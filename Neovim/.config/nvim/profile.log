SCRIPT  /Users/robertyang/Repos/Configs/Neovim/.config/coc/extensions/node_modules/coc-fzf-preview/autoload/fzf_preview/remote/util.vim
Sourced 1 time
Total time:   0.000275
 Self time:   0.000275

count  total (s)   self (s)
    1              0.000024 function! fzf_preview#remote#util#is_git_directory() abort
                              let git_root = system('git rev-parse --show-toplevel 2>/dev/null')
                              if git_root ==# ''
                                return v:false
                              else
                                return v:true
                              endif
                            endfunction
                            
    1              0.000008 function! fzf_preview#remote#util#project_root() abort
                              let git_root = system('git rev-parse --show-toplevel 2>/dev/null')
                              if git_root ==# ''
                                echomsg 'The current directory is not a git project'
                                return ''
                              endif
                            
                              return strpart(git_root, 0, strlen(git_root) - 1)
                            endfunction
                            
    1              0.000008 function! fzf_preview#remote#util#is_project_file(file, splitted_project_path) abort
                              let splitted_file_path = split(a:file, '/')
                              if len(splitted_file_path) == 0
                                return 0
                              endif
                            
                              let is_project_file = 1
                              let index = 0
                              for dir_name in a:splitted_project_path[:len(splitted_file_path) - 1]
                                if dir_name !=# splitted_file_path[index]
                                  let is_project_file = 0
                                endif
                                let index = index + 1
                              endfor
                            
                              return is_project_file
                            endfunction
                            
    1              0.000009 function! fzf_preview#remote#util#bufnr_and_lnum_to_resource(bufnr_and_lnum_list, splitted_project_path) abort
                              let result = []
                              for bufnr_and_lnum in a:bufnr_and_lnum_list
                                let bufnr = bufnr_and_lnum['bufnr']
                                let lnum = bufnr_and_lnum['lnum']
                                let bufinfos = getbufinfo(bufnr)
                            
                                if len(bufinfos) > 0
                                  let bufinfo = bufinfos[0]
                                  let file = bufinfo['name']
                            
                                  if fzf_preview#remote#util#is_project_file(file, a:splitted_project_path) && filereadable(file)
                                    let file = fnamemodify(file, ':.')
                                    let line_number = lnum
                                    let lines = getbufline(bufname(bufnr), lnum)
                            
                                    if len(lines) > 0
                                      let text = lines[0]
                                    else
                                      let text = ''
                                    endif
                            
                                    call add(result, { 'file': file, 'line': line_number, 'text': text })
                                  endif
                                endif
                              endfor
                            
                              return result
                            endfunction
                            
    1              0.000005 function! fzf_preview#remote#util#get_columns() abort
                              return &columns
                            endfunction
                            
    1              0.000005 function! fzf_preview#remote#util#uniq(list) abort
                              let result = []
                              for item in a:list
                                if index(result, item) == -1
                                  call add(result, item)
                                endif
                              endfor
                              return result
                            endfunction

SCRIPT  /Users/robertyang/Repos/Configs/Neovim/.config/coc/extensions/node_modules/coc-fzf-preview/autoload/fzf_preview/remote/resource/project_files.vim
Sourced 1 time
Total time:   0.000070
 Self time:   0.000070

count  total (s)   self (s)
    1              0.000025 function! fzf_preview#remote#resource#project_files#get(command) abort
                              return systemlist(a:command)
                            endfunction

SCRIPT  /Users/robertyang/Repos/Configs/Neovim/.config/coc/extensions/node_modules/coc-fzf-preview/autoload/fzf_preview/remote/window.vim
Sourced 1 time
Total time:   0.000139
 Self time:   0.000139

count  total (s)   self (s)
                            " TODO: Command other than fzf-preview saves wrong resumes
    1              0.000022 let s:resource_command_name = ''
                            
    1              0.000014 function! fzf_preview#remote#window#set_resource_command_name(command_name) abort
                              let s:resource_command_name = a:command_name
                            endfunction
                            
    1              0.000008 function! fzf_preview#remote#window#set_fzf_last_query(...) abort
                              if &filetype ==# 'fzf' && s:resource_command_name !=# ''
                                let matches = matchlist(getline('.'), '^\w\+\>.\(\(\w\|\s\|''\)\+\)')
                                if len(matches) > 0
                                  let query = substitute(substitute(matches[1], '\s\+$', '', ''), '^\s\+', '', '')
                                  if exists(':FzfPreviewRemoteEnvironment')
                                    call FzfPreviewDispatchResumeQuery(s:resource_command_name, query)
                                  else
                                    call CocAction('runCommand', 'fzf-preview-function.DispatchResumeQuery', [s:resource_command_name, query])
                                  endif
                                endif
                            
                                call timer_start(50, function('fzf_preview#remote#window#set_fzf_last_query'))
                              endif
                            endfunction

SCRIPT  /Users/robertyang/Repos/Configs/Neovim/.config/coc/extensions/node_modules/coc-fzf-preview/autoload/fzf_preview/remote/store.vim
Sourced 1 time
Total time:   0.000212
 Self time:   0.000212

count  total (s)   self (s)
    1              0.000038 let s:state = {}
                            
    1              0.000020 function! fzf_preview#remote#store#persist_store(state, module) abort
                              let s:state[a:module] = a:state
                            endfunction
                            
    1              0.000017 function! fzf_preview#remote#store#restore_store() abort
                              return s:state
                            endfunction

SCRIPT  /Users/robertyang/Repos/Configs/Neovim/.config/coc/extensions/node_modules/coc-fzf-preview/autoload/fzf_preview/remote/runner.vim
Sourced 1 time
Total time:   0.000067
 Self time:   0.000067

count  total (s)   self (s)
    1              0.000012 function! fzf_preview#remote#runner#fzf_run(params) abort
                              let source = a:params['source']
                              let options = a:params['options']
                              let handler = a:params['handler']
                              let env = a:params['environment']
                            
                              if env ==# 'remote'
                                let Sink = function('s:handler_wrapper', [handler])
                              elseif env ==# 'coc'
                                let Sink = function('s:coc_handler')
                              endif
                            
                              let window = g:fzf_preview_direct_window_option !=# '' ? g:fzf_preview_direct_window_option : { 'width': g:fzf_preview_floating_window_rate, 'height': g:fzf_preview_floating_window_rate }
                            
                              call fzf#run({
                              \ 'source':  source,
                              \ 'sink*':   Sink,
                              \ 'options': options,
                              \ 'window':  window,
                              \ })
                            endfunction
                            
    1              0.000005 function! s:handler_wrapper(handler, lines) abort
                              call call(a:handler, [a:lines])
                            endfunction
                            
    1              0.000003 function! s:coc_handler(lines) abort
                              call CocAction('runCommand', 'fzf-preview.HandleResource', [a:lines])
                            endfunction

SCRIPT  /Users/robertyang/Repos/Configs/Neovim/.config/nvim/plugged/vimspector/autoload/vimspector.vim
Sourced 1 time
Total time:   0.044063
 Self time:   0.001443

count  total (s)   self (s)
                            " vimspector - A multi-language debugging system for Vim
                            " Copyright 2018 Ben Jackson
                            "
                            " Licensed under the Apache License, Version 2.0 (the "License");
                            " you may not use this file except in compliance with the License.
                            " You may obtain a copy of the License at
                            "
                            "   http://www.apache.org/licenses/LICENSE-2.0
                            "
                            " Unless required by applicable law or agreed to in writing, software
                            " distributed under the License is distributed on an "AS IS" BASIS,
                            " WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                            " See the License for the specific language governing permissions and
                            " limitations under the License.
                            
                            
                            " Boilerplate {{{
    1              0.000026 let s:save_cpo = &cpoptions
    1              0.000033 set cpoptions&vim
                            " }}}
                            
    1              0.000012 function! s:Debug( ... ) abort
                              py3 <<EOF
                            if _vimspector_session is not None:
                              _vimspector_session._logger.debug( *vim.eval( 'a:000' ) )
                            EOF
                            endfunction
                            
                            
    1              0.000009 let s:enabled = v:null
                            
    1              0.000005 function! s:Initialised() abort
                              return s:enabled != v:null
                            endfunction
                            
    1              0.000004 function! s:Enabled() abort
                              if !s:Initialised()
                                let s:enabled = vimspector#internal#state#Reset()
                              endif
                            
                              return s:enabled
                            endfunction
                            
    1              0.000005 function! vimspector#Launch() abort
                              if !s:Enabled()
                                return
                              endif
                              py3 _vimspector_session.Start()
                            endfunction
                            
    1              0.000007 function! vimspector#LaunchWithSettings( settings ) abort
                              if !s:Enabled()
                                return
                              endif
                              py3 _vimspector_session.Start( launch_variables = vim.eval( 'a:settings' ) )
                            endfunction
                            
    1              0.000004 function! vimspector#Reset() abort
                              if !s:Enabled()
                                return
                              endif
                              py3 _vimspector_session.Reset()
                            endfunction
                            
    1              0.000004 function! vimspector#Restart() abort
                              if !s:Enabled()
                                return
                              endif
                              py3 _vimspector_session.Restart()
                            endfunction
                            
    1              0.000004 function! vimspector#ClearBreakpoints() abort
                              if !s:Enabled()
                                return
                              endif
                              py3 _vimspector_session.ClearBreakpoints()
                            endfunction
                            
    1              0.000004 function! vimspector#ToggleBreakpoint( ... ) abort
                              if !s:Enabled()
                                return
                              endif
                              if a:0 == 0
                                let options = {}
                              else
                                let options = a:1
                              endif
                              py3 _vimspector_session.ToggleBreakpoint( vim.eval( 'options' ) )
                            endfunction
                            
    1              0.000007 function! vimspector#SetLineBreakpoint( file_name, line_num, ... ) abort
                              if !s:Enabled()
                                return
                              endif
                              if a:0 == 0
                                let options = {}
                              else
                                let options = a:1
                              endif
                              py3 _vimspector_session.SetLineBreakpoint(
                                    \ vim.eval( 'a:file_name' ),
                                    \ int( vim.eval( 'a:line_num' ) ),
                                    \ vim.eval( 'options' ) )
                            endfunction
                            
    1              0.000007 function! vimspector#ClearLineBreakpoint( file_name, line_num ) abort
                              if !s:Enabled()
                                return
                              endif
                              py3 _vimspector_session.ClearLineBreakpoint(
                                    \ vim.eval( 'a:file_name' ),
                                    \ int( vim.eval( 'a:line_num' ) ) )
                            endfunction
                            
                            
    1              0.000005 function! vimspector#RunToCursor() abort
                              if !s:Enabled()
                                return
                              endif
                              py3 _vimspector_session.RunTo(
                                    \ vim.eval( "expand( '%' )" ),
                                    \ int( vim.eval( "line( '.' )" ) ) )
                            endfunction
                            
                            
    1              0.000006 function! vimspector#AddFunctionBreakpoint( function, ... ) abort
                              if !s:Enabled()
                                return
                              endif
                              if a:0 == 0
                                let options = {}
                              else
                                let options = a:1
                              endif
                              py3 _vimspector_session.AddFunctionBreakpoint( vim.eval( 'a:function' ),
                                                                           \ vim.eval( 'options' ) )
                            endfunction
                            
    1              0.000004 function! vimspector#StepOver() abort
                              if !s:Enabled()
                                return
                              endif
                              py3 _vimspector_session.StepOver()
                            endfunction
                            
    1              0.000004 function! vimspector#StepInto() abort
                              if !s:Enabled()
                                return
                              endif
                              py3 _vimspector_session.StepInto()
                            endfunction
                            
    1              0.000004 function! vimspector#StepOut() abort
                              if !s:Enabled()
                                return
                              endif
                              py3 _vimspector_session.StepOut()
                            endfunction
                            
    1              0.000004 function! vimspector#Continue() abort
                              if !s:Enabled()
                                return
                              endif
                              py3 _vimspector_session.Continue()
                            endfunction
                            
    1              0.000004 function! vimspector#Pause() abort
                              if !s:Enabled()
                                return
                              endif
                              py3 _vimspector_session.Pause()
                            endfunction
                            
    1              0.000004 function! vimspector#Stop() abort
                              if !s:Enabled()
                                return
                              endif
                              py3 _vimspector_session.Stop()
                            endfunction
                            
    1              0.000004 function! vimspector#ExpandVariable() abort
                              if !s:Enabled()
                                return
                              endif
                              py3 _vimspector_session.ExpandVariable()
                            endfunction
                            
    1              0.000014 function! vimspector#DeleteWatch() abort
                              if !s:Enabled()
                                return
                              endif
                              py3 _vimspector_session.DeleteWatch()
                            endfunction
                            
    1              0.000004 function! vimspector#GoToFrame() abort
                              if !s:Enabled()
                                return
                              endif
                              py3 _vimspector_session.ExpandFrameOrThread()
                            endfunction
                            
    1              0.000004 function! vimspector#AddWatch( ... ) abort
                              if !s:Enabled()
                                return
                              endif
                              if a:0 == 0
                                let expr = input( 'Enter watch expression: ' )
                              else
                                let expr = a:1
                              endif
                            
                              if expr ==# ''
                                return
                              endif
                            
                              py3 _vimspector_session.AddWatch( vim.eval( 'expr' ) )
                            endfunction
                            
    1              0.000005 function! vimspector#AddWatchPrompt( expr ) abort
                              if !s:Enabled()
                                return
                              endif
                              stopinsert
                              setlocal nomodified
                              call vimspector#AddWatch( a:expr )
                            endfunction
                            
    1              0.000004 function! vimspector#Evaluate( expr ) abort
                              if !s:Enabled()
                                return
                              endif
                              py3 _vimspector_session.ShowOutput( 'Console' )
                              py3 _vimspector_session.EvaluateConsole( vim.eval( 'a:expr' ), True )
                            endfunction
                            
    1              0.000005 function! vimspector#EvaluateConsole( expr ) abort
                              if !s:Enabled()
                                return
                              endif
                              stopinsert
                              setlocal nomodified
                              py3 _vimspector_session.EvaluateConsole( vim.eval( 'a:expr' ), False )
                            endfunction
                            
    1              0.000004 function! vimspector#ShowOutput( ... ) abort
                              if !s:Enabled()
                                return
                              endif
                              if a:0 == 1
                                py3 _vimspector_session.ShowOutput( vim.eval( 'a:1' ) )
                              else
                                py3 _vimspector_session.ShowOutput( 'Console' )
                              endif
                            endfunction
                            
    1              0.000007 function! vimspector#ShowOutputInWindow( win_id, category ) abort
                              if !s:Enabled()
                                return
                              endif
                              py3 __import__( 'vimspector',
                                    \         fromlist = [ 'output' ] ).output.ShowOutputInWindow(
                                    \           int( vim.eval( 'a:win_id' ) ),
                                    \           vim.eval( 'a:category' ) )
                            endfunction
                            
    1              0.000004 function! vimspector#ToggleLog() abort
                              if !s:Enabled()
                                return
                              endif
                              py3 _vimspector_session.ToggleLog()
                            endfunction
                            
    1              0.000004 function! vimspector#ListBreakpoints() abort
                              if !s:Enabled()
                                return
                              endif
                              py3 _vimspector_session.ListBreakpoints()
                            endfunction
                            
    1              0.000004 function! vimspector#GetConfigurations() abort
                              if !s:Enabled()
                                return
                              endif
                              let configurations = py3eval(
                                          \ 'list( _vimspector_session.GetConfigurations()[ 1 ].keys() )'
                                          \ . ' if _vimspector_session else []' )
                              return configurations
                            endfunction
                            
    1              0.000006 function! vimspector#CompleteOutput( ArgLead, CmdLine, CursorPos ) abort
                              if !s:Enabled()
                                return
                              endif
                              let buffers = py3eval( '_vimspector_session.GetOutputBuffers() '
                                                   \ . ' if _vimspector_session else []' )
                              return join( buffers, "\n" )
                            endfunction
                            
    1              0.000004 py3 <<EOF
                            def _vimspector_GetExprCompletions( ArgLead, prev_non_keyword_char ):
                              if not _vimspector_session:
                                return []
                            
                              items = []
                              for candidate in _vimspector_session.GetCompletionsSync(
                                ArgLead,
                                prev_non_keyword_char ):
                            
                                label = candidate.get( 'text', candidate[ 'label' ] )
                            
                                start = prev_non_keyword_char - 1
                            
                                if 'start' in candidate and 'length' in candidate:
                                  start = candidate[ 'start' ]
                            
                                items.append( ArgLead[ 0 : start ] + label )
                            
                              return items
                            EOF
                            
    1              0.000021 function! vimspector#CompleteExpr( ArgLead, CmdLine, CursorPos ) abort
                              if !s:Enabled()
                                return
                              endif
                            
                              let col = len( a:ArgLead )
                              let prev_non_keyword_char = match( a:ArgLead[ 0 : col - 1 ], '\k*$' ) + 1
                            
                              return join( py3eval( '_vimspector_GetExprCompletions( '
                                                  \ . 'vim.eval( "a:ArgLead" ), '
                                                  \ . 'int( vim.eval( "prev_non_keyword_char" ) ) )' ),
                                         \ "\n" )
                            endfunction
                            
    1              0.000016 let s:latest_completion_request = {}
                            
    1              0.000008 function! vimspector#CompleteFuncSync( prompt, find_start, query ) abort
                              if py3eval( 'not _vimspector_session' )
                                if a:find_start
                                  return -3
                                endif
                                return v:none
                              endif
                            
                              if a:find_start
                            
                                " We're busy
                                if !empty( s:latest_completion_request )
                                  return -3
                                endif
                            
                                let line = getline( line( '.' ) )[ len( a:prompt ) : ]
                                let col = col( '.' ) - len( a:prompt )
                            
                                " It seems that most servers don't implement the 'start' parameter, which is
                                " clearly necessary, as they all seem to assume a specific behaviour, which
                                " is undocumented.
                            
                                let s:latest_completion_request.items =
                                      \ py3eval( '_vimspector_session.GetCompletionsSync( '
                                               \.'  vim.eval( "line" ), '
                                               \.'  int( vim.eval( "col" ) ) )' )
                            
                                let s:latest_completion_request.line = line
                                let s:latest_completion_request.col = col
                            
                                let prev_non_keyword_char = match( line[ 0 : col - 1 ], '\k*$' ) + 1
                                let query_len = col - prev_non_keyword_char
                            
                                let start_pos = col
                                for item in s:latest_completion_request.items
                                  if !has_key( item, 'start' ) || !has_key( item, 'length' )
                                    " The specification states that if start is not supplied, isertion
                                    " should be at the requested column. But about 0 of the servers actually
                                    " implement that
                                    " (https://github.com/microsoft/debug-adapter-protocol/issues/138)
                                    let item.start = prev_non_keyword_char
                                    let item.length = query_len
                                  else
                                    " For some reason, the returned start value is 0-indexed even though we
                                    " use columnsStartAt1
                                    let item.start += 1
                                  endif
                            
                                  if !has_key( item, 'text' )
                                    let item.text = item.label
                                  endif
                            
                                  if item.start < start_pos
                                    let start_pos = item.start
                                  endif
                                endfor
                            
                                let s:latest_completion_request.start_pos = start_pos
                                let s:latest_completion_request.prompt = a:prompt
                            
                                " call s:Debug( 'FindStart: %s', {
                                "       \ 'line': line,
                                "       \ 'col': col,
                                "       \ 'prompt': len( a:prompt ),
                                "       \ 'start_pos': start_pos,
                                "       \ 'returning': ( start_pos + len( a:prompt ) ) - 1,
                                "       \ } )
                            
                                " start_pos is 1-based and the return of findstart is 0-based
                                return ( start_pos + len( a:prompt ) ) - 1
                              else
                                let items = []
                                let pfxlen = len( s:latest_completion_request.prompt )
                                for item in s:latest_completion_request.items
                                  if item.start > s:latest_completion_request.start_pos
                                    " fix up the text (insert anything that is already present in the line
                                    " that would be erased by the fixed-up earlier start position)
                                    "
                                    " both start_pos and item.start are 1-based
                                    let item.text = s:latest_completion_request.line[
                                          \ s:latest_completion_request.start_pos + pfxlen - 1 :
                                          \  item.start + pfxlen - 1 ] . item.text
                                  endif
                            
                                  if item.length > len( a:query )
                                    " call s:Debug( 'Rejecting %s, length is greater than %s',
                                    "       \ item,
                                    "       \ len( a:query ) )
                                    continue
                                  endif
                            
                                  call add( items, { 'word': item.text,
                                                   \ 'abbr': item.label,
                                                   \ 'menu': get( item, 'type', '' ),
                                                   \ 'icase': 1,
                                                   \ } )
                                endfor
                                let s:latest_completion_request = {}
                            
                                " call s:Debug( 'Items: %s', items )
                                return { 'words': items, 'refresh': 'always' }
                              endif
                            endfunction
                            
    1              0.000007 function! vimspector#OmniFuncWatch( find_start, query ) abort
                              return vimspector#CompleteFuncSync( 'Expression: ', a:find_start, a:query )
                            endfunction
                            
    1              0.000006 function! vimspector#OmniFuncConsole( find_start, query ) abort
                              return vimspector#CompleteFuncSync( '> ', a:find_start, a:query )
                            endfunction
                            
    1              0.000005 function! vimspector#Install( bang, ... ) abort
                              if !s:Enabled()
                                return
                              endif
                              let prefix = vimspector#internal#state#GetAPIPrefix()
                              py3 __import__( 'vimspector',
                                    \         fromlist = [ 'installer' ] ).installer.RunInstaller(
                                    \           vim.eval( 'prefix' ),
                                    \           vim.eval( 'a:bang' ) == '!',
                                    \           *vim.eval( 'a:000' ) )
                            endfunction
                            
    1              0.000007 function! vimspector#CompleteInstall( ArgLead, CmdLine, CursorPos ) abort
                              if !s:Enabled()
                                return
                              endif
                              return py3eval( '"\n".join('
                                            \ .   '__import__( "vimspector", fromlist = [ "gadgets" ] )'
                                            \ .   '.gadgets.GADGETS.keys() '
                                            \ . ')' )
                            endfunction
                            
    1              0.000005 function! vimspector#Update( bang, ... ) abort
                              if !s:Enabled()
                                return
                              endif
                            
                              let prefix = vimspector#internal#state#GetAPIPrefix()
                              py3 __import__( 'vimspector',
                                    \         fromlist = [ 'installer' ] ).installer.RunUpdate(
                                    \           vim.eval( 'prefix' ),
                                    \           vim.eval( 'a:bang' ) == '!',
                                    \           *vim.eval( 'a:000' ) )
                            endfunction
                            
    1              0.000005 function! vimspector#AbortInstall() abort
                              if !s:Enabled()
                                return
                              endif
                            
                              let prefix = vimspector#internal#state#GetAPIPrefix()
                              py3 __import__( 'vimspector', fromlist = [ 'installer' ] ).installer.Abort()
                            endfunction
                            
                            
    1              0.000005 function! vimspector#OnBufferCreated( file_name ) abort
                              if len( a:file_name ) == 0
                                return
                              endif
                            
                              " Don't actually load up vimsepctor python in autocommands that trigger
                              " regularly. We'll only create the session obkect in s:Enabled()
                              if !s:Initialised()
                                return
                              endif
                            
                              if !s:Enabled()
                                return
                              endif
                            
                              py3 _vimspector_session.RefreshSigns( vim.eval( 'a:file_name' ) )
                            endfunction
                            
                            
                            " Boilerplate {{{
    1              0.000026 let &cpoptions=s:save_cpo
    1              0.000007 unlet s:save_cpo
                            " }}}

SCRIPT  /Users/robertyang/Repos/Configs/Neovim/.config/nvim/plugged/vim-repeat/autoload/repeat.vim
Sourced 1 time
Total time:   0.001915
 Self time:   0.001915

count  total (s)   self (s)
                            " repeat.vim - Let the repeat command repeat plugin maps
                            " Maintainer:   Tim Pope
                            " Version:      1.2
                            " GetLatestVimScripts: 2136 1 :AutoInstall: repeat.vim
                            
                            " Installation:
                            " Place in either ~/.vim/plugin/repeat.vim (to load at start up) or
                            " ~/.vim/autoload/repeat.vim (to load automatically as needed).
                            "
                            " License:
                            " Copyright (c) Tim Pope.  Distributed under the same terms as Vim itself.
                            " See :help license
                            "
                            " Developers:
                            " Basic usage is as follows:
                            "
                            "   silent! call repeat#set("\<Plug>MappingToRepeatCommand",3)
                            "
                            " The first argument is the mapping that will be invoked when the |.| key is
                            " pressed.  Typically, it will be the same as the mapping the user invoked.
                            " This sequence will be stuffed into the input queue literally.  Thus you must
                            " encode special keys by prefixing them with a backslash inside double quotes.
                            "
                            " The second argument is the default count.  This is the number that will be
                            " prefixed to the mapping if no explicit numeric argument was given.  The
                            " value of the v:count variable is usually correct and it will be used if the
                            " second parameter is omitted.  If your mapping doesn't accept a numeric
                            " argument and you never want to receive one, pass a value of -1.
                            "
                            " Make sure to call the repeat#set function _after_ making changes to the
                            " file.
                            "
                            " For mappings that use a register and want the same register used on
                            " repetition, use:
                            "
                            "   silent! call repeat#setreg("\<Plug>MappingToRepeatCommand", v:register)
                            "
                            " This function can (and probably needs to be) called before making changes to
                            " the file (as those typically clear v:register).  Therefore, the call sequence
                            " in your mapping will look like this:
                            "
                            "   nnoremap <silent> <Plug>MyMap
                            "   \   :<C-U>execute 'silent! call repeat#setreg("\<lt>Plug>MyMap", v:register)'<Bar>
                            "   \   call <SID>MyFunction(v:register, ...)<Bar>
                            "   \   silent! call repeat#set("\<lt>Plug>MyMap")<CR>
                            
    1              0.000037 if exists("g:loaded_repeat") || &cp || v:version < 700
                                finish
    1              0.000002 endif
    1              0.000014 let g:loaded_repeat = 1
                            
    1              0.000006 let g:repeat_tick = -1
    1              0.000008 let g:repeat_reg = ['', '']
                            
                            " Special function to avoid spurious repeats in a related, naturally repeating
                            " mapping when your repeatable mapping doesn't increase b:changedtick.
    1              0.000006 function! repeat#invalidate()
                                autocmd! repeat_custom_motion
                                let g:repeat_tick = -1
                            endfunction
                            
    1              0.000003 function! repeat#set(sequence,...)
                                let g:repeat_sequence = a:sequence
                                let g:repeat_count = a:0 ? a:1 : v:count
                                let g:repeat_tick = b:changedtick
                                augroup repeat_custom_motion
                                    autocmd!
                                    autocmd CursorMoved <buffer> let g:repeat_tick = b:changedtick | autocmd! repeat_custom_motion
                                augroup END
                            endfunction
                            
    1              0.000002 function! repeat#setreg(sequence,register)
                                let g:repeat_reg = [a:sequence, a:register]
                            endfunction
                            
                            
    1              0.000004 function! s:default_register()
                                let values = split(&clipboard, ',')
                                if index(values, 'unnamedplus') != -1
                                    return '+'
                                elseif index(values, 'unnamed') != -1
                                    return '*'
                                else
                                    return '"'
                                endif
                            endfunction
                            
    1              0.000002 function! repeat#run(count)
                                try
                                    if g:repeat_tick == b:changedtick
                                        let r = ''
                                        if g:repeat_reg[0] ==# g:repeat_sequence && !empty(g:repeat_reg[1])
                                            " Take the original register, unless another (non-default, we
                                            " unfortunately cannot detect no vs. a given default register)
                                            " register has been supplied to the repeat command (as an
                                            " explicit override).
                                            let regname = v:register ==# s:default_register() ? g:repeat_reg[1] : v:register
                                            if regname ==# '='
                                                " This causes a re-evaluation of the expression on repeat, which
                                                " is what we want.
                                                let r = '"=' . getreg('=', 1) . "\<CR>"
                                            else
                                                let r = '"' . regname
                                            endif
                                        endif
                            
                                        let c = g:repeat_count
                                        let s = g:repeat_sequence
                                        let cnt = c == -1 ? "" : (a:count ? a:count : (c ? c : ''))
                                        if ((v:version == 703 && has('patch100')) || (v:version == 704 && !has('patch601')))
                                            exe 'norm ' . r . cnt . s
                                        elseif v:version <= 703
                                            call feedkeys(r . cnt, 'n')
                                            call feedkeys(s, '')
                                        else
                                            call feedkeys(s, 'i')
                                            call feedkeys(r . cnt, 'ni')
                                        endif
                                    else
                                        if ((v:version == 703 && has('patch100')) || (v:version == 704 && !has('patch601')))
                                            exe 'norm! '.(a:count ? a:count : '') . '.'
                                        else
                                            call feedkeys((a:count ? a:count : '') . '.', 'ni')
                                        endif
                                    endif
                                catch /^Vim(normal):/
                                    return 'echoerr v:errmsg'
                                endtry
                                return ''
                            endfunction
                            
    1              0.000003 function! repeat#wrap(command,count)
                                let preserve = (g:repeat_tick == b:changedtick)
                                call feedkeys((a:count ? a:count : '').a:command, 'n')
                                exe (&foldopen =~# 'undo\|all' ? 'norm! zv' : '')
                                if preserve
                                    let g:repeat_tick = b:changedtick
                                endif
                            endfunction
                            
    1              0.000066 nnoremap <silent> <Plug>(RepeatDot)      :<C-U>exe repeat#run(v:count)<CR>
    1              0.000042 nnoremap <silent> <Plug>(RepeatUndo)     :<C-U>call repeat#wrap('u',v:count)<CR>
    1              0.000036 nnoremap <silent> <Plug>(RepeatUndoLine) :<C-U>call repeat#wrap('U',v:count)<CR>
    1              0.000033 nnoremap <silent> <Plug>(RepeatRedo)     :<C-U>call repeat#wrap("\<Lt>C-R>",v:count)<CR>
                            
    1              0.000056 if !hasmapto('<Plug>(RepeatDot)', 'n')
    1              0.000025     nmap . <Plug>(RepeatDot)
    1              0.000001 endif
    1              0.000046 if !hasmapto('<Plug>(RepeatUndo)', 'n')
    1              0.000021     nmap u <Plug>(RepeatUndo)
    1              0.000001 endif
    1              0.000059 if maparg('U','n') ==# '' && !hasmapto('<Plug>(RepeatUndoLine)', 'n')
    1              0.000019     nmap U <Plug>(RepeatUndoLine)
    1              0.000001 endif
    1              0.000040 if !hasmapto('<Plug>(RepeatRedo)', 'n')
    1              0.000020     nmap <C-R> <Plug>(RepeatRedo)
    1              0.000001 endif
                            
    1              0.000004 augroup repeatPlugin
    1              0.001145     autocmd!
    1              0.000024     autocmd BufLeave,BufWritePre,BufReadPre * let g:repeat_tick = (g:repeat_tick == b:changedtick || g:repeat_tick == 0) ? 0 : -1
    1              0.000006     autocmd BufEnter,BufWritePost * if g:repeat_tick == 0|let g:repeat_tick = b:changedtick|endif
    1              0.000002 augroup END
                            
                            " vim:set ft=vim et sw=4 sts=4:

SCRIPT  /Users/robertyang/Repos/Configs/Neovim/.config/coc/extensions/node_modules/coc-fzf-preview/autoload/fzf_preview/remote/resource/directory_files.vim
Sourced 1 time
Total time:   0.000049
 Self time:   0.000049

count  total (s)   self (s)
    1              0.000021 function! fzf_preview#remote#resource#directory_files#get(command) abort
                              return systemlist(a:command)
                            endfunction

SCRIPT  /usr/local/Cellar/neovim/HEAD-40a7427/share/nvim/runtime/ftplugin/vim.vim
Sourced 6 times
Total time:   0.005212
 Self time:   0.005212

count  total (s)   self (s)
                            " Vim filetype plugin
                            " Language:	Vim
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last Change:	2018 Aug 07
                            
                            " Only do this when not done yet for this buffer
    6              0.000136 if exists("b:did_ftplugin")
                              finish
    6              0.000011 endif
                            
                            " Don't load another plugin for this buffer
    6              0.000048 let b:did_ftplugin = 1
                            
    6              0.000099 let s:cpo_save = &cpo
    6              0.000123 set cpo-=C
                            
    6              0.000054 if !exists('*VimFtpluginUndo')
    1              0.000007   func VimFtpluginUndo()
                                setl fo< isk< com< tw< commentstring< keywordprg<
                                if exists('b:did_add_maps')
                                  silent! nunmap <buffer> [[
                                  silent! vunmap <buffer> [[
                                  silent! nunmap <buffer> ]]
                                  silent! vunmap <buffer> ]]
                                  silent! nunmap <buffer> []
                                  silent! vunmap <buffer> []
                                  silent! nunmap <buffer> ][
                                  silent! vunmap <buffer> ][
                                  silent! nunmap <buffer> ]"
                                  silent! vunmap <buffer> ]"
                                  silent! nunmap <buffer> ["
                                  silent! vunmap <buffer> ["
                                 endif
                                unlet! b:match_ignorecase b:match_words b:match_skip b:did_add_maps
                              endfunc
    6              0.000013 endif
                            
    6              0.000043 let b:undo_ftplugin = "call VimFtpluginUndo()"
                            
                            " Set 'formatoptions' to break comment lines but not other lines,
                            " and insert the comment leader when hitting <CR> or using "o".
    6              0.000120 setlocal fo-=t fo+=croql
                            
                            " To allow tag lookup via CTRL-] for autoload functions, '#' must be a
                            " keyword character.  E.g., for netrw#Nread().
    6              0.000475 setlocal isk+=#
                            
                            " Use :help to lookup the keyword under the cursor with K.
    6              0.000049 setlocal keywordprg=:help
                            
                            " Set 'comments' to format dashed lists in comments
    6              0.000069 setlocal com=sO:\"\ -,mO:\"\ \ ,eO:\"\",:\"
                            
                            " Format comments to be up to 78 characters long
    6              0.000032 if &tw == 0
    6              0.000078   setlocal tw=78
    6              0.000012 endif
                            
                            " Comments start with a double quote
    6              0.000039 setlocal commentstring=\"%s
                            
                            " Prefer Vim help instead of manpages.
    6              0.000036 setlocal keywordprg=:help
                            
    6              0.000073 if !exists("no_plugin_maps") && !exists("no_vim_maps")
    6              0.000058   let b:did_add_maps = 1
                            
                              " Move around functions.
    6              0.000433   nnoremap <silent><buffer> [[ m':call search('^\s*fu\%[nction]\>', "bW")<CR>
    6              0.000189   vnoremap <silent><buffer> [[ m':<C-U>exe "normal! gv"<Bar>call search('^\s*fu\%[nction]\>', "bW")<CR>
    6              0.000151   nnoremap <silent><buffer> ]] m':call search('^\s*fu\%[nction]\>', "W")<CR>
    6              0.000157   vnoremap <silent><buffer> ]] m':<C-U>exe "normal! gv"<Bar>call search('^\s*fu\%[nction]\>', "W")<CR>
    6              0.000143   nnoremap <silent><buffer> [] m':call search('^\s*endf\%[unction]\>', "bW")<CR>
    6              0.000156   vnoremap <silent><buffer> [] m':<C-U>exe "normal! gv"<Bar>call search('^\s*endf\%[unction]\>', "bW")<CR>
    6              0.000140   nnoremap <silent><buffer> ][ m':call search('^\s*endf\%[unction]\>', "W")<CR>
    6              0.000150   vnoremap <silent><buffer> ][ m':<C-U>exe "normal! gv"<Bar>call search('^\s*endf\%[unction]\>', "W")<CR>
                            
                              " Move around comments
    6              0.000139   nnoremap <silent><buffer> ]" :call search('^\(\s*".*\n\)\@<!\(\s*"\)', "W")<CR>
    6              0.000184   vnoremap <silent><buffer> ]" :<C-U>exe "normal! gv"<Bar>call search('^\(\s*".*\n\)\@<!\(\s*"\)', "W")<CR>
    6              0.000155   nnoremap <silent><buffer> [" :call search('\%(^\s*".*\n\)\%(^\s*"\)\@!', "bW")<CR>
    6              0.000159   vnoremap <silent><buffer> [" :<C-U>exe "normal! gv"<Bar>call search('\%(^\s*".*\n\)\%(^\s*"\)\@!', "bW")<CR>
    6              0.000012 endif
                            
                            " Let the matchit plugin know what items can be matched.
    6              0.000049 if exists("loaded_matchit")
    6              0.000035   let b:match_ignorecase = 0
    6              0.000120   let b:match_words =
                            	\ '\<fu\%[nction]\>:\<retu\%[rn]\>:\<endf\%[unction]\>,' .
                             	\ '\<\(wh\%[ile]\|for\)\>:\<brea\%[k]\>:\<con\%[tinue]\>:\<end\(w\%[hile]\|fo\%[r]\)\>,' .
                            	\ '\<if\>:\<el\%[seif]\>:\<en\%[dif]\>,' .
                            	\ '\<try\>:\<cat\%[ch]\>:\<fina\%[lly]\>:\<endt\%[ry]\>,' .
                            	\ '\<aug\%[roup]\s\+\%(END\>\)\@!\S:\<aug\%[roup]\s\+END\>,'
                              " Ignore syntax region commands and settings, any 'en*' would clobber
                              " if-endif.
                              " - set spl=de,en
                              " - au! FileType javascript syntax region foldBraces start=/{/ end=/}/ 
    6              0.000044   let b:match_skip = 'synIDattr(synID(line("."),col("."),1),"name")
                                    \ =~? "comment\\|string\\|vimSynReg\\|vimSet"'
    6              0.000009 endif
                            
    6              0.000087 let &cpo = s:cpo_save
    6              0.000046 unlet s:cpo_save
                            
                            " removed this, because 'cpoptions' is a global option.
                            " setlocal cpo+=M		" makes \%( match \)

SCRIPT  /Users/robertyang/Repos/Configs/Neovim/.config/nvim/plugged/vim-textobj-function/after/ftplugin/vim/textobj-function.vim
Sourced 6 times
Total time:   0.003301
 Self time:   0.003301

count  total (s)   self (s)
                            " Vim additional ftplugin: vim/textobj-function
                            " Version: 0.4.0
                            " Copyright (C) 2007-2014 Kana Natsuno <http://whileimautomaton.net/>
                            " License: MIT license  {{{
                            "     Permission is hereby granted, free of charge, to any person obtaining
                            "     a copy of this software and associated documentation files (the
                            "     "Software"), to deal in the Software without restriction, including
                            "     without limitation the rights to use, copy, modify, merge, publish,
                            "     distribute, sublicense, and/or sell copies of the Software, and to
                            "     permit persons to whom the Software is furnished to do so, subject to
                            "     the following conditions:
                            "
                            "     The above copyright notice and this permission notice shall be included
                            "     in all copies or substantial portions of the Software.
                            "
                            "     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
                            "     OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
                            "     MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
                            "     IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
                            "     CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
                            "     TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
                            "     SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
                            " }}}
                            
                            
                            
                            
    6              0.000200 let b:textobj_function_select = function('textobj#function#vim#select')
                            
                            
                            
                            
    6              0.000061 if exists('b:undo_ftplugin')
    6              0.000048   let b:undo_ftplugin .= '|'
                            else
                              let b:undo_ftplugin = ''
    6              0.000013 endif
    6              0.000348 let b:undo_ftplugin .= 'unlet b:textobj_function_select'
                            
                            " __END__
                            " vim: foldmethod=marker

SCRIPT  /usr/local/Cellar/neovim/HEAD-40a7427/share/nvim/runtime/indent/vim.vim
Sourced 6 times
Total time:   0.002861
 Self time:   0.002861

count  total (s)   self (s)
                            " Vim indent file
                            " Language:	Vim script
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last Change:	2016 Jun 27
                            
                            " Only load this indent file when no other was loaded.
    6              0.000101 if exists("b:did_indent")
                              finish
    6              0.000010 endif
    6              0.000042 let b:did_indent = 1
                            
    6              0.000096 setlocal indentexpr=GetVimIndent()
    6              0.000062 setlocal indentkeys+==end,=else,=cat,=fina,=END,0\\,0=\"\\\ 
                            
    6              0.000034 let b:undo_indent = "setl indentkeys< indentexpr<"
                            
                            " Only define the function once.
    6              0.000046 if exists("*GetVimIndent")
    5              0.000011   finish
    1              0.000002 endif
    1              0.000016 let s:keepcpo= &cpo
    1              0.000017 set cpo&vim
                            
    1              0.000015 function GetVimIndent()
                              let ignorecase_save = &ignorecase
                              try
                                let &ignorecase = 0
                                return GetVimIndentIntern()
                              finally
                                let &ignorecase = ignorecase_save
                              endtry
                            endfunc
                            
    1              0.000008 let s:lineContPat = '^\s*\(\\\|"\\ \)'
                            
    1              0.000005 function GetVimIndentIntern()
                              " Find a non-blank line above the current line.
                              let lnum = prevnonblank(v:lnum - 1)
                            
                              " If the current line doesn't start with '\' or '"\ ' and below a line that
                              " starts with '\' or '"\ ', use the indent of the line above it.
                              let cur_text = getline(v:lnum)
                              if cur_text !~ s:lineContPat
                                while lnum > 0 && getline(lnum) =~ s:lineContPat
                                  let lnum = lnum - 1
                                endwhile
                              endif
                            
                              " At the start of the file use zero indent.
                              if lnum == 0
                                return 0
                              endif
                              let prev_text = getline(lnum)
                            
                              " Add a 'shiftwidth' after :if, :while, :try, :catch, :finally, :function
                              " and :else.  Add it three times for a line that starts with '\' or '"\ '
                              " after a line that doesn't (or g:vim_indent_cont if it exists).
                              let ind = indent(lnum)
                              if cur_text =~ s:lineContPat && v:lnum > 1 && prev_text !~ s:lineContPat
                                if exists("g:vim_indent_cont")
                                  let ind = ind + g:vim_indent_cont
                                else
                                  let ind = ind + shiftwidth() * 3
                                endif
                              elseif prev_text =~ '^\s*aug\%[roup]\s\+' && prev_text !~ '^\s*aug\%[roup]\s\+[eE][nN][dD]\>'
                                let ind = ind + shiftwidth()
                              else
                                " A line starting with :au does not increment/decrement indent.
                                if prev_text !~ '^\s*au\%[tocmd]'
                                  let i = match(prev_text, '\(^\||\)\s*\(if\|wh\%[ile]\|for\|try\|cat\%[ch]\|fina\%[lly]\|fu\%[nction]\|el\%[seif]\)\>')
                                  if i >= 0
                            	let ind += shiftwidth()
                            	if strpart(prev_text, i, 1) == '|' && has('syntax_items')
                            	      \ && synIDattr(synID(lnum, i, 1), "name") =~ '\(Comment\|String\)$'
                            	  let ind -= shiftwidth()
                            	endif
                                  endif
                                endif
                              endif
                            
                              " If the previous line contains an "end" after a pipe, but not in an ":au"
                              " command.  And not when there is a backslash before the pipe.
                              " And when syntax HL is enabled avoid a match inside a string.
                              let i = match(prev_text, '[^\\]|\s*\(ene\@!\)')
                              if i > 0 && prev_text !~ '^\s*au\%[tocmd]'
                                if !has('syntax_items') || synIDattr(synID(lnum, i + 2, 1), "name") !~ '\(Comment\|String\)$'
                                  let ind = ind - shiftwidth()
                                endif
                              endif
                            
                            
                              " Subtract a 'shiftwidth' on a :endif, :endwhile, :catch, :finally, :endtry,
                              " :endfun, :else and :augroup END.
                              if cur_text =~ '^\s*\(ene\@!\|cat\|fina\|el\|aug\%[roup]\s\+[eE][nN][dD]\)'
                                let ind = ind - shiftwidth()
                              endif
                            
                              return ind
                            endfunction
                            
    1              0.000021 let &cpo = s:keepcpo
    1              0.000007 unlet s:keepcpo
                            
                            " vim:sw=2

SCRIPT  /usr/local/Cellar/neovim/HEAD-40a7427/share/nvim/runtime/syntax/vim.vim
Sourced 6 times
Total time:   0.125892
 Self time:   0.125892

count  total (s)   self (s)
                            " Vim syntax file
                            
                            " #############################################################################
                            " #############################################################################
                            " Note: Be careful when merging the upstream version of this file.
                            "       Much of this is generated by scripts/genvimvim.lua
                            "       (installs to $VIMRUNTIME/syntax/vim/generated.vim)
                            " #############################################################################
                            " #############################################################################
                            
                            " Quit when a syntax file was already loaded {{{2
    6              0.000151 if exists("b:current_syntax")
                              finish
    6              0.000011 endif
    6              0.000100 let s:keepcpo= &cpo
    6              0.000143 set cpo&vim
                            
                            " vimTodo: contains common special-notices for comments {{{2
                            " Use the vimCommentGroup cluster to add your own.
    6              0.000900 syn keyword vimTodo contained	COMBAK	FIXME	TODO	XXX
    6              0.000133 syn cluster vimCommentGroup	contains=vimTodo,@Spell
                            
                            " Special and plugin vim commands {{{2
    6              0.000224 syn match   vimCommand contained	"\<z[-+^.=]\=\>"
    6              0.000113 syn keyword vimOnlyCommand contained	fix[del] op[en] sh[ell] P[rint]
    6              0.000086 syn keyword vimStdPlugin contained	DiffOrig Man N[ext] S TOhtml XMLent XMLns
                            
                            " Vim-specific options {{{2
    6              0.000285 syn keyword vimOnlyOption contained	biosk bioskey cp compatible consk conskey cm cryptmethod edcompatible guipty key macatsui mzq mzquantum osfiletype oft renderoptions rop st shelltype sn shortname tenc termencoding ta textauto tx textmode tf ttyfast ttym ttymouse tbi ttybuiltin wiv weirdinvert
                            
                            " Turn-off setting variants
    6              0.000114 syn keyword vimOnlyOption contained	nobiosk nobioskey noconsk noconskey nocp nocompatible noguipty nomacatsui nosn noshortname nota notextauto notx notextmode notf nottyfast notbi nottybuiltin nowiv noweirdinvert
                            
                            " Invertible setting variants
    6              0.000091 syn keyword vimOnlyOption contained	invbiosk invbioskey invconsk invconskey invcp invcompatible invguipty invmacatsui invsn invshortname invta invtextauto invtx invtextmode invtf invttyfast invtbi invttybuiltin invwiv invweirdinvert
                            " termcap codes (which can also be set) {{{2
    6              0.001600 syn keyword vimTermOption contained	t_8b t_AB t_al t_bc t_ce t_cl t_Co t_Cs t_CV t_db t_DL t_F1 t_F2 t_F3 t_F4 t_F5 t_F6 t_F7 t_F8 t_F9 t_fs t_IE t_IS t_k1 t_K1 t_k2 t_k3 t_K3 t_k4 t_K4 t_k5 t_K5 t_k6 t_K6 t_k7 t_K7 t_k8 t_K8 t_k9 t_K9 t_KA t_kb t_kB t_KB t_KC t_kd t_kD t_KD t_ke t_KE t_KF t_KG t_kh t_KH t_kI t_KI t_KJ t_KK t_kl t_KL t_kN t_kP t_kr t_ks t_ku t_le t_mb t_md t_me t_mr t_ms t_nd t_op t_RB t_RI t_RV t_Sb t_se t_Sf t_SI t_so t_sr t_SR t_te t_ti t_ts t_u7 t_ue t_us t_ut t_vb t_ve t_vi t_vs t_WP t_WS t_xn t_xs t_ZH t_ZR
    6              0.000093 syn keyword vimTermOption contained	t_8f t_AF t_AL t_cd t_Ce t_cm t_cs t_CS t_da t_dl t_EI
    6              0.000067 syn match   vimTermOption contained	"t_%1"
    6              0.000049 syn match   vimTermOption contained	"t_#2"
    6              0.000044 syn match   vimTermOption contained	"t_#4"
    6              0.000044 syn match   vimTermOption contained	"t_@7"
    6              0.000051 syn match   vimTermOption contained	"t_*7"
    6              0.000043 syn match   vimTermOption contained	"t_&8"
    6              0.000043 syn match   vimTermOption contained	"t_%i"
    6              0.000046 syn match   vimTermOption contained	"t_k;"
                            
                            " unsupported settings: these are supported by vi but don't do anything in vim {{{2
    6              0.000062 syn keyword vimErrSetting contained	hardtabs ht w1200 w300 w9600 
                            "}}}2
    6              0.000014 syn case ignore
                            " Highlight commonly used Groupnames {{{2
    6              0.000299 syn keyword vimGroup contained	Comment Constant String Character Number Boolean Float Identifier Function Statement Conditional Repeat Label Operator Keyword Exception PreProc Include Define Macro PreCondit Type StorageClass Structure Typedef Special SpecialChar Tag Delimiter SpecialComment Debug Underlined Ignore Error Todo 
                            
                            " Default highlighting groups {{{2
    6              0.000397 syn keyword vimHLGroup contained	ColorColumn Cursor CursorColumn CursorIM CursorLine CursorLineNr DiffAdd DiffChange DiffDelete DiffText Directory EndOfBuffer ErrorMsg FoldColumn Folded IncSearch LineNr MatchParen Menu ModeMsg MoreMsg NonText Normal Pmenu PmenuSbar PmenuSel PmenuThumb Question Scrollbar Search SignColumn SpecialKey SpellBad SpellCap SpellLocal SpellRare StatusLine StatusLineNC TabLine TabLineFill TabLineSel Title Tooltip VertSplit Visual WarningMsg WildMenu 
    6              0.001069 syn match vimHLGroup contained	"Conceal"
    6              0.000062 syn keyword vimOnlyHLGroup contained	VisualNOS
    6              0.000074 syn keyword nvimHLGroup contained	Substitute TermCursor TermCursorNC QuickFixLine
                            "}}}2
    6              0.000012 syn case match
                            " Special Vim Highlighting (not automatic) {{{1
                            
                            " Set up folding commands
    6              0.000114 if exists("g:vimsyn_folding") && g:vimsyn_folding =~# '[aflmpPrt]'
                             if g:vimsyn_folding =~# 'a'
                              com! -nargs=* VimFolda <args> fold
                             else
                              com! -nargs=* VimFolda <args>
                             endif
                             if g:vimsyn_folding =~# 'f'
                              com! -nargs=* VimFoldf <args> fold
                             else
                              com! -nargs=* VimFoldf <args>
                             endif
                             if g:vimsyn_folding =~# 'l'
                              com! -nargs=* VimFoldl <args> fold
                             else
                              com! -nargs=* VimFoldl <args>
                             endif
                             if g:vimsyn_folding =~# 'm'
                              com! -nargs=* VimFoldm <args> fold
                             else
                              com! -nargs=* VimFoldm <args>
                             endif
                             if g:vimsyn_folding =~# 'p' 
                              com! -nargs=* VimFoldp <args> fold 
                             else 
                              com! -nargs=* VimFoldp <args> 
                             endif
                             if g:vimsyn_folding =~# 'P'
                              com! -nargs=* VimFoldP <args> fold
                             else
                              com! -nargs=* VimFoldP <args>
                             endif
                             if g:vimsyn_folding =~# 'r'
                              com! -nargs=* VimFoldr <args> fold
                             else
                              com! -nargs=* VimFoldr <args>
                             endif
                             if g:vimsyn_folding =~# 't'
                              com! -nargs=* VimFoldt <args> fold
                             else
                              com! -nargs=* VimFoldt <args>
                             endif
    6              0.000009 else
    6              0.000188  com! -nargs=*	VimFolda	<args>
    6              0.000075  com! -nargs=*	VimFoldf	<args>
    6              0.000063  com! -nargs=*	VimFoldl	<args>
    6              0.000060  com! -nargs=*	VimFoldm	<args>
    6              0.000058  com! -nargs=*	VimFoldp	<args>
    6              0.000063  com! -nargs=*	VimFoldP	<args>
    6              0.000063  com! -nargs=*	VimFoldr	<args>
    6              0.000060  com! -nargs=*	VimFoldt	<args>
    6              0.000010 endif
                            
                            " commands not picked up by the generator (due to non-standard format)
    6              0.000119 syn keyword vimCommand contained	py3
                            
                            " Deprecated variable options {{{2
    6              0.000053 if exists("g:vim_minlines")
                             let g:vimsyn_minlines= g:vim_minlines
    6              0.000009 endif
    6              0.000030 if exists("g:vim_maxlines")
                             let g:vimsyn_maxlines= g:vim_maxlines
    6              0.000008 endif
    6              0.000032 if exists("g:vimsyntax_noerror")
                             let g:vimsyn_noerror= g:vimsyntax_noerror
    6              0.000008 endif
                            
                            " Variable options {{{2
    6              0.000028 if exists("g:vim_maxlines")
                             let s:vimsyn_maxlines= g:vim_maxlines
    6              0.000008 else
    6              0.000054  let s:vimsyn_maxlines= 60
    6              0.000010 endif
                            
                            " Numbers {{{2
                            " =======
    6              0.000419 syn match vimNumber	"\<\d\+\%(\.\d\+\%([eE][+-]\=\d\+\)\=\)\=" skipwhite nextgroup=vimGlobal,vimSubst,vimCommand,vimComment
    6              0.000329 syn match vimNumber	"-\d\+\%(\.\d\+\%([eE][+-]\=\d\+\)\=\)\="  skipwhite nextgroup=vimGlobal,vimSubst,vimCommand,vimComment
    6              0.000301 syn match vimNumber	"\<0[xX]\x\+"		       skipwhite nextgroup=vimGlobal,vimSubst,vimCommand,vimComment
    6              0.000342 syn match vimNumber	"\%(^\|\A\)\zs#\x\{6}"             	       skipwhite nextgroup=vimGlobal,vimSubst,vimCommand,vimComment
                            
                            " All vimCommands are contained by vimIsCommand. {{{2
    6              0.000810 syn match vimCmdSep	"[:|]\+"	skipwhite nextgroup=vimAddress,vimAutoCmd,vimEcho,vimIsCommand,vimExtCmd,vimFilter,vimLet,vimMap,vimMark,vimSet,vimSyntax,vimUserCmd
    6              0.000223 syn match vimIsCommand	"\<\h\w*\>"	contains=vimCommand
    6              0.000107 syn match vimVar	      contained	"\<\h[a-zA-Z0-9#_]*\>"
    6              0.000111 syn match vimVar		"\<[bwglstav]:\h[a-zA-Z0-9#_]*\>"
    6              0.000092 syn match vimVar	      	"\s\zs&\a\+\>"
    6              0.000087 syn match vimFBVar      contained   "\<[bwglstav]:\h[a-zA-Z0-9#_]*\>"
    6              0.000074 syn keyword vimCommand  contained	in
                            
                            " Insertions And Appends: insert append {{{2
                            " =======================
    6              0.000301 syn region vimInsert	matchgroup=vimCommand start="^[: \t]*\(\d\+\(,\d\+\)\=\)\=a\%[ppend]$"		matchgroup=vimCommand end="^\.$""
    6              0.000255 syn region vimInsert	matchgroup=vimCommand start="^[: \t]*\(\d\+\(,\d\+\)\=\)\=c\%[hange]$"		matchgroup=vimCommand end="^\.$""
    6              0.000308 syn region vimInsert	matchgroup=vimCommand start="^[: \t]*\(\d\+\(,\d\+\)\=\)\=i\%[nsert]$"		matchgroup=vimCommand end="^\.$""
    6              0.000247 syn region vimInsert	matchgroup=vimCommand start="^[: \t]*\(\d\+\(,\d\+\)\=\)\=starti\%[nsert]$"	matchgroup=vimCommand end="^\.$""
                            
                            " Behave! {{{2
                            " =======
    6              0.000185 syn match   vimBehave	"\<be\%[have]\>" skipwhite nextgroup=vimBehaveModel,vimBehaveError
    6              0.000042 syn keyword vimBehaveModel contained	mswin	xterm
    6              0.000083 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_nobehaveerror")
    6              0.000052  syn match   vimBehaveError contained	"[^ ]\+"
    6              0.000011 endif
                            
                            " Filetypes {{{2
                            " =========
    6              0.000304 syn match   vimFiletype	"\<filet\%[ype]\(\s\+\I\i*\)*"	skipwhite contains=vimFTCmd,vimFTOption,vimFTError
    6              0.000066 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_vimFTError")
    6              0.000055  syn match   vimFTError  contained	"\I\i*"
    6              0.000010 endif
    6              0.000182 syn keyword vimFTCmd    contained	filet[ype]
    6              0.000053 syn keyword vimFTOption contained	detect indent off on plugin
                            
                            " Augroup : vimAugroupError removed because long augroups caused sync'ing problems. {{{2
                            " ======= : Trade-off: Increasing synclines with slower editing vs augroup END error checking.
    6              0.001710 syn cluster vimAugroupList	contains=vimAugroup,vimIsCommand,vimUserCmd,vimExecute,vimNotFunc,vimFuncName,vimFunction,vimFunctionError,vimLineComment,vimNotFunc,vimMap,vimSpecFile,vimOper,vimNumber,vimOperParen,vimComment,vimString,vimSubst,vimMark,vimRegister,vimAddress,vimFilter,vimCmplxRepeat,vimComment,vimLet,vimSet,vimAutoCmd,vimRegion,vimSynLine,vimNotation,vimCtrlChar,vimFuncVar,vimContinue,vimSetEqual,vimOption
    6              0.000057 if exists("g:vimsyn_folding") && g:vimsyn_folding =~# 'a'
                             syn region  vimAugroup	fold matchgroup=vimAugroupKey start="\<aug\%[roup]\>\ze\s\+\K\k*" end="\<aug\%[roup]\>\ze\s\+[eE][nN][dD]\>"	contains=vimAutoCmd,@vimAugroupList
    6              0.000013 else
    6              0.000216  syn region  vimAugroup	matchgroup=vimAugroupKey start="\<aug\%[roup]\>\ze\s\+\K\k*" end="\<aug\%[roup]\>\ze\s\+[eE][nN][dD]\>"		contains=vimAutoCmd,@vimAugroupList
    6              0.000011 endif
    6              0.000093 syn match   vimAugroup	"aug\%[roup]!"	contains=vimAugroupKey
    6              0.000067 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_noaugrouperror")
    6              0.000088  syn match   vimAugroupError	"\<aug\%[roup]\>\s\+[eE][nN][dD]\>"
    6              0.000009 endif
    6              0.000044 syn keyword vimAugroupKey contained	aug[roup]
                            
                            " Operators: {{{2
                            " =========
    6              0.000387 syn cluster	vimOperGroup	contains=vimEnvvar,vimFunc,vimFuncVar,vimOper,vimOperParen,vimNumber,vimString,vimRegister,vimContinue
    6              0.000175 syn match	vimOper	"\%#=1\(==\|!=\|>=\|<=\|=\~\|!\~\|>\|<\|=\)[?#]\{0,2}"	skipwhite nextgroup=vimString,vimSpecFile
    6              0.000137 syn match	vimOper	"\(\<is\|\<isnot\)[?#]\{0,2}\>"			skipwhite nextgroup=vimString,vimSpecFile
    6              0.000141 syn match	vimOper	"||\|&&\|[-+.!]"				skipwhite nextgroup=vimString,vimSpecFile
    6              0.000123 syn region	vimOperParen 	matchgroup=vimParenSep	start="(" end=")" contains=@vimOperGroup
    6              0.000250 syn region	vimOperParen	matchgroup=vimSep		start="{" end="}" contains=@vimOperGroup nextgroup=vimVar,vimFuncVar
    6              0.000068 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_noopererror")
    6              0.000056  syn match	vimOperError	")"
    6              0.000010 endif
                            
                            " Functions : Tag is provided for those who wish to highlight tagged functions {{{2
                            " =========
    6              0.001052 syn cluster	vimFuncList	contains=vimCommand,vimFunctionError,vimFuncKey,Tag,vimFuncSID
    6              0.003215 syn cluster	vimFuncBodyList	contains=vimAbb,vimAddress,vimAugroupKey,vimAutoCmd,vimCmplxRepeat,vimComment,vimContinue,vimCtrlChar,vimEcho,vimEchoHL,vimExecute,vimIsCommand,vimFBVar,vimFunc,vimFunction,vimFuncVar,vimGlobal,vimHighlight,vimIsCommand,vimLet,vimLineComment,vimMap,vimMark,vimNorm,vimNotation,vimNotFunc,vimNumber,vimOper,vimOperParen,vimRegion,vimRegister,vimSearch,vimSet,vimSpecFile,vimString,vimSubst,vimSynLine,vimUnmap,vimUserCommand
    6              0.000261 syn match	vimFunction	"\<fu\%[nction]!\=\s\+\%(<[sS][iI][dD]>\|[sSgGbBwWtTlL]:\)\=\%(\i\|[#.]\|{.\{-1,}}\)*\ze\s*("	contains=@vimFuncList nextgroup=vimFuncBody
                            
    6              0.000086 if exists("g:vimsyn_folding") && g:vimsyn_folding =~# 'f'
                             syn region	vimFuncBody  contained	fold start="\ze\s*("	matchgroup=vimCommand end="\<\(endf\>\|endfu\%[nction]\>\)"		contains=@vimFuncBodyList
    6              0.000012 else
    6              0.000195  syn region	vimFuncBody  contained	start="\ze\s*("	matchgroup=vimCommand end="\<\(endf\>\|endfu\%[nction]\>\)"		contains=@vimFuncBodyList
    6              0.000012 endif
    6              0.000062 syn match	vimFuncVar   contained	"a:\(\K\k*\|\d\+\)"
    6              0.000054 syn match	vimFuncSID   contained	"\c<sid>\|\<s:"
    6              0.000049 syn keyword	vimFuncKey   contained	fu[nction]
    6              0.000053 syn match	vimFuncBlank contained	"\s\+"
                            
    6              0.000055 syn keyword	vimPattern   contained	start	skip	end
                            
                            " Special Filenames, Modifiers, Extension Removal: {{{2
                            " ===============================================
    6              0.000145 syn match	vimSpecFile	"<c\(word\|WORD\)>"	nextgroup=vimSpecFileMod,vimSubst
    6              0.000140 syn match	vimSpecFile	"<\([acs]file\|amatch\|abuf\)>"	nextgroup=vimSpecFileMod,vimSubst
    6              0.000117 syn match	vimSpecFile	"\s%[ \t:]"ms=s+1,me=e-1	nextgroup=vimSpecFileMod,vimSubst
    6              0.000107 syn match	vimSpecFile	"\s%$"ms=s+1	nextgroup=vimSpecFileMod,vimSubst
    6              0.000104 syn match	vimSpecFile	"\s%<"ms=s+1,me=e-1	nextgroup=vimSpecFileMod,vimSubst
    6              0.000117 syn match	vimSpecFile	"#\d\+\|[#%]<\>"	nextgroup=vimSpecFileMod,vimSubst
    6              0.000055 syn match	vimSpecFileMod	"\(:[phtre]\)\+"	contained
                            
                            " User-Specified Commands: {{{2
                            " =======================
    6              0.001322 syn cluster	vimUserCmdList	contains=vimAddress,vimSyntax,vimHighlight,vimAutoCmd,vimCmplxRepeat,vimComment,vimCtrlChar,vimEscapeBrace,vimFunc,vimFuncName,vimFunction,vimFunctionError,vimIsCommand,vimMark,vimNotation,vimNumber,vimOper,vimRegion,vimRegister,vimLet,vimSet,vimSetEqual,vimSetString,vimSpecFile,vimString,vimSubst,vimSubstRep,vimSubstRange,vimSynLine
    6              0.000053 syn keyword	vimUserCommand	contained	com[mand]
    6              0.000269 syn match	vimUserCmd	"\<com\%[mand]!\=\>.*$"	contains=vimUserAttrb,vimUserAttrbError,vimUserCommand,@vimUserCmdList
    6              0.000058 syn match	vimUserAttrbError	contained	"-\a\+\ze\s"
    6              0.000141 syn match	vimUserAttrb	contained	"-nargs=[01*?+]"	contains=vimUserAttrbKey,vimOper
    6              0.000211 syn match	vimUserAttrb	contained	"-complete="		contains=vimUserAttrbKey,vimOper nextgroup=vimUserAttrbCmplt,vimUserCmdError
    6              0.000176 syn match	vimUserAttrb	contained	"-range\(=%\|=\d\+\)\="	contains=vimNumber,vimOper,vimUserAttrbKey
    6              0.000163 syn match	vimUserAttrb	contained	"-count\(=\d\+\)\="	contains=vimNumber,vimOper,vimUserAttrbKey
    6              0.000111 syn match	vimUserAttrb	contained	"-bang\>"		contains=vimOper,vimUserAttrbKey
    6              0.000107 syn match	vimUserAttrb	contained	"-bar\>"		contains=vimOper,vimUserAttrbKey
    6              0.000109 syn match	vimUserAttrb	contained	"-buffer\>"		contains=vimOper,vimUserAttrbKey
    6              0.000110 syn match	vimUserAttrb	contained	"-register\>"		contains=vimOper,vimUserAttrbKey
    6              0.000088 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_nousercmderror")
    6              0.000061  syn match	vimUserCmdError	contained	"\S\+\>"
    6              0.000012 endif
    6              0.000014 syn case ignore
    6              0.000146 syn keyword	vimUserAttrbKey   contained	bar	ban[g]	cou[nt]	ra[nge] com[plete]	n[args]	re[gister]
    6              0.000190 syn keyword	vimUserAttrbCmplt contained	augroup buffer behave color command compiler cscope dir environment event expression file file_in_path filetype function help highlight history locale mapping menu option packadd shellcmd sign syntax syntime tag tag_listfiles user var
    6              0.000130 syn keyword	vimUserAttrbCmplt contained	custom customlist nextgroup=vimUserAttrbCmpltFunc,vimUserCmdError
    6              0.000158 syn match	vimUserAttrbCmpltFunc contained	",\%([sS]:\|<[sS][iI][dD]>\)\=\%(\h\w*\%(#\h\w*\)\+\|\h\w*\)"hs=s+1 nextgroup=vimUserCmdError
                            
    6              0.000013 syn case match
    6              0.000053 syn match	vimUserAttrbCmplt contained	"custom,\u\w*"
                            
                            " Lower Priority Comments: after some vim commands... {{{2
                            " =======================
    6              0.000214 syn match	vimComment	excludenl +\s"[^\-:.%#=*].*$+lc=1	contains=@vimCommentGroup,vimCommentString
    6              0.000201 syn match	vimComment	+\<endif\s\+".*$+lc=5	contains=@vimCommentGroup,vimCommentString
    6              0.000209 syn match	vimComment	+\<else\s\+".*$+lc=4	contains=@vimCommentGroup,vimCommentString
    6              0.000147 syn region	vimCommentString	contained oneline start='\S\s\+"'ms=e	end='"'
                            
                            " Environment Variables: {{{2
                            " =====================
    6              0.000057 syn match	vimEnvvar	"\$\I\i*"
    6              0.000051 syn match	vimEnvvar	"\${\I\i*}"
                            
                            " In-String Specials: {{{2
                            " Try to catch strings, if nothing else matches (therefore it must precede the others!)
                            "  vimEscapeBrace handles ["]  []"] (ie. "s don't terminate string inside [])
    6              0.000138 syn region	vimEscapeBrace	oneline   contained transparent start="[^\\]\(\\\\\)*\[\zs\^\=\]\=" skip="\\\\\|\\\]" end="]"me=e-1
    6              0.000056 syn match	vimPatSepErr	contained	"\\)"
    6              0.000053 syn match	vimPatSep	contained	"\\|"
    6              0.000176 syn region	vimPatSepZone	oneline   contained   matchgroup=vimPatSepZ start="\\%\=\ze(" skip="\\\\" end="\\)\|[^\\]['"]"	contains=@vimStringGroup
    6              0.000138 syn region	vimPatRegion	contained transparent matchgroup=vimPatSepR start="\\[z%]\=(" end="\\)"	contains=@vimSubstList oneline
    6              0.000054 syn match	vimNotPatSep	contained	"\\\\"
    6              0.000186 syn cluster	vimStringGroup	contains=vimEscapeBrace,vimPatSep,vimNotPatSep,vimPatSepErr,vimPatSepZone,@Spell
    6              0.000163 syn region	vimString	oneline keepend	start=+[^a-zA-Z>!\\@]"+lc=1 skip=+\\\\\|\\"+ matchgroup=vimStringEnd end=+"+	contains=@vimStringGroup
    6              0.000077 syn region	vimString	oneline keepend	start=+[^a-zA-Z>!\\@]'+lc=1 end=+'+
    6              0.000102 syn region	vimString	oneline	start=+=!+lc=1	skip=+\\\\\|\\!+ end=+!+	contains=@vimStringGroup
    6              0.000098 syn region	vimString	oneline	start="=+"lc=1	skip="\\\\\|\\+" end="+"	contains=@vimStringGroup
    6              0.000123 syn region	vimString	oneline	start="\s/\s*\A"lc=1 skip="\\\\\|\\+" end="/"	contains=@vimStringGroup
    6              0.000155 syn match	vimString	contained	+"[^"]*\\$+	skipnl nextgroup=vimStringCont
    6              0.000074 syn match	vimStringCont	contained	+\(\\\\\|.\)\{-}[^\\]"+
                            
                            " Substitutions: {{{2
                            " =============
    6              0.000216 syn cluster	vimSubstList	contains=vimPatSep,vimPatRegion,vimPatSepErr,vimSubstTwoBS,vimSubstRange,vimNotation
    6              0.000131 syn cluster	vimSubstRepList	contains=vimSubstSubstr,vimSubstTwoBS,vimNotation
    6              0.000085 syn cluster	vimSubstList	add=vimCollection
    6              0.000551 syn match	vimSubst	"\(:\+\s*\|^\s*\||\s*\)\<\%(\<s\%[ubstitute]\>\|\<sm\%[agic]\>\|\<sno\%[magic]\>\)[:#[:alpha:]]\@!" nextgroup=vimSubstPat
    6              0.000156 syn match	vimSubst	"\%(^\|[^\\]\)\<s\%[ubstitute]\>[:#[:alpha:]]\@!"	nextgroup=vimSubstPat contained
    6              0.000115 syn match	vimSubst	"/\zs\<s\%[ubstitute]\>\ze/"		nextgroup=vimSubstPat
    6              0.000117 syn match	vimSubst	"\(:\+\s*\|^\s*\)s\ze#.\{-}#.\{-}#"		nextgroup=vimSubstPat
    6              0.000155 syn match	vimSubst1       contained	"\<s\%[ubstitute]\>"	nextgroup=vimSubstPat
    6              0.000112 syn match	vimSubst2       contained	"s\%[ubstitute]\>"	nextgroup=vimSubstPat
    6              0.000215 syn region	vimSubstPat     contained	matchgroup=vimSubstDelim start="\z([^a-zA-Z( \t[\]&]\)"rs=s+1 skip="\\\\\|\\\z1" end="\z1"re=e-1,me=e-1	 contains=@vimSubstList	nextgroup=vimSubstRep4	oneline
    6              0.000225 syn region	vimSubstRep4    contained	matchgroup=vimSubstDelim start="\z(.\)" skip="\\\\\|\\\z1" end="\z1" matchgroup=vimNotation end="<[cC][rR]>" contains=@vimSubstRepList	nextgroup=vimSubstFlagErr	oneline
    6              0.000143 syn region	vimCollection   contained transparent	start="\\\@<!\[" skip="\\\[" end="\]"	contains=vimCollClass
    6              0.000072 syn match	vimCollClassErr contained	"\[:.\{-\}:\]"
    6              0.000204 syn match	vimCollClass    contained transparent	"\%#=1\[:\(alnum\|alpha\|blank\|cntrl\|digit\|graph\|lower\|print\|punct\|space\|upper\|xdigit\|return\|tab\|escape\|backspace\):\]"
    6              0.000049 syn match	vimSubstSubstr  contained	"\\z\=\d"
    6              0.000039 syn match	vimSubstTwoBS   contained	"\\\\"
    6              0.000089 syn match	vimSubstFlagErr contained	"[^< \t\r|]\+" contains=vimSubstFlags
    6              0.000043 syn match	vimSubstFlags   contained	"[&cegiIpr]\+"
                            
                            " 'String': {{{2
    6              0.000137 syn match	vimString	"[^(,]'[^']\{-}\zs'"
                            
                            " Marks, Registers, Addresses, Filters: {{{2
    6              0.000205 syn match	vimMark	"'[a-zA-Z0-9]\ze[-+,!]"	nextgroup=vimFilter,vimMarkNumber,vimSubst
    6              0.000163 syn match	vimMark	"'[<>]\ze[-+,!]"		nextgroup=vimFilter,vimMarkNumber,vimSubst
    6              0.000147 syn match	vimMark	",\zs'[<>]\ze"		nextgroup=vimFilter,vimMarkNumber,vimSubst
    6              0.000150 syn match	vimMark	"[!,:]\zs'[a-zA-Z0-9]"	nextgroup=vimFilter,vimMarkNumber,vimSubst
    6              0.000172 syn match	vimMark	"\<norm\%[al]\s\zs'[a-zA-Z0-9]"	nextgroup=vimFilter,vimMarkNumber,vimSubst
    6              0.000101 syn match	vimMarkNumber	"[-+]\d\+"		contained contains=vimOper nextgroup=vimSubst2
    6              0.000061 syn match	vimPlainMark contained	"'[a-zA-Z0-9]"
    6              0.000147 syn match	vimRange	"[`'][a-zA-Z0-9],[`'][a-zA-Z0-9]"	contains=vimMark	skipwhite nextgroup=vimFilter
                            
    6              0.000080 syn match	vimRegister	'[^,;[{: \t]\zs"[a-zA-Z0-9.%#:_\-/]\ze[^a-zA-Z_":0-9]'
    6              0.000062 syn match	vimRegister	'\<norm\s\+\zs"[a-zA-Z0-9]'
    6              0.000059 syn match	vimRegister	'\<normal\s\+\zs"[a-zA-Z0-9]'
    6              0.000036 syn match	vimRegister	'@"'
    6              0.000065 syn match	vimPlainRegister contained	'"[a-zA-Z0-9\-:.%#*+=]'
                            
    6              0.000072 syn match	vimAddress	",\zs[.$]"	skipwhite nextgroup=vimSubst1
    6              0.000099 syn match	vimAddress	"%\ze\a"	skipwhite nextgroup=vimString,vimSubst1
                            
    6              0.000147 syn match	vimFilter 		"^!!\=[^"]\{-}\(|\|\ze\"\|$\)"	contains=vimOper,vimSpecFile
    6              0.000132 syn match	vimFilter contained	"!!\=[^"]\{-}\(|\|\ze\"\|$\)"	contains=vimOper,vimSpecFile
                            
                            " Complex repeats (:h complex-repeat) {{{2
    6              0.000065 syn match	vimCmplxRepeat	'[^a-zA-Z_/\\()]q[0-9a-zA-Z"]\>'lc=1
    6              0.000072 syn match	vimCmplxRepeat	'@[0-9a-z".=@:]\ze\($\|[^a-zA-Z]\>\)'
                            
                            " Set command and associated set-options (vimOptions) with comment {{{2
    6              0.000624 syn region	vimSet		matchgroup=vimCommand start="\<\%(setl\%[ocal]\|setg\%[lobal]\|se\%[t]\)\>" skip="\%(\\\\\)*\\." end="$" end="|" matchgroup=vimNotation end="<[cC][rR]>" keepend oneline contains=vimSetEqual,vimOption,vimErrSetting,vimComment,vimSetString,vimSetMod
    6              0.000291 syn region	vimSetEqual	contained	start="[=:]\|[-+^]=" skip="\\\\\|\\\s" end="[| \t]\|$"me=e-1	contains=vimCtrlChar,vimSetSep,vimNotation,vimEnvvar oneline
    6              0.000127 syn region	vimSetString	contained	start=+="+hs=s+1	skip=+\\\\\|\\"+  end=+"+		contains=vimCtrlChar
    6              0.000146 syn match	vimSetSep	contained	"[,:]" skipwhite nextgroup=vimCommand
    6              0.000062 syn match	vimSetMod	contained	"&vim\=\|[!&?<]\|all&"
                            
                            " Let {{{2
                            " ===
    6              0.000198 syn keyword	vimLet	let	unl[et]	skipwhite nextgroup=vimVar,vimFuncVar
                            
                            " Abbreviations {{{2
                            " =============
    6              0.000245 syn keyword vimAbb	ab[breviate] ca[bbrev] inorea[bbrev] cnorea[bbrev] norea[bbrev] ia[bbrev] skipwhite nextgroup=vimMapMod,vimMapLhs
                            
                            " Autocmd {{{2
                            " =======
    6              0.000231 syn match	vimAutoEventList	contained	"\(!\s\+\)\=\(\a\+,\)*\a\+"	contains=vimAutoEvent,nvimAutoEvent nextgroup=vimAutoCmdSpace
    6              0.000100 syn match	vimAutoCmdSpace	contained	"\s\+"	nextgroup=vimAutoCmdSfxList
    6              0.000041 syn match	vimAutoCmdSfxList	contained	"\S*"
    6              0.000141 syn keyword	vimAutoCmd	au[tocmd] do[autocmd] doautoa[ll]	skipwhite nextgroup=vimAutoEventList
                            
                            " Echo and Execute -- prefer strings! {{{2
                            " ================
    6              0.000463 syn region	vimEcho	oneline excludenl matchgroup=vimCommand start="\<ec\%[ho]\>" skip="\(\\\\\)*\\|" end="$\||" contains=vimFunc,vimFuncVar,vimString,vimVar
    6              0.000537 syn region	vimExecute	oneline excludenl matchgroup=vimCommand start="\<exe\%[cute]\>" skip="\(\\\\\)*\\|" end="$\||\|<[cC][rR]>" contains=vimFuncVar,vimIsCommand,vimOper,vimNotation,vimOperParen,vimString,vimVar
    6              0.000293 syn match	vimEchoHL	"echohl\="	skipwhite nextgroup=vimGroup,vimHLGroup,vimEchoHLNone,vimOnlyHLGroup,nvimHLGroup
    6              0.000015 syn case ignore
    6              0.000029 syn keyword	vimEchoHLNone	none
    6              0.000010 syn case match
                            
                            " Maps {{{2
                            " ====
    6              0.000111 syn match	vimMap		"\<map\>!\=\ze\s*[^(]" skipwhite nextgroup=vimMapMod,vimMapLhs
    6              0.000338 syn keyword	vimMap		cm[ap] cno[remap] im[ap] ino[remap] lm[ap] ln[oremap] nm[ap] nn[oremap] no[remap] om[ap] ono[remap] smap snor[emap] vm[ap] vn[oremap] xm[ap] xn[oremap] skipwhite nextgroup=vimMapBang,vimMapMod,vimMapLhs
    6              0.000130 syn keyword	nvimMap		tn[oremap] tm[ap] skipwhite nextgroup=vimMapBang,vimMapMod,vimMapLhs
    6              0.000053 syn keyword	vimMap		mapc[lear] smapc[lear]
    6              0.000223 syn keyword	vimUnmap		cu[nmap] iu[nmap] lu[nmap] nun[map] ou[nmap] sunm[ap] unm[ap] unm[ap] vu[nmap] xu[nmap] skipwhite nextgroup=vimMapBang,vimMapMod,vimMapLhs
    6              0.000112 syn keyword	nvimUnmap 		tunm[ap] skipwhite nextgroup=vimMapBang,vimMapMod,vimMapLhs
    6              0.000136 syn match	vimMapLhs	contained	"\S\+"			contains=vimNotation,vimCtrlChar skipwhite nextgroup=vimMapRhs
    6              0.000081 syn match	vimMapBang	contained	"!"			skipwhite nextgroup=vimMapMod,vimMapLhs
    6              0.000252 syn match	vimMapMod	contained	"\%#=1\c<\(buffer\|expr\|\(local\)\=leader\|nowait\|plug\|script\|sid\|unique\|silent\)\+>" contains=vimMapModKey,vimMapModErr skipwhite nextgroup=vimMapMod,vimMapLhs
    6              0.000137 syn match	vimMapRhs	contained	".*" contains=vimNotation,vimCtrlChar	skipnl nextgroup=vimMapRhsExtend
    6              0.000077 syn match	vimMapRhsExtend	contained	"^\s*\\.*$"			contains=vimContinue
    6              0.000011 syn case ignore
    6              0.000077 syn keyword	vimMapModKey	contained	buffer	expr	leader	localleader	nowait	plug	script	sid	silent	unique
    6              0.000010 syn case match
                            
                            " Menus {{{2
                            " =====
    6              0.000167 syn cluster	vimMenuList contains=vimMenuBang,vimMenuPriority,vimMenuName,vimMenuMod
    6              0.000276 syn keyword	vimCommand	am[enu] an[oremenu] aun[menu] cme[nu] cnoreme[nu] cunme[nu] ime[nu] inoreme[nu] iunme[nu] me[nu] nme[nu] nnoreme[nu] noreme[nu] nunme[nu] ome[nu] onoreme[nu] ounme[nu] unme[nu] vme[nu] vnoreme[nu] vunme[nu] skipwhite nextgroup=@vimMenuList
    6              0.000110 syn match	vimMenuName	"[^ \t\\<]\+"	contained nextgroup=vimMenuNameMore,vimMenuMap
    6              0.000071 syn match	vimMenuPriority	"\d\+\(\.\d\+\)*"	contained skipwhite nextgroup=vimMenuName
    6              0.000124 syn match	vimMenuNameMore	"\c\\\s\|<tab>\|\\\."	contained nextgroup=vimMenuName,vimMenuNameMore contains=vimNotation
    6              0.000115 syn match	vimMenuMod    contained	"\c<\(script\|silent\)\+>"  skipwhite contains=vimMapModKey,vimMapModErr nextgroup=@vimMenuList
    6              0.000061 syn match	vimMenuMap	"\s"	contained skipwhite nextgroup=vimMenuRhs
    6              0.000190 syn match	vimMenuRhs	".*$"	contained contains=vimString,vimComment,vimIsCommand
    6              0.000044 syn match	vimMenuBang	"!"	contained skipwhite nextgroup=@vimMenuList
                            
                            " Angle-Bracket Notation (tnx to Michael Geddes) {{{2
                            " ======================
    6              0.000014 syn case ignore
    6              0.000449 syn match	vimNotation	"\%#=1\(\\\|<lt>\)\=<\([scamd]-\)\{0,4}x\=\(f\d\{1,2}\|[^ \t:]\|cmd\|cr\|lf\|linefeed\|return\|k\=del\%[ete]\|bs\|backspace\|tab\|esc\|right\|left\|help\|undo\|insert\|ins\|mouse\|k\=home\|k\=end\|kplus\|kminus\|kdivide\|kmultiply\|kenter\|kpoint\|space\|k\=\(page\)\=\(\|down\|up\|k\d\>\)\)>" contains=vimBracket
    6              0.000153 syn match	vimNotation	"\%#=1\(\\\|<lt>\)\=<\([scam2-4]-\)\{0,4}\(right\|left\|middle\)\(mouse\)\=\(drag\|release\)\=>"	contains=vimBracket
    6              0.000123 syn match	vimNotation	"\%#=1\(\\\|<lt>\)\=<\(bslash\|plug\|sid\|space\|bar\|nop\|nul\|lt\)>"			contains=vimBracket
    6              0.000089 syn match	vimNotation	'\(\\\|<lt>\)\=<C-R>[0-9a-z"%#:.\-=]'he=e-1				contains=vimBracket
    6              0.000152 syn match	vimNotation	'\%#=1\(\\\|<lt>\)\=<\%(q-\)\=\(line[12]\|count\|bang\|reg\|args\|mods\|f-args\|f-mods\|lt\)>'	contains=vimBracket
    6              0.000132 syn match	vimNotation	"\%#=1\(\\\|<lt>\)\=<\([cas]file\|abuf\|amatch\|cword\|cWORD\|client\)>"		contains=vimBracket
    6              0.000039 syn match	vimBracket contained	"[\\<>]"
    6              0.000010 syn case match
                            
                            " User Function Highlighting {{{2
                            " (following Gautam Iyer's suggestion)
                            " ==========================
    6              0.000326 syn match vimFunc		"\%(\%([sSgGbBwWtTlL]:\|<[sS][iI][dD]>\)\=\%(\w\+\.\)*\I[a-zA-Z0-9_.]*\)\ze\s*("		contains=vimFuncName,vimUserFunc,vimExecute
    6              0.000207 syn match vimUserFunc contained	"\%(\%([sSgGbBwWtTlL]:\|<[sS][iI][dD]>\)\=\%(\w\+\.\)*\I[a-zA-Z0-9_.]*\)\|\<\u[a-zA-Z0-9.]*\>\|\<if\>"	contains=vimNotation
                            
                            " Errors And Warnings: {{{2
                            " ====================
    6              0.000094 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_novimfunctionerror")
    6              0.000134  syn match	vimFunctionError	"\s\zs[a-z0-9]\i\{-}\ze\s*("			contained contains=vimFuncKey,vimFuncBlank
    6              0.000150  syn match	vimFunctionError	"\s\zs\%(<[sS][iI][dD]>\|[sSgGbBwWtTlL]:\)\d\i\{-}\ze\s*("	contained contains=vimFuncKey,vimFuncBlank
    6              0.000060  syn match	vimElseIfErr	"\<else\s\+if\>"
    6              0.000073  syn match	vimBufnrWarn	/\<bufnr\s*(\s*["']\.['"]\s*)/
    6              0.000012 endif
                            
    6              0.000400 syn match vimNotFunc	"\<if\>\|\<el\%[seif]\>\|\<return\>\|\<while\>"	skipwhite nextgroup=vimOper,vimOperParen,vimVar,vimFunc,vimNotation
                            
                            " Norm {{{2
                            " ====
    6              0.000091 syn match	vimNorm		"\<norm\%[al]!\=" skipwhite nextgroup=vimNormCmds
    6              0.000036 syn match	vimNormCmds contained	".*$"
                            
                            " Syntax {{{2
                            "=======
    6              0.000117 syn match	vimGroupList	contained	"@\=[^ \t,]*"	contains=vimGroupSpecial,vimPatSep
    6              0.000115 syn match	vimGroupList	contained	"@\=[^ \t,]*,"	nextgroup=vimGroupList contains=vimGroupSpecial,vimPatSep
    6              0.000043 syn keyword	vimGroupSpecial	contained	ALL	ALLBUT	CONTAINED	TOP
    6              0.000061 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_novimsynerror")
    6              0.000049  syn match	vimSynError	contained	"\i\+"
    6              0.000056  syn match	vimSynError	contained	"\i\+="	nextgroup=vimGroupList
    6              0.000009 endif
    6              0.000091 syn match	vimSynContains	contained	"\<contain\(s\|edin\)="	nextgroup=vimGroupList
    6              0.000079 syn match	vimSynKeyContainedin	contained	"\<containedin="	nextgroup=vimGroupList
    6              0.000072 syn match	vimSynNextgroup	contained	"nextgroup="	nextgroup=vimGroupList
                            
    6              0.000296 syn match	vimSyntax	"\<sy\%[ntax]\>"	contains=vimCommand skipwhite nextgroup=vimSynType,vimComment
    6              0.000309 syn match	vimAuSyntax	contained	"\s+sy\%[ntax]"	contains=vimCommand skipwhite nextgroup=vimSynType,vimComment
    6              0.000098 syn cluster vimFuncBodyList add=vimSyntax
                            
                            " Syntax: case {{{2
    6              0.000148 syn keyword	vimSynType	contained	case	skipwhite nextgroup=vimSynCase,vimSynCaseError
    6              0.000079 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_novimsyncaseerror")
    6              0.000046  syn match	vimSynCaseError	contained	"\i\+"
    6              0.000010 endif
    6              0.000028 syn keyword	vimSynCase	contained	ignore	match
                            
                            " Syntax: clear {{{2
    6              0.000101 syn keyword	vimSynType	contained	clear	skipwhite nextgroup=vimGroupList
                            
                            " Syntax: cluster {{{2
    6              0.000108 syn keyword	vimSynType	contained	cluster	skipwhite nextgroup=vimClusterName
    6              0.000273 syn region	vimClusterName	contained	matchgroup=vimGroupName start="\h\w*" skip="\\\\\|\\|" matchgroup=vimSep end="$\||" contains=vimGroupAdd,vimGroupRem,vimSynContains,vimSynError
    6              0.000060 syn match	vimGroupAdd	contained	"add="	nextgroup=vimGroupList
    6              0.000056 syn match	vimGroupRem	contained	"remove="	nextgroup=vimGroupList
    6              0.000179 syn cluster vimFuncBodyList add=vimSynType,vimGroupAdd,vimGroupRem
                            
                            " Syntax: iskeyword {{{2
    6              0.000107 syn keyword	vimSynType	contained	iskeyword	skipwhite nextgroup=vimIskList
    6              0.000067 syn match	vimIskList	contained	'\S\+'	contains=vimIskSep
    6              0.000031 syn match	vimIskSep	contained	','
                            
                            " Syntax: include {{{2
    6              0.000094 syn keyword	vimSynType	contained	include	skipwhite nextgroup=vimGroupList
    6              0.000137 syn cluster vimFuncBodyList add=vimSynType
                            
                            " Syntax: keyword {{{2
    6              0.000115 syn cluster	vimSynKeyGroup	contains=vimSynNextgroup,vimSynKeyOpt,vimSynKeyContainedin
    6              0.000371 syn keyword	vimSynType	contained	keyword	skipwhite nextgroup=vimSynKeyRegion
    6              0.000147 syn region	vimSynKeyRegion	contained oneline keepend	matchgroup=vimGroupName start="\h\w*" skip="\\\\\|\\|" matchgroup=vimSep end="|\|$" contains=@vimSynKeyGroup
    6              0.000110 syn match	vimSynKeyOpt	contained	"\%#=1\<\(conceal\|contained\|transparent\|skipempty\|skipwhite\|skipnl\)\>"
    6              0.000145 syn cluster vimFuncBodyList add=vimSynType
                            
                            " Syntax: match {{{2
    6              0.000322 syn cluster	vimSynMtchGroup	contains=vimMtchComment,vimSynContains,vimSynError,vimSynMtchOpt,vimSynNextgroup,vimSynRegPat,vimNotation
    6              0.000125 syn keyword	vimSynType	contained	match	skipwhite nextgroup=vimSynMatchRegion
    6              0.000266 syn region	vimSynMatchRegion	contained keepend	matchgroup=vimGroupName start="\h\w*" matchgroup=vimSep end="|\|$" contains=@vimSynMtchGroup
    6              0.000223 syn match	vimSynMtchOpt	contained	"\%#=1\<\(conceal\|transparent\|contained\|excludenl\|keepend\|skipempty\|skipwhite\|display\|extend\|skipnl\|fold\)\>"
    6              0.000056 if has("conceal")
    6              0.000197  syn match	vimSynMtchOpt	contained	"\<cchar="	nextgroup=vimSynMtchCchar
    6              0.000037  syn match	vimSynMtchCchar	contained	"\S"
    6              0.000010 endif
    6              0.000065 syn cluster vimFuncBodyList add=vimSynMtchGroup
                            
                            " Syntax: off and on {{{2
    6              0.000101 syn keyword	vimSynType	contained	enable	list	manual	off	on	reset
                            
                            " Syntax: region {{{2
    6              0.000262 syn cluster	vimSynRegPatGroup	contains=vimPatSep,vimNotPatSep,vimSynPatRange,vimSynNotPatRange,vimSubstSubstr,vimPatRegion,vimPatSepErr,vimNotation
    6              0.000164 syn cluster	vimSynRegGroup	contains=vimSynContains,vimSynNextgroup,vimSynRegOpt,vimSynReg,vimSynMtchGrp
    6              0.000120 syn keyword	vimSynType	contained	region	skipwhite nextgroup=vimSynRegion
    6              0.000126 syn region	vimSynRegion	contained keepend	matchgroup=vimGroupName start="\h\w*" skip="\\\\\|\\|" end="|\|$" contains=@vimSynRegGroup
    6              0.000177 syn match	vimSynRegOpt	contained	"\%#=1\<\(conceal\(ends\)\=\|transparent\|contained\|excludenl\|skipempty\|skipwhite\|display\|keepend\|oneline\|extend\|skipnl\|fold\)\>"
    6              0.000124 syn match	vimSynReg	contained	"\(start\|skip\|end\)="he=e-1	nextgroup=vimSynRegPat
    6              0.000272 syn match	vimSynMtchGrp	contained	"matchgroup="	nextgroup=vimGroup,vimHLGroup,vimOnlyHLGroup,nvimHLGroup
    6              0.000189 syn region	vimSynRegPat	contained extend	start="\z([-`~!@#$%^&*_=+;:'",./?]\)"  skip="\\\\\|\\\z1"  end="\z1"  contains=@vimSynRegPatGroup skipwhite nextgroup=vimSynPatMod,vimSynReg
    6              0.000093 syn match	vimSynPatMod	contained	"\%#=1\(hs\|ms\|me\|hs\|he\|rs\|re\)=[se]\([-+]\d\+\)\="
    6              0.000127 syn match	vimSynPatMod	contained	"\%#=1\(hs\|ms\|me\|hs\|he\|rs\|re\)=[se]\([-+]\d\+\)\=," nextgroup=vimSynPatMod
    6              0.000077 syn match	vimSynPatMod	contained	"lc=\d\+"
    6              0.000059 syn match	vimSynPatMod	contained	"lc=\d\+," nextgroup=vimSynPatMod
    6              0.000084 syn region	vimSynPatRange	contained	start="\["	skip="\\\\\|\\]"   end="]"
    6              0.000042 syn match	vimSynNotPatRange	contained	"\\\\\|\\\["
    6              0.000039 syn match	vimMtchComment	contained	'"[^"]\+$'
    6              0.000142 syn cluster vimFuncBodyList add=vimSynType
                            
                            " Syntax: sync {{{2
                            " ============
    6              0.000283 syn keyword vimSynType	contained	sync	skipwhite	nextgroup=vimSyncC,vimSyncLines,vimSyncMatch,vimSyncError,vimSyncLinebreak,vimSyncLinecont,vimSyncRegion
    6              0.000074 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_novimsyncerror")
    6              0.000035  syn match	vimSyncError	contained	"\i\+"
    6              0.000009 endif
    6              0.000036 syn keyword	vimSyncC	contained	ccomment	clear	fromstart
    6              0.000061 syn keyword	vimSyncMatch	contained	match	skipwhite	nextgroup=vimSyncGroupName
    6              0.000046 syn keyword	vimSyncRegion	contained	region	skipwhite	nextgroup=vimSynReg
    6              0.000087 syn match	vimSyncLinebreak	contained	"\<linebreaks="	skipwhite	nextgroup=vimNumber
    6              0.000048 syn keyword	vimSyncLinecont	contained	linecont	skipwhite	nextgroup=vimSynRegPat
    6              0.000099 syn match	vimSyncLines	contained	"\(min\|max\)\=lines="	nextgroup=vimNumber
    6              0.000065 syn match	vimSyncGroupName	contained	"\h\w*"	skipwhite	nextgroup=vimSyncKey
    6              0.000093 syn match	vimSyncKey	contained	"\<groupthere\|grouphere\>"	skipwhite nextgroup=vimSyncGroup
    6              0.000084 syn match	vimSyncGroup	contained	"\h\w*"	skipwhite	nextgroup=vimSynRegPat,vimSyncNone
    6              0.000025 syn keyword	vimSyncNone	contained	NONE
                            
                            " Additional IsCommand, here by reasons of precedence {{{2
                            " ====================
    6              0.000219 syn match	vimIsCommand	"<Bar>\s*\a\+"	transparent contains=vimCommand,vimNotation
                            
                            " Highlighting {{{2
                            " ============
    6              0.000218 syn cluster	vimHighlightCluster		contains=vimHiLink,vimHiClear,vimHiKeyList,vimComment
    6              0.000070 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_novimhictermerror")
    6              0.000048  syn match	vimHiCtermError	contained	"\D\i*"
    6              0.000009 endif
    6              0.001062 syn match	vimHighlight	"\<hi\%[ghlight]\>"	skipwhite nextgroup=vimHiBang,@vimHighlightCluster
    6              0.000052 syn match	vimHiBang	contained	"!"	skipwhite nextgroup=@vimHighlightCluster
                            
    6              0.000104 syn match	vimHiGroup	contained	"\i\+"
    6              0.000023 syn case ignore
    6              0.000096 syn keyword	vimHiAttrib	contained	none bold inverse italic nocombine reverse standout strikethrough underline undercurl
    6              0.000057 syn keyword	vimFgBgAttrib	contained	none bg background fg foreground
    6              0.000010 syn case match
    6              0.000066 syn match	vimHiAttribList	contained	"\i\+"	contains=vimHiAttrib
    6              0.000074 syn match	vimHiAttribList	contained	"\i\+,"he=e-1	contains=vimHiAttrib nextgroup=vimHiAttribList
    6              0.000022 syn case ignore
    6              0.004168 syn keyword	vimHiCtermColor	contained	black blue brown cyan darkblue darkcyan darkgray darkgreen darkgrey darkmagenta darkred darkyellow gray green grey lightblue lightcyan lightgray lightgreen lightgrey lightmagenta lightred magenta red white yellow
    6              0.000087 syn match	vimHiCtermColor	contained	"\<color\d\{1,3}\>"
                            
    6              0.000011 syn case match
    6              0.000059 syn match	vimHiFontname	contained	"[a-zA-Z\-*]\+"
    6              0.000062 syn match	vimHiGuiFontname	contained	"'[a-zA-Z\-* ]\+'"
    6              0.000052 syn match	vimHiGuiRgb	contained	"#\x\{6}"
                            
                            " Highlighting: hi group key=arg ... {{{2
    6              0.000667 syn cluster	vimHiCluster contains=vimGroup,vimHiBlend,vimHiGroup,vimHiTerm,vimHiCTerm,vimHiStartStop,vimHiCtermFgBg,vimHiGui,vimHiGuiFont,vimHiGuiFgBg,vimHiKeyError,vimNotation
    6              0.000135 syn region	vimHiKeyList	contained oneline start="\i\+" skip="\\\\\|\\|" end="$\||"	contains=@vimHiCluster
    6              0.000090 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_vimhikeyerror")
    6              0.000042  syn match	vimHiKeyError	contained	"\i\+="he=e-1
    6              0.000011 endif
    6              0.000062 syn match	vimHiTerm	contained	"\cterm="he=e-1		nextgroup=vimHiAttribList
    6              0.000126 syn match	vimHiStartStop	contained	"\c\(start\|stop\)="he=e-1	nextgroup=vimHiTermcap,vimOption
    6              0.000061 syn match	vimHiCTerm	contained	"\ccterm="he=e-1		nextgroup=vimHiAttribList
    6              0.000133 syn match	vimHiCtermFgBg	contained	"\ccterm[fb]g="he=e-1	nextgroup=vimHiNmbr,vimHiCtermColor,vimFgBgAttrib,vimHiCtermError
    6              0.000060 syn match	vimHiGui	contained	"\cgui="he=e-1		nextgroup=vimHiAttribList
    6              0.000054 syn match	vimHiGuiFont	contained	"\cfont="he=e-1		nextgroup=vimHiFontname
    6              0.000254 syn match	vimHiGuiFgBg	contained	"\cgui\%([fb]g\|sp\)="he=e-1	nextgroup=vimHiGroup,vimHiGuiFontname,vimHiGuiRgb,vimFgBgAttrib
    6              0.000076 syn match	vimHiTermcap	contained	"\S\+"		contains=vimNotation
    6              0.000067 syn match	vimHiBlend	contained	"\cblend="he=e-1		nextgroup=vimHiNmbr
    6              0.000029 syn match	vimHiNmbr	contained	'\d\+'
                            
                            " Highlight: clear {{{2
    6              0.000179 syn keyword	vimHiClear	contained	clear	nextgroup=vimHiGroup
                            
                            " Highlight: link {{{2
                            " see tst24 (hi def vs hi) (Jul 06, 2018)
                            "syn region	vimHiLink	contained oneline matchgroup=vimCommand start="\(\<hi\%[ghlight]\s\+\)\@<=\(\(def\%[ault]\s\+\)\=link\>\|\<def\>\)" end="$"	contains=vimHiGroup,vimGroup,vimHLGroup,vimNotation
    6              0.000301 syn region	vimHiLink	contained oneline matchgroup=vimCommand start="\(\<hi\%[ghlight]\s\+\)\@<=\(\(def\%[ault]\s\+\)\=link\>\|\<def\>\)" end="$"	contains=@vimHiCluster
    6              0.000165 syn cluster vimFuncBodyList add=vimHiLink
                            
                            " Control Characters {{{2
                            " ==================
    6              0.000056 syn match	vimCtrlChar	"[--]"
                            
                            " Beginners - Patterns that involve ^ {{{2
                            " =========
    6              0.000212 syn match	vimLineComment	+^[ \t:]*".*$+	contains=@vimCommentGroup,vimCommentString,vimCommentTitle
    6              0.000184 syn match	vimCommentTitle	'"\s*\%([sS]:\|\h\w*#\)\=\u\w*\(\s\+\u\w*\)*:'hs=s+1	contained contains=vimCommentTitleLeader,vimTodo,@vimCommentGroup
    6              0.000048 syn match	vimContinue	"^\s*\\"
    6              0.000158 syn region	vimString	start="^\s*\\\z(['"]\)" skip='\\\\\|\\\z1' end="\z1" oneline keepend contains=@vimStringGroup,vimContinue
    6              0.000039 syn match	vimCommentTitleLeader	'"\s\+'ms=s+1	contained
                            
                            " Searches And Globals: {{{2
                            " ====================
    6              0.000074 syn match	vimSearch	'^\s*[/?].*'		contains=vimSearchDelim
    6              0.000048 syn match	vimSearchDelim	'^\s*\zs[/?]\|[/?]$'	contained
    6              0.000226 syn region	vimGlobal	matchgroup=Statement start='\<g\%[lobal]!\=/'  skip='\\.' end='/'	skipwhite nextgroup=vimSubst
    6              0.000209 syn region	vimGlobal	matchgroup=Statement start='\<v\%[global]!\=/' skip='\\.' end='/'	skipwhite nextgroup=vimSubst
                            
                            " Scripts  : perl,ruby : Benoit Cerrina {{{2
                            " =======    python,tcl: Johannes Zellner
                            "            lua
                            
                            " Allows users to specify the type of embedded script highlighting
                            " they want:  (perl/python/ruby/tcl support)
                            "   g:vimsyn_embed == 0   : don't embed any scripts
                            "   g:vimsyn_embed =~# 'l' : embed lua
                            "   g:vimsyn_embed =~# 'm' : embed mzscheme
                            "   g:vimsyn_embed =~# 'p' : embed perl
                            "   g:vimsyn_embed =~# 'P' : embed python
                            "   g:vimsyn_embed =~# 'r' : embed ruby
                            "   g:vimsyn_embed =~# 't' : embed tcl
    6              0.000056 if !exists("g:vimsyn_embed")
    1              0.000019  let g:vimsyn_embed= 0
    6              0.000011 endif
                            
                            " [-- lua --] {{{3
    6              0.000279 let s:luapath= fnameescape(expand("<sfile>:p:h")."/lua.vim")
    6              0.003461 if !filereadable(s:luapath)
                             for s:luapath in split(globpath(&rtp,"syntax/lua.vim"),"\n")
                              if filereadable(fnameescape(s:luapath))
                               let s:luapath= fnameescape(s:luapath)
                               break
                              endif
                             endfor
    6              0.000011 endif
    6              0.000123 if g:vimsyn_embed =~# 'l' && filereadable(s:luapath)
                             unlet! b:current_syntax
                             syn cluster vimFuncBodyList	add=vimLuaRegion
                             exe "syn include @vimLuaScript ".s:luapath
                             VimFoldl syn region vimLuaRegion matchgroup=vimScriptDelim start=+lua\s*<<\s*\z(.*\)$+ end=+^\z1$+	contains=@vimLuaScript
                             VimFoldl syn region vimLuaRegion matchgroup=vimScriptDelim start=+lua\s*<<\s*$+ end=+\.$+	contains=@vimLuaScript
                             syn cluster vimFuncBodyList	add=vimLuaRegion
    6              0.000011 else
    6              0.000153  syn region vimEmbedError start=+lua\s*<<\s*\z(.*\)$+ end=+^\z1$+
    6              0.000075  syn region vimEmbedError start=+lua\s*<<\s*$+ end=+\.$+
    6              0.000010 endif
    6              0.000026 unlet s:luapath
                            
                            " [-- perl --] {{{3
    6              0.000201 let s:perlpath= fnameescape(expand("<sfile>:p:h")."/perl.vim")
    6              0.005064 if !filereadable(s:perlpath)
                             for s:perlpath in split(globpath(&rtp,"syntax/perl.vim"),"\n")
                              if filereadable(fnameescape(s:perlpath))
                               let s:perlpath= fnameescape(s:perlpath)
                               break
                              endif
                             endfor
    6              0.000010 endif
    6              0.000083 if g:vimsyn_embed =~# 'p' && filereadable(s:perlpath)
                             unlet! b:current_syntax
                             syn cluster vimFuncBodyList	add=vimPerlRegion
                             let s:foldmethod = &l:foldmethod
                             exe "syn include @vimPerlScript ".s:perlpath
                             let &l:foldmethod = s:foldmethod
                             VimFoldp syn region vimPerlRegion  matchgroup=vimScriptDelim start=+pe\%[rl]\s*<<\s*\z(\S*\)\ze\(\s*["#].*\)\=$+ end=+^\z1\ze\(\s*[#"].*\)\=$+	contains=@vimPerlScript
                             VimFoldp syn region vimPerlRegion	matchgroup=vimScriptDelim start=+pe\%[rl]\s*<<\s*$+ end=+\.$+			contains=@vimPerlScript
                             syn cluster vimFuncBodyList	add=vimPerlRegion
    6              0.000012 else
    6              0.000136  syn region vimEmbedError start=+pe\%[rl]\s*<<\s*\z(.*\)$+ end=+^\z1$+
    6              0.000089  syn region vimEmbedError start=+pe\%[rl]\s*<<\s*$+ end=+\.$+
    6              0.000012 endif
    6              0.000026 unlet s:perlpath
                            
                            " [-- ruby --] {{{3
    6              0.000197 let s:rubypath= fnameescape(expand("<sfile>:p:h")."/ruby.vim")
    6              0.004388 if !filereadable(s:rubypath)
                             for s:rubypath in split(globpath(&rtp,"syntax/ruby.vim"),"\n")
                              if filereadable(fnameescape(s:rubypath))
                               let s:rubypath= fnameescape(s:rubypath)
                               break
                              endif
                             endfor
    6              0.000010 endif
    6              0.000075 if g:vimsyn_embed =~# 'r' && filereadable(s:rubypath)
                             syn cluster vimFuncBodyList	add=vimRubyRegion
                             unlet! b:current_syntax
                             let s:foldmethod = &l:foldmethod
                             exe "syn include @vimRubyScript ".s:rubypath
                             let &l:foldmethod = s:foldmethod
                             VimFoldr syn region vimRubyRegion	matchgroup=vimScriptDelim start=+rub[y]\s*<<\s*\z(\S*\)\ze\(\s*#.*\)\=$+ end=+^\z1\ze\(\s*".*\)\=$+	contains=@vimRubyScript
                             syn region vimRubyRegion	matchgroup=vimScriptDelim start=+rub[y]\s*<<\s*$+ end=+\.$+			contains=@vimRubyScript
                             syn cluster vimFuncBodyList	add=vimRubyRegion
    6              0.000010 else
    6              0.000093  syn region vimEmbedError start=+rub[y]\s*<<\s*\z(.*\)$+ end=+^\z1$+
    6              0.000066  syn region vimEmbedError start=+rub[y]\s*<<\s*$+ end=+\.$+
    6              0.000009 endif
    6              0.000023 unlet s:rubypath
                            
                            " [-- python --] {{{3
    6              0.000212 let s:pythonpath= fnameescape(expand("<sfile>:p:h")."/python.vim")
    6              0.004290 if !filereadable(s:pythonpath)
                             for s:pythonpath in split(globpath(&rtp,"syntax/python.vim"),"\n")
                              if filereadable(fnameescape(s:pythonpath))
                               let s:pythonpath= fnameescape(s:pythonpath)
                               break
                              endif
                             endfor
    6              0.000009 endif
    6              0.000074 if g:vimsyn_embed =~# 'P' && filereadable(s:pythonpath)
                             unlet! b:current_syntax
                             syn cluster vimFuncBodyList	add=vimPythonRegion
                             exe "syn include @vimPythonScript ".s:pythonpath
                             VimFoldP syn region vimPythonRegion matchgroup=vimScriptDelim start=+py\%[thon]3\=\s*<<\s*\z(\S*\)\ze\(\s*#.*\)\=$+ end=+^\z1\ze\(\s*".*\)\=$+	contains=@vimPythonScript
                             VimFoldP syn region vimPythonRegion matchgroup=vimScriptDelim start=+py\%[thon]3\=\s*<<\s*$+ end=+\.$+			contains=@vimPythonScript
                             VimFoldP syn region vimPythonRegion matchgroup=vimScriptDelim start=+Py\%[thon]2or3\s*<<\s*\z(\S*\)\ze\(\s*#.*\)\=$+ end=+^\z1\ze\(\s*".*\)\=$+	contains=@vimPythonScript
                             VimFoldP syn region vimPythonRegion matchgroup=vimScriptDelim start=+Py\%[thon]2or3\=\s*<<\s*$+ end=+\.$+			contains=@vimPythonScript
                             syn cluster vimFuncBodyList	add=vimPythonRegion
    6              0.000011 else
    6              0.000128  syn region vimEmbedError start=+py\%[thon]3\=\s*<<\s*\z(.*\)$+ end=+^\z1$+
    6              0.000089  syn region vimEmbedError start=+py\%[thon]3\=\s*<<\s*$+ end=+\.$+
    6              0.000010 endif
    6              0.000025 unlet s:pythonpath
                            
                            " [-- tcl --] {{{3
    6              0.000124 if has("win32") || has("win95") || has("win64") || has("win16")
                             " apparently has("tcl") has been hanging vim on some windows systems with cygwin
                             let s:trytcl= (&shell !~ '\<\%(bash\>\|4[nN][tT]\|\<zsh\)\>\%(\.exe\)\=$')
    6              0.000009 else
    6              0.000028  let s:trytcl= 1
    6              0.000009 endif
    6              0.000015 if s:trytcl
    6              0.000180  let s:tclpath= fnameescape(expand("<sfile>:p:h")."/tcl.vim")
    6              0.004237  if !filereadable(s:tclpath)
                              for s:tclpath in split(globpath(&rtp,"syntax/tcl.vim"),"\n")
                               if filereadable(fnameescape(s:tclpath))
                                let s:tclpath= fnameescape(s:tclpath)
                                break
                               endif
                              endfor
    6              0.000010  endif
    6              0.000074  if g:vimsyn_embed =~# 't' && filereadable(s:tclpath)
                              unlet! b:current_syntax
                              syn cluster vimFuncBodyList	add=vimTclRegion
                              exe "syn include @vimTclScript ".s:tclpath
                              VimFoldt syn region vimTclRegion matchgroup=vimScriptDelim start=+tc[l]\=\s*<<\s*\z(.*\)$+ end=+^\z1$+	contains=@vimTclScript
                              VimFoldt syn region vimTclRegion matchgroup=vimScriptDelim start=+tc[l]\=\s*<<\s*$+ end=+\.$+	contains=@vimTclScript
                              syn cluster vimFuncBodyList	add=vimTclScript
    6              0.000010  else
    6              0.000119   syn region vimEmbedError start=+tc[l]\=\s*<<\s*\z(.*\)$+ end=+^\z1$+
    6              0.000073   syn region vimEmbedError start=+tc[l]\=\s*<<\s*$+ end=+\.$+
    6              0.000010  endif
    6              0.000024  unlet s:tclpath
                            else
                             syn region vimEmbedError start=+tc[l]\=\s*<<\s*\z(.*\)$+ end=+^\z1$+
                             syn region vimEmbedError start=+tc[l]\=\s*<<\s*$+ end=+\.$+
    6              0.000012 endif
    6              0.000019 unlet s:trytcl
                            
                            " [-- mzscheme --] {{{3
    6              0.000191 let s:mzschemepath= fnameescape(expand("<sfile>:p:h")."/scheme.vim")
    6              0.004345 if !filereadable(s:mzschemepath)
                             for s:mzschemepath in split(globpath(&rtp,"syntax/mzscheme.vim"),"\n")
                              if filereadable(fnameescape(s:mzschemepath))
                               let s:mzschemepath= fnameescape(s:mzschemepath)
                               break
                              endif
                             endfor
    6              0.000029 endif
    6              0.000074 if g:vimsyn_embed =~# 'm' && filereadable(s:mzschemepath)
                             unlet! b:current_syntax
                             let s:iskKeep= &isk
                             syn cluster vimFuncBodyList	add=vimMzSchemeRegion
                             exe "syn include @vimMzSchemeScript ".s:mzschemepath
                             let &isk= s:iskKeep
                             unlet s:iskKeep
                             VimFoldm syn region vimMzSchemeRegion matchgroup=vimScriptDelim start=+mz\%[scheme]\s*<<\s*\z(.*\)$+ end=+^\z1$+	contains=@vimMzSchemeScript
                             VimFoldm syn region vimMzSchemeRegion matchgroup=vimScriptDelim start=+mz\%[scheme]\s*<<\s*$+ end=+\.$+		contains=@vimMzSchemeScript
                             syn cluster vimFuncBodyList	add=vimMzSchemeRegion
    6              0.000010 else
    6              0.000126  syn region vimEmbedError start=+mz\%[scheme]\s*<<\s*\z(.*\)$+ end=+^\z1$+
    6              0.000086  syn region vimEmbedError start=+mz\%[scheme]\s*<<\s*$+ end=+\.$+
    6              0.000010 endif
    6              0.000023 unlet s:mzschemepath
                            
                            " Synchronize (speed) {{{2
                            "============
    6              0.000049 if exists("g:vimsyn_minlines")
                             exe "syn sync minlines=".g:vimsyn_minlines
    6              0.000009 endif
    6              0.000066 exe "syn sync maxlines=".s:vimsyn_maxlines
    6              0.000036 syn sync linecont	"^\s\+\\"
    6              0.000120 syn sync match vimAugroupSyncA	groupthere NONE	"\<aug\%[roup]\>\s\+[eE][nN][dD]"
                            
                            " ====================
                            " Highlighting Settings {{{2
                            " ====================
                            
    6              0.000041 if !exists("skip_vim_syntax_inits")
    6              0.000034  if !exists("g:vimsyn_noerror")
    6              0.000091   hi def link vimBehaveError	vimError
    6              0.000032   hi def link vimCollClassErr	vimError
    6              0.000039   hi def link vimErrSetting	vimError
    6              0.000143   hi def link vimEmbedError	Normal
    6              0.000048   hi def link vimFTError	vimError
    6              0.000038   hi def link vimFunctionError	vimError
    6              0.000100   hi def link vimFunc         	vimError
    6              0.000023   hi def link vimHiAttribList	vimError
    6              0.000021   hi def link vimHiCtermError	vimError
    6              0.000020   hi def link vimHiKeyError	vimError
    6              0.000037   hi def link vimKeyCodeError	vimError
    6              0.000027   hi def link vimMapModErr	vimError
    6              0.000027   hi def link vimSubstFlagErr	vimError
    6              0.000024   hi def link vimSynCaseError	vimError
    6              0.000041   hi def link vimBufnrWarn	vimWarn
    6              0.000010  endif
                            
    6              0.000092  hi def link vimAbb	vimCommand
    6              0.000053  hi def link vimAddress	vimMark
    6              0.000032  hi def link vimAugroupError	vimError
    6              0.000085  hi def link vimAugroupKey	vimCommand
    6              0.000053  hi def link vimAuHighlight	vimHighlight
    6              0.000049  hi def link vimAutoCmdOpt	vimOption
    6              0.000176  hi def link vimAutoCmd	vimCommand
    6              0.000102  hi def link vimAutoEvent	Type
    6              0.000092  hi def link vimAutoSet	vimCommand
    6              0.000049  hi def link vimBehaveModel	vimBehave
    6              0.000082  hi def link vimBehave	vimCommand
    6              0.000092  hi def link vimBracket	Delimiter
    6              0.000095  hi def link vimCmplxRepeat	SpecialChar
    6              0.000122  hi def link vimCommand	Statement
    6              0.000087  hi def link vimComment	Comment
    6              0.000088  hi def link vimCommentString	vimString
    6              0.000074  hi def link vimCommentTitle	PreProc
    6              0.000087  hi def link vimCondHL	vimCommand
    6              0.000084  hi def link vimContinue	Special
    6              0.000093  hi def link vimCtrlChar	SpecialChar
    6              0.000077  hi def link vimEchoHLNone	vimGroup
    6              0.000079  hi def link vimEchoHL	vimCommand
    6              0.000084  hi def link vimElseIfErr	Error
    6              0.000038  hi def link vimElseif	vimCondHL
    6              0.000091  hi def link vimEnvvar	PreProc
    6              0.000079  hi def link vimError	Error
    6              0.000085  hi def link vimFBVar	vimVar
    6              0.000026  hi def link vimFgBgAttrib	vimHiAttrib
    6              0.000102  hi def link vimFold	Folded
    6              0.000081  hi def link vimFTCmd	vimCommand
    6              0.000091  hi def link vimFTOption	vimSynType
    6              0.000078  hi def link vimFuncKey	vimCommand
    6              0.000093  hi def link vimFuncName	Function
    6              0.000092  hi def link vimFuncSID	Special
    6              0.009830  hi def link vimFuncVar	Identifier
    6              0.000051  hi def link vimGroupAdd	vimSynOption
    6              0.000089  hi def link vimGroupName	vimGroup
    6              0.000027  hi def link vimGroupRem	vimSynOption
    6              0.000078  hi def link vimGroupSpecial	Special
    6              0.000128  hi def link vimGroup	Type
    6              0.000075  hi def link vimHiAttrib	PreProc
    6              0.000023  hi def link vimHiBlend	vimHiTerm
    6              0.000031  hi def link vimHiClear	vimHighlight
    6              0.000024  hi def link vimHiCtermFgBg	vimHiTerm
    6              0.000020  hi def link vimHiCTerm	vimHiTerm
    6              0.000084  hi def link vimHighlight	vimCommand
    6              0.000084  hi def link vimHiGroup	vimGroupName
    6              0.000024  hi def link vimHiGuiFgBg	vimHiTerm
    6              0.000020  hi def link vimHiGuiFont	vimHiTerm
    6              0.000034  hi def link vimHiGuiRgb	vimNumber
    6              0.000021  hi def link vimHiGui	vimHiTerm
    6              0.000075  hi def link vimHiNmbr	Number
    6              0.000024  hi def link vimHiStartStop	vimHiTerm
    6              0.000078  hi def link vimHiTerm	Type
    6              0.000078  hi def link vimHLGroup	vimGroup
    6              0.000084  hi def link vimHLMod	PreProc
    6              0.000044  hi def link vimInsert	vimString
    6              0.000079  hi def link vimIskSep	Delimiter
    6              0.000049  hi def link vimKeyCode	vimSpecFile
    6              0.000083  hi def link vimKeyword	Statement
    6              0.000080  hi def link vimLet	vimCommand
    6              0.000045  hi def link vimLineComment	vimComment
    6              0.000070  hi def link vimMapBang	vimCommand
    6              0.000036  hi def link vimMapModKey	vimFuncSID
    6              0.000029  hi def link vimMapMod	vimBracket
    6              0.000083  hi def link vimMap	vimCommand
    6              0.000089  hi def link vimMark	Number
    6              0.000041  hi def link vimMarkNumber	vimNumber
    6              0.000030  hi def link vimMenuMod	vimMapMod
    6              0.000029  hi def link vimMenuNameMore	vimMenuName
    6              0.000083  hi def link vimMenuName	PreProc
    6              0.000076  hi def link vimMtchComment	vimComment
    6              0.000103  hi def link vimNorm	vimCommand
    6              0.000150  hi def link vimNotation	Special
    6              0.000108  hi def link vimNotFunc	vimCommand
    6              0.000048  hi def link vimNotPatSep	vimString
    6              0.000102  hi def link vimNumber	Number
    6              0.000121  hi def link vimOperError	Error
    6              0.000144  hi def link vimOper	Operator
    6              0.000097  hi def link vimOption	PreProc
    6              0.000128  hi def link vimParenSep	Delimiter
    6              0.000039  hi def link vimPatSepErr	vimError
    6              0.000039  hi def link vimPatSepR	vimPatSep
    6              0.000122  hi def link vimPatSep	SpecialChar
    6              0.000051  hi def link vimPatSepZone	vimString
    6              0.000037  hi def link vimPatSepZ	vimPatSep
    6              0.000100  hi def link vimPattern	Type
    6              0.000046  hi def link vimPlainMark	vimMark
    6              0.000053  hi def link vimPlainRegister	vimRegister
    6              0.000096  hi def link vimRegister	SpecialChar
    6              0.000094  hi def link vimScriptDelim	Comment
    6              0.000076  hi def link vimSearchDelim	Statement
    6              0.000045  hi def link vimSearch	vimString
    6              0.000090  hi def link vimSep	Delimiter
    6              0.000041  hi def link vimSetMod	vimOption
    6              0.000087  hi def link vimSetSep	Statement
    6              0.000044  hi def link vimSetString	vimString
    6              0.000092  hi def link vimSpecFile	Identifier
    6              0.000045  hi def link vimSpecFileMod	vimSpecFile
    6              0.000093  hi def link vimSpecial	Type
    6              0.000091  hi def link vimStatement	Statement
    6              0.000043  hi def link vimStringCont	vimString
    6              0.000087  hi def link vimString	String
    6              0.000044  hi def link vimStringEnd	vimString
    6              0.000041  hi def link vimSubst1	vimSubst
    6              0.000097  hi def link vimSubstDelim	Delimiter
    6              0.000107  hi def link vimSubstFlags	Special
    6              0.000100  hi def link vimSubstSubstr	SpecialChar
    6              0.000048  hi def link vimSubstTwoBS	vimString
    6              0.000090  hi def link vimSubst	vimCommand
    6              0.000092  hi def link vimSynCaseError	Error
    6              0.000093  hi def link vimSynCase	Type
    6              0.000098  hi def link vimSyncC	Type
    6              0.000092  hi def link vimSyncError	Error
    6              0.000064  hi def link vimSyncGroupName	vimGroupName
    6              0.000034  hi def link vimSyncGroup	vimGroupName
    6              0.000090  hi def link vimSyncKey	Type
    6              0.000091  hi def link vimSyncNone	Type
    6              0.000031  hi def link vimSynContains	vimSynOption
    6              0.000088  hi def link vimSynError	Error
    6              0.000040  hi def link vimSynKeyContainedin	vimSynContains
    6              0.000026  hi def link vimSynKeyOpt	vimSynOption
    6              0.000024  hi def link vimSynMtchGrp	vimSynOption
    6              0.000075  hi def link vimSynMtchOpt	vimSynOption
    6              0.000081  hi def link vimSynNextgroup	vimSynOption
    6              0.000032  hi def link vimSynNotPatRange	vimSynRegPat
    6              0.000078  hi def link vimSynOption	Special
    6              0.000042  hi def link vimSynPatRange	vimString
    6              0.000026  hi def link vimSynRegOpt	vimSynOption
    6              0.000037  hi def link vimSynRegPat	vimString
    6              0.000086  hi def link vimSynReg	Type
    6              0.000093  hi def link vimSyntax	vimCommand
    6              0.000116  hi def link vimSynType	vimSpecial
    6              0.000092  hi def link vimTodo	Todo
    6              0.000049  hi def link vimUnmap	vimMap
    6              0.000086  hi def link vimUserAttrbCmpltFunc	Special
    6              0.000036  hi def link vimUserAttrbCmplt	vimSpecial
    6              0.000040  hi def link vimUserAttrbKey	vimOption
    6              0.000030  hi def link vimUserAttrb	vimSpecial
    6              0.000088  hi def link vimUserAttrbError	Error
    6              0.000092  hi def link vimUserCmdError	Error
    6              0.000084  hi def link vimUserCommand	vimCommand
    6              0.000137  hi def link vimUserFunc	Normal
    6              0.000133  hi def link vimVar	Identifier
    6              0.000091  hi def link vimWarn	WarningMsg
                            
    6              0.000036  hi def link nvimAutoEvent	vimAutoEvent
    6              0.000049  hi def link nvimHLGroup	vimHLGroup
    6              0.000039  hi def link nvimMap	vimMap
    6              0.000035  hi def link nvimUnmap	vimUnmap
    6              0.000011 endif
                            
                            " Current Syntax Variable: {{{2
    6              0.000060 let b:current_syntax = "vim"
                            
                            " ---------------------------------------------------------------------
                            " Cleanup: {{{1
    6              0.000059 delc VimFolda
    6              0.000031 delc VimFoldf
    6              0.000027 delc VimFoldl
    6              0.000025 delc VimFoldm
    6              0.000024 delc VimFoldp
    6              0.000023 delc VimFoldP
    6              0.000023 delc VimFoldr
    6              0.000024 delc VimFoldt
    6              0.000141 let &cpo = s:keepcpo
    6              0.000028 unlet s:keepcpo
                            " vim:ts=18  fdm=marker

SCRIPT  /usr/local/Cellar/neovim/HEAD-40a7427/share/nvim/runtime/syntax/vim/generated.vim
Sourced 12 times
Total time:   0.054398
 Self time:   0.054398

count  total (s)   self (s)
   12              0.020692 syn keyword vimCommand contained  a[ppend] ab[breviate] abc[lear] abo[veleft] al[l] am[enu] an[oremenu] ar[gs] arga[dd] argd[elete] argdo arge[dit] argg[lobal] argl[ocal] argu[ment] as[cii] aun[menu] b[uffer] bN[ext] ba[ll] bad[d] bd[elete] be[have] bel[owright] bf[irst] bl[ast] bm[odified] bn[ext] bo[tright] bp[revious] br[ewind] brea[k] breaka[dd] breakd[el] breakl[ist] bro[wse] bu[ffers] bufd[o] bun[load] bw[ipeout] c[hange] cN[ext] cNf[ile] ca[bbrev] cabc[lear] cabo[ve] cad[dbuffer] cadde[xpr] caddf[ile] cal[l] cat[ch] cb[uffer] cbe[low] cbo[ttom] cc ccl[ose] cd cdo ce[nter] cex[pr] cf[ile] cfd[o] cfi[rst] cg[etfile] cgetb[uffer] cgete[xpr] ch[dir] cha[nges] che[ckhealth] checkp[ath] checkt[ime] chi[story] cl[ist] cla[st] clo[se] cle[arjumps] cm[ap] cmapc[lear] cme[nu] cn[ext] cnew[er] cnf[ile] cno[remap] cnorea[bbrev] cnorem[enu] co[py]
   12              0.002055 syn keyword vimCommand contained  col[der] colo[rscheme] com[mand] comc[lear] comp[iler] con[tinue] conf[irm] cons[t] cop[en] cp[revious] cpf[ile] cq[uit] cr[ewind] cs[cope] cst[ag] cu[nmap] cuna[bbrev] cunm[enu] cw[indow] d[elete] delm[arks] deb[ug] debugg[reedy] del[command] delf[unction] di[splay] dif[fupdate] diffg[et] diffo[ff] diffp[atch] diffpu[t] diffs[plit] difft[his] dig[raphs] dj[ump] dl[ist] dr[op] ds[earch] dsp[lit] e[dit] ea[rlier] ec[ho] echoe[rr] echoh[l] echom[sg] echon el[se] elsei[f] em[enu] en[dif] endf[unction] endfo[r] endt[ry] endw[hile] ene[w] ex exe[cute] exi[t] exu[sage] f[ile] files filet[ype] filt[er] fin[d] fina[lly] fini[sh] fir[st] fo[ld] foldc[lose] foldd[oopen] folddoc[losed] foldo[pen] for fu[nction] g[lobal] go[to] gr[ep] grepa[dd] gu[i] gv[im] h[elp] helpc[lose] helpg[rep] helpt[ags] ha[rdcopy] hi[ghlight]
   12              0.001565 syn keyword vimCommand contained  hid[e] his[tory] i[nsert] ia[bbrev] iabc[lear] if ij[ump] il[ist] im[ap] imapc[lear] ime[nu] in[oremap] inorea[bbrev] inorem[enu] int[ro] is[earch] isp[lit] iu[nmap] iuna[bbrev] iunm[enu] j[oin] ju[mps] k ke[epmarks] keepj[umps] keepp[atterns] keepa[lt] l[ist] lN[ext] lNf[ile] la[st] lab[ove] lan[guage] lad[dexpr] laddb[uffer] laddf[ile] lat[er] lb[uffer] lbe[low] lbo[ttom] lc[d] lch[dir] lcl[ose] lcs[cope] ld[o] le[ft] lefta[bove] let lex[pr] lf[ile] lfd[o] lfi[rst] lg[etfile] lgetb[uffer] lgete[xpr] lgr[ep] lgrepa[dd] lh[elpgrep] lhi[story] ll lla[st] lli[st] lm[ap] lmapc[lear] lmak[e] ln[oremap] lne[xt] lnew[er] lnf[ile] lo[adview] loadk[eymap] loc[kmarks] lockv[ar] lol[der] lop[en] lp[revious] lpf[ile] lr[ewind] lt[ag] lu[nmap] lua luad[o] luaf[ile] lv[imgrep] lvimgrepa[dd] lw[indow] ls m[ove] ma[rk] mak[e]
   12              0.005388 syn keyword vimCommand contained  map mapc[lear] mar[ks] mat[ch] me[nu] menut[ranslate] mes[sages] mk[exrc] mks[ession] mksp[ell] mkv[imrc] mkvie[w] mo[de] mz[scheme] mzf[ile] n[ext] new nm[ap] nmapc[lear] nme[nu] nn[oremap] nnoreme[nu] no[remap] noa[utocmd] noh[lsearch] nor[eabbrev] norem[enu] nos[wapfile] nor[mal] nu[mber] nun[map] nunme[nu] o[ldfiles] om[ap] omapc[lear] ome[nu] on[ly] ono[remap] onoreme[nu] op[tions] ou[nmap] ounme[nu] ow[nsyntax] p[rint] pa[ckadd] packl[oadall] pc[lose] pe[rl] perld[o] perlf[ile] ped[it] po[p] popu[p] pp[op] pr[eserve] prev[ious] pro[file] profd[el] ps[earch] pt[ag] ptN[ext] ptf[irst] ptj[ump] ptl[ast] ptn[ext] ptp[revious] ptr[ewind] pts[elect] pu[t] pw[d] py[thon] pyd[o] pyf[ile] py3 py3d[o] pyt[hon3] py3[file] pyx pyxd[o] pyt[honx] pyx[file] q[uit] quita[ll] qa[ll] r[ead] rec[over] red[o] redi[r] redr[aw]
   12              0.001804 syn keyword vimCommand contained  redraws[tatus] redrawt[abline] reg[isters] res[ize] ret[ab] retu[rn] rew[ind] ri[ght] rightb[elow] rs[hada] ru[ntime] rund[o] rub[y] rubyd[o] rubyf[ile] rv[iminfo] s[ubstitute] sN[ext] sa[rgument] sal[l] san[dbox] sav[eas] sb[uffer] sbN[ext] sba[ll] sbf[irst] sbl[ast] sbm[odified] sbn[ext] sbp[revious] sbr[ewind] sc[riptnames] scripte[ncoding] scs[cope] se[t] setf[iletype] setg[lobal] setl[ocal] sf[ind] sfir[st] si[malt] sig[n] sil[ent] sl[eep] sla[st] sm[agic] smap smapc[lear] sme[nu] sn[ext] sno[magic] snor[emap] snoreme[nu] so[urce] sor[t] sp[lit] spe[llgood] spelld[ump] spelli[nfo] spellr[epall] spellu[ndo] spellw[rong] spr[evious] sr[ewind] st[op] sta[g] star[tinsert] startg[replace] startr[eplace] sto[pinsert] stj[ump] sts[elect] su[nhide] sunm[ap] sunme[nu] sus[pend] sv[iew] sw[apname] sy[ntax] synti[me]
   12              0.001686 syn keyword vimCommand contained  sync[bind] t tc[d] tch[dir] tN[ext] ta[g] tags tab tabc[lose] tabd[o] tabe[dit] tabf[ind] tabfir[st] tabm[ove] tabl[ast] tabn[ext] tabnew tabo[nly] tabp[revious] tabN[ext] tabr[ewind] tabs tc[l] tcld[o] tclf[ile] te[rminal] tf[irst] th[row] tj[ump] tl[ast] tm[enu] tma[p] tmapc[lear] tn[ext] tno[remap] to[pleft] tp[revious] tr[ewind] try ts[elect] tu[nmenu] tunma[p] u[ndo] undoj[oin] undol[ist] una[bbreviate] unh[ide] unl[et] unlo[ckvar] unm[ap] unme[nu] uns[ilent] up[date] v[global] ve[rsion] verb[ose] vert[ical] vi[sual] vie[w] vim[grep] vimgrepa[dd] viu[sage] vm[ap] vmapc[lear] vme[nu] vn[oremap] vne[w] vno[remenu] vs[plit] vu[nmap] vunme[nu] w[rite] wN[ext] wa[ll] wh[ile] wi[nsize] winc[md] wind[o] winp[os] wn[ext] wp[revious] wq wqa[ll] ws[hada] wu[ndo] wv[iminfo] x[it] xa[ll] xm[ap] xmapc[lear] xme[nu]
   12              0.000323 syn keyword vimCommand contained  xn[oremap] xnoreme[nu] xu[nmap] xunme[nu] y[ank] N[ext]
                            
   12              0.000617 syn keyword vimOption contained  aleph al arabic arab invarabic noarabic invarab noarab arabicshape arshape invarabicshape noarabicshape invarshape noarshape allowrevins ari invallowrevins noallowrevins invari noari ambiwidth ambw autochdir acd invautochdir noautochdir invacd noacd autoindent ai invautoindent noautoindent invai noai autoread ar invautoread noautoread invar noar autowrite aw invautowrite noautowrite invaw noaw autowriteall awa invautowriteall noautowriteall invawa noawa background bg backspace bs backup bk invbackup nobackup invbk nobk backupcopy bkc backupdir bdir backupext bex backupskip bsk belloff bo binary bin invbinary nobinary invbin nobin bomb invbomb nobomb breakat brk breakindent bri invbreakindent nobreakindent invbri nobri breakindentopt briopt browsedir bsdir bufhidden bh buflisted bl invbuflisted nobuflisted invbl nobl
   12              0.000784 syn keyword vimOption contained  buftype bt casemap cmp cdpath cd cedit channel charconvert ccv cindent cin invcindent nocindent invcin nocin cinkeys cink cinoptions cino cinwords cinw clipboard cb cmdheight ch cmdwinheight cwh colorcolumn cc columns co comments com commentstring cms complete cpt concealcursor cocu conceallevel cole completefunc cfu completeopt cot completeslash csl confirm cf invconfirm noconfirm invcf nocf copyindent ci invcopyindent nocopyindent invci noci cpoptions cpo cscopepathcomp cspc cscopeprg csprg cscopequickfix csqf cscoperelative csre invcscoperelative nocscoperelative invcsre nocsre cscopetag cst invcscopetag nocscopetag invcst nocst cscopetagorder csto cscopeverbose csverb invcscopeverbose nocscopeverbose invcsverb nocsverb cursorbind crb invcursorbind nocursorbind invcrb nocrb cursorcolumn cuc invcursorcolumn nocursorcolumn invcuc nocuc
   12              0.001847 syn keyword vimOption contained  cursorline cul invcursorline nocursorline invcul nocul debug define def delcombine deco invdelcombine nodelcombine invdeco nodeco dictionary dict diff invdiff nodiff diffexpr dex diffopt dip digraph dg invdigraph nodigraph invdg nodg directory dir display dy eadirection ead emoji emo invemoji noemoji invemo noemo encoding enc endofline eol invendofline noendofline inveol noeol equalalways ea invequalalways noequalalways invea noea equalprg ep errorbells eb inverrorbells noerrorbells inveb noeb errorfile ef errorformat efm eventignore ei expandtab et invexpandtab noexpandtab invet noet exrc ex invexrc noexrc invex noex fileencoding fenc fileencodings fencs fileformat ff fileformats ffs fileignorecase fic invfileignorecase nofileignorecase invfic nofic filetype ft fillchars fcs fixendofline fixeol invfixendofline nofixendofline invfixeol nofixeol
   12              0.002061 syn keyword vimOption contained  foldclose fcl foldcolumn fdc foldenable fen invfoldenable nofoldenable invfen nofen foldexpr fde foldignore fdi foldlevel fdl foldlevelstart fdls foldmarker fmr foldmethod fdm foldminlines fml foldnestmax fdn foldopen fdo foldtext fdt formatexpr fex formatoptions fo formatlistpat flp formatprg fp fsync fs invfsync nofsync invfs nofs gdefault gd invgdefault nogdefault invgd nogd grepformat gfm grepprg gp guicursor gcr guifont gfn guifontwide gfw guioptions go guitablabel gtl guitabtooltip gtt helpfile hf helpheight hh helplang hlg hidden hid invhidden nohidden invhid nohid highlight hl history hi hkmap hk invhkmap nohkmap invhk nohk hkmapp hkp invhkmapp nohkmapp invhkp nohkp hlsearch hls invhlsearch nohlsearch invhls nohls icon invicon noicon iconstring ignorecase ic invignorecase noignorecase invic noic imcmdline imc invimcmdline noimcmdline invimc noimc
   12              0.000631 syn keyword vimOption contained  imdisable imd invimdisable noimdisable invimd noimd iminsert imi imsearch ims inccommand icm include inc includeexpr inex incsearch is invincsearch noincsearch invis nois indentexpr inde indentkeys indk infercase inf invinfercase noinfercase invinf noinf insertmode im invinsertmode noinsertmode invim noim isfname isf isident isi iskeyword isk isprint isp joinspaces js invjoinspaces nojoinspaces invjs nojs jumpoptions jop keymap kmp keymodel km keywordprg kp langmap lmap langmenu lm langnoremap lnr invlangnoremap nolangnoremap invlnr nolnr langremap lrm invlangremap nolangremap invlrm nolrm laststatus ls lazyredraw lz invlazyredraw nolazyredraw invlz nolz linebreak lbr invlinebreak nolinebreak invlbr nolbr lines linespace lsp lisp invlisp nolisp lispwords lw list invlist nolist listchars lcs loadplugins lpl invloadplugins noloadplugins invlpl nolpl
   12              0.000607 syn keyword vimOption contained  magic invmagic nomagic makeef mef makeencoding menc makeprg mp matchpairs mps matchtime mat maxcombine mco maxfuncdepth mfd maxmapdepth mmd maxmempattern mmp menuitems mis mkspellmem msm modeline ml invmodeline nomodeline invml noml modelineexpr mle invmodelineexpr nomodelineexpr invmle nomle modelines mls modifiable ma invmodifiable nomodifiable invma noma modified mod invmodified nomodified invmod nomod more invmore nomore mouse mousefocus mousef invmousefocus nomousefocus invmousef nomousef mousehide mh invmousehide nomousehide invmh nomh mousemodel mousem mouseshape mouses mousetime mouset nrformats nf number nu invnumber nonumber invnu nonu numberwidth nuw omnifunc ofu opendevice odev invopendevice noopendevice invodev noodev operatorfunc opfunc packpath pp paragraphs para paste invpaste nopaste pastetoggle pt
   12              0.000613 syn keyword vimOption contained  patchexpr pex patchmode pm path pa preserveindent pi invpreserveindent nopreserveindent invpi nopi previewheight pvh previewwindow pvw invpreviewwindow nopreviewwindow invpvw nopvw printdevice pdev printencoding penc printexpr pexpr printfont pfn printheader pheader printmbcharset pmbcs printmbfont pmbfn printoptions popt prompt invprompt noprompt pumblend pb pumheight ph pumwidth pw pyxversion pyx quoteescape qe readonly ro invreadonly noreadonly invro noro redrawdebug rdb redrawtime rdt regexpengine re relativenumber rnu invrelativenumber norelativenumber invrnu nornu remap invremap noremap report revins ri invrevins norevins invri nori rightleft rl invrightleft norightleft invrl norl rightleftcmd rlc ruler ru invruler noruler invru noru rulerformat ruf runtimepath rtp scroll scr scrollback scbk scrollbind scb invscrollbind noscrollbind invscb noscb
   12              0.003264 syn keyword vimOption contained  scrolljump sj scrolloff so scrollopt sbo sections sect secure invsecure nosecure selection sel selectmode slm sessionoptions ssop shada sd shadafile sdf shell sh shellcmdflag shcf shellpipe sp shellquote shq shellredir srr shellslash ssl invshellslash noshellslash invssl nossl shelltemp stmp invshelltemp noshelltemp invstmp nostmp shellxquote sxq shellxescape sxe shiftround sr invshiftround noshiftround invsr nosr shiftwidth sw shortmess shm showbreak sbr showcmd sc invshowcmd noshowcmd invsc nosc showfulltag sft invshowfulltag noshowfulltag invsft nosft showmatch sm invshowmatch noshowmatch invsm nosm showmode smd invshowmode noshowmode invsmd nosmd showtabline stal sidescroll ss sidescrolloff siso signcolumn scl smartcase scs invsmartcase nosmartcase invscs noscs smartindent si invsmartindent nosmartindent invsi nosi
   12              0.000739 syn keyword vimOption contained  smarttab sta invsmarttab nosmarttab invsta nosta softtabstop sts spell invspell nospell spellcapcheck spc spellfile spf spelllang spl spellsuggest sps spelloptions spo splitbelow sb invsplitbelow nosplitbelow invsb nosb splitright spr invsplitright nosplitright invspr nospr startofline sol invstartofline nostartofline invsol nosol statusline stl suffixes su suffixesadd sua swapfile swf invswapfile noswapfile invswf noswf switchbuf swb synmaxcol smc syntax syn tagfunc tfu tabline tal tabpagemax tpm tabstop ts tagbsearch tbs invtagbsearch notagbsearch invtbs notbs tagcase tc taglength tl tagrelative tr invtagrelative notagrelative invtr notr tags tag tagstack tgst invtagstack notagstack invtgst notgst termbidi tbidi invtermbidi notermbidi invtbidi notbidi termencoding tenc termguicolors tgc invtermguicolors notermguicolors invtgc notgc
   12              0.000612 syn keyword vimOption contained  terse invterse noterse textwidth tw thesaurus tsr tildeop top invtildeop notildeop invtop notop timeout to invtimeout notimeout invto noto timeoutlen tm title invtitle notitle titlelen titleold titlestring ttimeout invttimeout nottimeout ttimeoutlen ttm undodir udir undofile udf invundofile noundofile invudf noudf undolevels ul undoreload ur updatecount uc updatetime ut verbose vbs verbosefile vfile viewdir vdir viewoptions vop viminfo vi viminfofile vif virtualedit ve visualbell vb invvisualbell novisualbell invvb novb warn invwarn nowarn whichwrap ww wildchar wc wildcharm wcm wildignore wig wildignorecase wic invwildignorecase nowildignorecase invwic nowic wildmenu wmnu invwildmenu nowildmenu invwmnu nowmnu wildmode wim wildoptions wop winaltkeys wak winblend winbl winhighlight winhl window wi winheight wh
   12              0.000292 syn keyword vimOption contained  winfixheight wfh invwinfixheight nowinfixheight invwfh nowfh winfixwidth wfw invwinfixwidth nowinfixwidth invwfw nowfw winminheight wmh winminwidth wmw winwidth wiw wrap invwrap nowrap wrapmargin wm wrapscan ws invwrapscan nowrapscan invws nows write invwrite nowrite writeany wa invwriteany nowriteany invwa nowa writebackup wb invwritebackup nowritebackup invwb nowb writedelay wd
                            
   12              0.000028 syn case ignore
                            
   12              0.001090 syn keyword vimAutoEvent contained  BufAdd BufDelete BufEnter BufFilePost BufFilePre BufHidden BufLeave BufNew BufNewFile BufReadCmd BufReadPost BufReadPre BufUnload BufWinEnter BufWinLeave BufWipeout BufWriteCmd BufWritePost BufWritePre ChanInfo ChanOpen CmdUndefined CmdWinEnter CmdWinLeave CmdlineChanged CmdlineEnter CmdlineLeave ColorScheme ColorSchemePre CompleteChanged CompleteDone CompleteDonePre CursorHold CursorHoldI CursorMoved CursorMovedI DiffUpdated EncodingChanged ExitPre FileAppendCmd FileAppendPost FileAppendPre FileChangedRO FileChangedShell FileChangedShellPost FileReadCmd FileReadPost FileReadPre FileType FileWriteCmd FileWritePost FileWritePre FilterReadPost FilterReadPre FilterWritePost FilterWritePre FocusGained FocusLost FuncUndefined GUIEnter GUIFailed InsertChange InsertCharPre InsertEnter InsertLeave InsertLeavePre
   12              0.000448 syn keyword vimAutoEvent contained  MenuPopup OptionSet QuickFixCmdPost QuickFixCmdPre QuitPre RemoteReply SessionLoadPost ShellCmdPost ShellFilterPost SourceCmd SourcePost SourcePre SpellFileMissing StdinReadPost StdinReadPre SwapExists Syntax TabEnter TabLeave TermChanged TermEnter TermLeave TermResponse TextChanged TextChangedI TextChangedP TextYankPost User VimEnter VimLeave VimLeavePre VimResized VimResume VimSuspend WinEnter WinLeave WinNew BufWrite FileEncoding BufCreate BufRead
                            
   12              0.000150 syn keyword nvimAutoEvent contained  UIEnter Signal TabNewEntered TabClosed UILeave WinClosed DirChanged TabNew TermClose TermOpen
                            
   12              0.000022 syn case match
                            
   12              0.000911 syn keyword vimFuncName contained  ceil lispindent nvim_buf_line_count nvim_put sign_getplaced rubyeval jobsend settabwinvar tagfiles append getwinposx msgpackparse nvim_buf_get_commands pathshorten nvim_set_current_tabpage inputrestore nvim_buf_get_changedtick expandcmd log resolve inputsave strcharpart nvim_win_set_cursor range sqrt winheight dictwatcheradd screenrow getcmdline getbufinfo histnr nvim_get_proc_children float2nr nvim_buf_clear_highlight dictwatcherdel settagstack win_findbuf nvim__id_float rpcstop hasmapto rpcnotify atan2 screenpos timer_stopall screenchar setcharsearch nvim__get_lib_dir nvim_win_get_width nvim_win_set_var jobpid nvim_get_current_tabpage asin sort winbufnr getjumplist bufnr foreground setfperm nvim_open_win str2nr strridx invert reg_recording getcompletion extend serverstop min nextnonblank appendbufline assert_fails
   12              0.000587 syn keyword vimFuncName contained  nvim_set_current_dir tabpagenr bufloaded stdpath setloclist atan nvim_win_get_height nvim_list_tabpages line2byte assert_inrange setqflist searchpair isinf getloclist buffer_exists virtcol writefile nvim_input serverlist getwininfo cosh nvim_tabpage_is_valid nvim_set_option nvim_get_namespaces exp json_encode nvim_replace_termcodes str2float spellbadword nvim_buf_del_var getcharsearch sign_place escape readfile str2list sign_jump nvim_set_keymap iconv strtrans nvim_buf_get_extmarks setbufline nvim_get_current_buf matchstrpos haslocaldir strdisplaywidth join nvim_del_keymap getqflist uniq nvim_input_mouse assert_equalfile nvim_buf_is_loaded tr eval localtime matchstr getwinpos filereadable insert nvim_buf_get_name pow foldlevel hostname getchar index type function byteidxcomp last_buffer_nr tabpagebuflist log10
   12              0.000868 syn keyword vimFuncName contained  has getenv flatten foldclosed json_decode ctxget exepath reltime trunc matchlist assert_true searchdecl sha256 nvim_buf_set_virtual_text byteidx wordcount assert_beeps libcall remove bufname wait assert_false hlexists tolower mapcheck getcwd jobwait search items spellsuggest did_filetype nvim_get_color_map undotree exists eventhandler prevnonblank tempname chansend keys perleval matchend ctxpush isdirectory file_readable nvim_buf_set_option nvim_out_write highlightID timer_info bufadd deletebufline nvim_get_proc debugbreak luaeval argidx add max nvim_get_runtime_file systemlist deepcopy nvim_win_get_position strftime sinh interrupt nvim_tabpage_get_win inputdialog shellescape tabpagewinnr jobclose map test_garbagecollect_now inputlist has_key sign_define test_write_list_log nvim_buf_get_option nr2char swapinfo
   12              0.001920 syn keyword vimFuncName contained  ctxsize acos gettabvar setwinvar assert_match nvim_win_set_config expand nvim_buf_set_extmark pum_getpos delete round nvim_paste nvim_get_color_by_name globpath values nvim_list_uis nvim_buf_del_extmark substitute synconcealed nvim_feedkeys indent reverse nvim_buf_get_keymap serverstart nvim_tabpage_get_number nvim_get_hl_by_name garbagecollect diff_filler nvim_tabpage_get_var char2nr maparg nvim_win_set_buf bufload foldclosedend pumvisible nvim_get_hl_by_id getftime rename fmod nvim_strwidth nvim__id_array pyxeval tanh nvim_win_get_option nvim__get_hl_defs changenr setreg assert_report nvim_get_current_win sign_getdefined nvim__buf_stats timer_start nvim_list_runtime_paths nvim_call_dict_function glob2regpat nvim_get_current_line sockconnect nvim_set_var split nvim_win_close getcmdtype prompt_setprompt foldtext
   12              0.000676 syn keyword vimFuncName contained  nvim_buf_add_highlight cursor nvim__screenshot nvim_command_output getregtype nvim__inspect_cell glob timer_stop inputsecret ctxset getcmdpos mode hlID getwinvar matcharg nvim_win_get_number nvim_err_writeln nvim_err_write assert_equal buffer_number nvim__stats copy strchars winlayout winnr reltimefloat nvim_buf_set_lines getwinposy strpart nvim_set_hl_ns getchangelist setcmdpos nvim_win_del_var highlight_exists screencol sign_unplace gettabwinvar execute or prompt_setinterrupt undofile synIDattr feedkeys strgetchar xor synID argv libcallnr timer_pause assert_exception winline nvim__id winsaveview isnan searchpairpos winrestview system getftype funcref nvim_win_set_height simplify shiftwidth abs nvim_win_is_valid finddir getline pyeval printf getfontname sign_undefine setline list2str nvim_set_current_win
   12              0.000568 syn keyword vimFuncName contained  assert_notequal getcmdwintype menu_get nvim_set_current_line nvim_eval jobstart nvim_buf_set_var synIDtrans matchadd submatch cos nvim_get_context nvim_call_function prompt_setcallback empty rpcstart nvim_command synstack nvim_set_hl environ nvim_list_wins arglistid fnamemodify col nvim_tabpage_list_wins nvim_buf_clear_namespace nvim__id_dictionary nvim_win_set_width diff_hlID tan py3eval confirm string jobstop gettabinfo get nvim_win_set_option win_screenpos and complete_check nvim_create_namespace wincol win_id2tabwin trim readdir strwidth toupper win_id2win nvim_win_get_config nvim_get_commands win_gotoid setpos fnameescape buffer_name browsedir nvim_win_get_tabpage bufexists getfsize nvim_get_option mkdir histget wildmenumode nvim_win_get_cursor complete_info stridx matchaddpos soundfold nvim_list_bufs
   12              0.000584 syn keyword vimFuncName contained  input match complete_add getbufvar nvim_create_buf nvim_tabpage_set_var line nvim_del_var browse nvim_load_context nvim_buf_is_valid nvim_buf_get_offset setmatches winwidth nvim_buf_get_mark getfperm nvim_buf_get_var buflisted count clearmatches matchdelete argc cindent assert_notmatch filter nvim_get_hl_id_by_name visualmode nvim_buf_set_keymap reltimestr executable getmatches getcharmod findfile call nvim_get_keymap nvim_list_chans strlen taglist nvim_buf_delete ctxpop nvim_del_current_line reg_executing getbufline nvim_select_popupmenu_item histadd getreg repeat chanclose nvim_buf_get_number jobresize nvim_exec api_info stdioopen filewritable complete gettagstack nvim_win_get_var nvim_set_current_buf byte2line nvim_buf_attach nvim_get_mode searchpos nvim_set_vvar swapname islocked nvim_win_get_buf foldtextresult
   12              0.000309 syn keyword vimFuncName contained  id screenattr nvim_buf_del_keymap cscope_connection len setenv bufwinid setbufvar rpcrequest winrestcmd nvim_get_var floor getpos settabvar nvim_buf_get_extmark_by_id sin msgpackdump nvim_tabpage_del_var termopen nvim_parse_expression nvim_get_vvar bufwinnr getpid getcurpos nvim_buf_get_lines win_getid nvim_get_chan_info nvim_buf_set_name histdel

SCRIPT  /Users/robertyang/Repos/Configs/Neovim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/async.vim
Sourced 1 time
Total time:   0.000187
 Self time:   0.000187

count  total (s)   self (s)
    1              0.000042 let s:available = has('nvim') || (
                                  \   has('job') && (
                                  \     (has('patch-7-4-1826') && !has('gui_running')) ||
                                  \     (has('patch-7-4-1850') &&  has('gui_running')) ||
                                  \     (has('patch-7-4-1832') &&  has('gui_macvim'))
                                  \   )
                                  \ )
                            
    1              0.000004 let s:jobs = {}
                            
    1              0.000004 function! gitgutter#async#available()
                              return s:available
                            endfunction
                            
                            
    1              0.000003 function! gitgutter#async#execute(cmd, bufnr, handler) abort
                              call gitgutter#debug#log('[async] '.a:cmd)
                            
                              let options = {
                                    \   'stdoutbuffer': [],
                                    \   'buffer': a:bufnr,
                                    \   'handler': a:handler
                                    \ }
                              let command = s:build_command(a:cmd)
                            
                              if has('nvim')
                                call jobstart(command, extend(options, {
                                      \   'on_stdout': function('s:on_stdout_nvim'),
                                      \   'on_stderr': function('s:on_stderr_nvim'),
                                      \   'on_exit':   function('s:on_exit_nvim')
                                      \ }))
                              else
                                let job = job_start(command, {
                                      \   'out_cb':   function('s:on_stdout_vim', options),
                                      \   'err_cb':   function('s:on_stderr_vim', options),
                                      \   'close_cb': function('s:on_exit_vim', options)
                                      \ })
                                let s:jobs[s:job_id(job)] = 1
                              endif
                            endfunction
                            
                            
    1              0.000004 function! s:build_command(cmd)
                              if has('unix')
                                return ['sh', '-c', a:cmd]
                              endif
                            
                              if has('win32')
                                return has('nvim') ? ['cmd.exe', '/c', a:cmd] : 'cmd.exe /c '.a:cmd
                              endif
                            
                              throw 'unknown os'
                            endfunction
                            
                            
    1              0.000003 function! s:on_stdout_nvim(_job_id, data, _event) dict abort
                              if empty(self.stdoutbuffer)
                                let self.stdoutbuffer = a:data
                              else
                                let self.stdoutbuffer = self.stdoutbuffer[:-2] +
                                      \ [self.stdoutbuffer[-1] . a:data[0]] +
                                      \ a:data[1:]
                              endif
                            endfunction
                            
    1              0.000002 function! s:on_stderr_nvim(_job_id, data, _event) dict abort
                              if a:data != ['']  " With Neovim there is always [''] reported on stderr.
                                call self.handler.err(self.buffer)
                              endif
                            endfunction
                            
    1              0.000002 function! s:on_exit_nvim(_job_id, exit_code, _event) dict abort
                              if !a:exit_code
                                call self.handler.out(self.buffer, join(self.stdoutbuffer, "\n"))
                              endif
                            endfunction
                            
                            
    1              0.000002 function! s:on_stdout_vim(_channel, data) dict abort
                              call add(self.stdoutbuffer, a:data)
                            endfunction
                            
    1              0.000002 function! s:on_stderr_vim(channel, _data) dict abort
                              call self.handler.err(self.buffer)
                            endfunction
                            
    1              0.000002 function! s:on_exit_vim(channel) dict abort
                              let job = ch_getjob(a:channel)
                              let jobid = s:job_id(job)
                              if has_key(s:jobs, jobid) | unlet s:jobs[jobid] | endif
                              while 1
                                if job_status(job) == 'dead'
                                  let exit_code = job_info(job).exitval
                                  break
                                endif
                                sleep 5m
                              endwhile
                            
                              if !exit_code
                                call self.handler.out(self.buffer, join(self.stdoutbuffer, "\n"))
                              endif
                            endfunction
                            
    1              0.000002 function! s:job_id(job)
                              " Vim
                              return job_info(a:job).process
                            endfunction

SCRIPT  /Users/robertyang/Repos/Configs/Neovim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/debug.vim
Sourced 1 time
Total time:   0.000280
 Self time:   0.000280

count  total (s)   self (s)
    1              0.000061 let s:plugin_dir  = expand('<sfile>:p:h:h:h').'/'
    1              0.000009 let s:log_file    = s:plugin_dir.'gitgutter.log'
    1              0.000006 let s:channel_log = s:plugin_dir.'channel.log'
    1              0.000004 let s:new_log_session = 1
                            
                            
    1              0.000006 function! gitgutter#debug#debug()
                              " Open a scratch buffer
                              vsplit __GitGutter_Debug__
                              normal! ggdG
                              setlocal buftype=nofile
                              setlocal bufhidden=delete
                              setlocal noswapfile
                            
                              call s:vim_version()
                              call s:separator()
                            
                              call s:git_version()
                              call s:separator()
                            
                              call s:grep_version()
                              call s:separator()
                            
                              call s:option('updatetime')
                            endfunction
                            
                            
    1              0.000005 function! s:separator()
                              call s:output('')
                            endfunction
                            
    1              0.000003 function! s:vim_version()
                              redir => version_info
                                silent execute 'version'
                              redir END
                              call s:output(split(version_info, '\n')[0:2])
                            endfunction
                            
    1              0.000003 function! s:git_version()
                              let v = system(g:gitgutter_git_executable.' --version')
                              call s:output( substitute(v, '\n$', '', '') )
                            endfunction
                            
    1              0.000003 function! s:grep_version()
                              let v = system(g:gitgutter_grep.' --version')
                              call s:output( substitute(v, '\n$', '', '') )
                            
                              let v = system(g:gitgutter_grep.' --help')
                              call s:output( substitute(v, '\%x00', '', 'g') )
                            endfunction
                            
    1              0.000003 function! s:option(name)
                              if exists('+' . a:name)
                                let v = eval('&' . a:name)
                                call s:output(a:name . '=' . v)
                                " redir => output
                                "   silent execute "verbose set " . a:name . "?"
                                " redir END
                                " call s:output(a:name . '=' . output)
                              else
                                call s:output(a:name . ' [n/a]')
                              end
                            endfunction
                            
    1              0.000003 function! s:output(text)
                              call append(line('$'), a:text)
                            endfunction
                            
                            " assumes optional args are calling function's optional args
    1              0.000004 function! gitgutter#debug#log(message, ...) abort
                              if g:gitgutter_log
                                if s:new_log_session && gitgutter#async#available()
                                  if exists('*ch_logfile')
                                    call ch_logfile(s:channel_log, 'w')
                                  endif
                                endif
                            
                                execute 'redir >> '.s:log_file
                                  if s:new_log_session
                                    let s:start = reltime()
                                    silent echo "\n==== start log session ===="
                                  endif
                            
                                  let elapsed = reltimestr(reltime(s:start)).' '
                                  silent echo ''
                                  " callers excluding this function
                                  silent echo elapsed.expand('<sfile>')[:-22].':'
                                  silent echo elapsed.s:format_for_log(a:message)
                                  if a:0 && !empty(a:1)
                                    for msg in a:000
                                      silent echo elapsed.s:format_for_log(msg)
                                    endfor
                                  endif
                                redir END
                            
                                let s:new_log_session = 0
                              endif
                            endfunction
                            
    1              0.000003 function! s:format_for_log(data) abort
                              if type(a:data) == 1
                                return join(split(a:data,'\n'),"\n")
                              elseif type(a:data) == 3
                                return '['.join(a:data,"\n").']'
                              else
                                return a:data
                              endif
                            endfunction
                            

SCRIPT  /Users/robertyang/Repos/Configs/Neovim/.config/coc/extensions/node_modules/coc-fzf-preview/autoload/fzf_preview/remote/mr.vim
Sourced 1 time
Total time:   0.000084
 Self time:   0.000084

count  total (s)   self (s)
    1              0.000014 function! fzf_preview#remote#mr#append(path, cache_path) abort
                              let files = s:get_files_with_create_directory(a:cache_path)
                            
                              call insert(files, a:path)
                              call writefile(fzf_preview#remote#util#uniq(files)[:g:fzf_preview_mru_limit - 1], a:cache_path)
                            endfunction
                            
    1              0.000004 function! fzf_preview#remote#mr#mru_file_path() abort
                              return g:fzf_preview_cache_directory . '/mru'
                            endfunction
                            
    1              0.000003 function! fzf_preview#remote#mr#mrw_file_path() abort
                              return g:fzf_preview_cache_directory . '/mrw'
                            endfunction
                            
    1              0.000004 function! s:get_files_with_create_directory(cache_path) abort
                              if !isdirectory(g:fzf_preview_cache_directory)
                                call mkdir(g:fzf_preview_cache_directory, 'p')
                              endif
                            
                              try
                                let files = readfile(a:cache_path)
                              catch
                                let files = []
                              endtry
                            
                              return files
                            endfunction

SCRIPT  /Users/robertyang/Repos/Configs/Neovim/.config/nvim/plugged/vim-fugitive/autoload/fugitive.vim
Sourced 1 time
Total time:   0.023498
 Self time:   0.022084

count  total (s)   self (s)
                            " Location:     autoload/fugitive.vim
                            " Maintainer:   Tim Pope <http://tpo.pe/>
                            
    1              0.000027 if exists('g:autoloaded_fugitive')
                              finish
    1              0.000003 endif
    1              0.000025 let g:autoloaded_fugitive = 1
                            
    1              0.000011 if !exists('g:fugitive_git_executable')
    1              0.000010   let g:fugitive_git_executable = 'git'
                            elseif g:fugitive_git_executable =~# '^\w\+='
                              let g:fugitive_git_executable = 'env ' . g:fugitive_git_executable
    1              0.000002 endif
                            
                            " Section: Utility
                            
    1              0.000011 function! s:function(name) abort
                              return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '.*\zs<SNR>\d\+_'),''))
                            endfunction
                            
    1              0.000006 function! s:sub(str,pat,rep) abort
                              return substitute(a:str,'\v\C'.a:pat,a:rep,'')
                            endfunction
                            
    1              0.000005 function! s:gsub(str,pat,rep) abort
                              return substitute(a:str,'\v\C'.a:pat,a:rep,'g')
                            endfunction
                            
    1              0.000004 function! s:Uniq(list) abort
                              let i = 0
                              let seen = {}
                              while i < len(a:list)
                                let str = string(a:list[i])
                                if has_key(seen, str)
                                  call remove(a:list, i)
                                else
                                  let seen[str] = 1
                                  let i += 1
                                endif
                              endwhile
                              return a:list
                            endfunction
                            
    1              0.000004 function! s:winshell() abort
                              return has('win32') && &shellcmdflag !~# '^-'
                            endfunction
                            
    1              0.000005 function! s:WinShellEsc(arg) abort
                              if type(a:arg) == type([])
                                return join(map(copy(a:arg), 's:shellesc(v:val)'))
                              elseif a:arg =~# '^[A-Za-z0-9_/:.-]\+$'
                                return a:arg
                              else
                                return '"' . s:gsub(s:gsub(a:arg, '"', '""'), '\%', '"%"') . '"'
                              endif
                            endfunction
                            
    1              0.000004 function! s:shellesc(arg) abort
                              if type(a:arg) == type([])
                                return join(map(copy(a:arg), 's:shellesc(v:val)'))
                              elseif a:arg =~# '^[A-Za-z0-9_/:.-]\+$'
                                return a:arg
                              elseif s:winshell()
                                return '"' . s:gsub(s:gsub(a:arg, '"', '""'), '\%', '"%"') . '"'
                              else
                                return shellescape(a:arg)
                              endif
                            endfunction
                            
    1              0.000008 let s:fnameescape = " \t\n*?[{`$\\%#'\"|!<"
    1              0.000005 function! s:fnameescape(file) abort
                              if type(a:file) == type([])
                                return join(map(copy(a:file), 's:fnameescape(v:val)'))
                              elseif exists('*fnameescape')
                                return fnameescape(a:file)
                              else
                                return escape(a:file, s:fnameescape)
                              endif
                            endfunction
                            
    1              0.000004 function! s:throw(string) abort
                              throw 'fugitive: '.a:string
                            endfunction
                            
    1              0.000004 function! s:DirCheck(...) abort
                              if !empty(a:0 ? s:Dir(a:1) : s:Dir())
                                return ''
                              elseif empty(bufname(''))
                                return 'return ' . string('echoerr "fugitive: working directory does not belong to a Git repository"')
                              else
                                return 'return ' . string('echoerr "fugitive: file does not belong to a Git repository"')
                              endif
                            endfunction
                            
    1              0.000004 function! s:Mods(mods, ...) abort
                              let mods = substitute(a:mods, '\C<mods>', '', '')
                              let mods = mods =~# '\S$' ? mods . ' ' : mods
                              if a:0 && mods !~# '\<\%(aboveleft\|belowright\|leftabove\|rightbelow\|topleft\|botright\|tab\)\>'
                                let mods = a:1 . ' ' . mods
                              endif
                              return substitute(mods, '\s\+', ' ', 'g')
                            endfunction
                            
    1              0.000004 function! s:Slash(path) abort
                              if exists('+shellslash')
                                return tr(a:path, '\', '/')
                              else
                                return a:path
                              endif
                            endfunction
                            
    1              0.000004 function! s:Resolve(path) abort
                              let path = resolve(a:path)
                              if has('win32')
                                let path = FugitiveVimPath(fnamemodify(fnamemodify(path, ':h'), ':p') . fnamemodify(path, ':t'))
                              endif
                              return path
                            endfunction
                            
    1              0.000005 function! s:FileIgnoreCase(for_completion) abort
                              return (exists('+fileignorecase') && &fileignorecase)
                                    \ || (a:for_completion && exists('+wildignorecase') && &wildignorecase)
                            endfunction
                            
    1              0.000004 function! s:cpath(path, ...) abort
                              if s:FileIgnoreCase(0)
                                let path = FugitiveVimPath(tolower(a:path))
                              else
                                let path = FugitiveVimPath(a:path)
                              endif
                              return a:0 ? path ==# s:cpath(a:1) : path
                            endfunction
                            
    1              0.000011 let s:executables = {}
                            
    1              0.000005 function! s:executable(binary) abort
                              if !has_key(s:executables, a:binary)
                                let s:executables[a:binary] = executable(a:binary)
                              endif
                              return s:executables[a:binary]
                            endfunction
                            
    1              0.000009 if !exists('s:temp_scripts')
    1              0.000006   let s:temp_scripts = {}
    1              0.000002 endif
    1              0.000004 function! s:TempScript(...) abort
                              let body = join(a:000, "\n")
                              if !has_key(s:temp_scripts, body)
                                let s:temp_scripts[body] = tempname() . '.sh'
                              endif
                              let temp = s:temp_scripts[body]
                              if !filereadable(temp)
                                call writefile(['#!/bin/sh'] + a:000, temp)
                              endif
                              return FugitiveGitPath(temp)
                            endfunction
                            
    1              0.000005 function! s:DoAutocmd(cmd) abort
                              if v:version >= 704 || (v:version == 703 && has('patch442'))
                                return 'doautocmd <nomodeline>' . a:cmd
                              elseif &modelines > 0
                                return 'try|set modelines=0|doautocmd ' . a:cmd . '|finally|set modelines=' . &modelines . '|endtry'
                              else
                                return 'doautocmd ' . a:cmd
                              endif
                            endfunction
                            
    1              0.000011 let s:nowait = v:version >= 704 ? '<nowait>' : ''
                            
    1              0.000006 function! s:Map(mode, lhs, rhs, ...) abort
                              for mode in split(a:mode, '\zs')
                                let flags = (a:0 ? a:1 : '') . (a:rhs =~# '<Plug>' ? '' : '<script>')
                                let head = a:lhs
                                let tail = ''
                                let keys = get(g:, mode.'remap', {})
                                if type(keys) == type([])
                                  return
                                endif
                                while !empty(head)
                                  if has_key(keys, head)
                                    let head = keys[head]
                                    if empty(head)
                                      return
                                    endif
                                    break
                                  endif
                                  let tail = matchstr(head, '<[^<>]*>$\|.$') . tail
                                  let head = substitute(head, '<[^<>]*>$\|.$', '', '')
                                endwhile
                                if flags !~# '<unique>' || empty(mapcheck(head.tail, mode))
                                  exe mode.'map <buffer>' s:nowait flags head.tail a:rhs
                                  if a:0 > 1
                                    let b:undo_ftplugin = get(b:, 'undo_ftplugin', 'exe') .
                                          \ '|sil! exe "' . mode . 'unmap <buffer> ' . head.tail . '"'
                                  endif
                                endif
                              endfor
                            endfunction
                            
                            " Section: Git
                            
    1              0.000005 function! s:UserCommandList(...) abort
                              let git = split(get(g:, 'fugitive_git_command', g:fugitive_git_executable), '\s\+')
                              let flags = []
                              if a:0 && type(a:1) == type({})
                                let git = copy(get(a:1, 'git', git))
                                let flags = get(a:1, 'flags', flags)
                                let dir = a:1.dir
                              elseif a:0
                                let dir = a:1
                              else
                                let dir = ''
                              endif
                              if len(dir)
                                let tree = s:Tree(dir)
                                if empty(tree)
                                  call add(git, '--git-dir=' . FugitiveGitPath(dir))
                                elseif len(tree) && s:cpath(tree) !=# s:cpath(getcwd())
                                  if fugitive#GitVersion(1, 8, 5)
                                    call extend(git, ['-C', FugitiveGitPath(tree)])
                                  else
                                    throw 'fugitive: Git 1.8.5 or higher required to change directory'
                                  endif
                                endif
                              endif
                              return git + flags
                            endfunction
                            
    1              0.000004 function! s:UserCommand(...) abort
                              return s:shellesc(call('s:UserCommandList', a:0 ? [a:1] : []) + (a:0 ? a:2 : []))
                            endfunction
                            
    1              0.000006 let s:git_versions = {}
    1              0.000004 function! fugitive#GitVersion(...) abort
                              if !has_key(s:git_versions, g:fugitive_git_executable)
                                let s:git_versions[g:fugitive_git_executable] = matchstr(system(g:fugitive_git_executable.' --version'), '\d[^[:space:]]\+')
                              endif
                              if !a:0
                                return s:git_versions[g:fugitive_git_executable]
                              endif
                              let components = split(s:git_versions[g:fugitive_git_executable], '\D\+')
                              if empty(components)
                                return -1
                              endif
                              for i in range(len(a:000))
                                if a:000[i] > +get(components, i)
                                  return 0
                                elseif a:000[i] < +get(components, i)
                                  return 1
                                endif
                              endfor
                              return a:000[i] ==# get(components, i)
                            endfunction
                            
    1              0.000005 let s:commondirs = {}
    1              0.000005 function! fugitive#CommonDir(dir) abort
                              if empty(a:dir)
                                return ''
                              endif
                              if !has_key(s:commondirs, a:dir)
                                if getfsize(a:dir . '/HEAD') < 10
                                  let s:commondirs[a:dir] = ''
                                elseif filereadable(a:dir . '/commondir')
                                  let cdir = get(readfile(a:dir . '/commondir', 1), 0, '')
                                  if cdir =~# '^/\|^\a:/'
                                    let s:commondirs[a:dir] = s:Slash(FugitiveVimPath(cdir))
                                  else
                                    let s:commondirs[a:dir] = simplify(a:dir . '/' . cdir)
                                  endif
                                else
                                  let s:commondirs[a:dir] = a:dir
                                endif
                              endif
                              return s:commondirs[a:dir]
                            endfunction
                            
    1              0.000009 function! s:Dir(...) abort
                              return a:0 ? FugitiveGitDir(a:1) : FugitiveGitDir()
                            endfunction
                            
    1              0.000007 function! s:Tree(...) abort
                              return a:0 ? FugitiveWorkTree(a:1) : FugitiveWorkTree()
                            endfunction
                            
    1              0.000005 function! s:HasOpt(args, ...) abort
                              let args = a:args[0 : index(a:args, '--')]
                              let opts = copy(a:000)
                              if type(opts[0]) == type([])
                                if empty(args) || index(opts[0], args[0]) == -1
                                  return 0
                                endif
                                call remove(opts, 0)
                              endif
                              for opt in opts
                                if index(args, opt) != -1
                                  return 1
                                endif
                              endfor
                            endfunction
                            
    1              0.000007 function! s:PreparePathArgs(cmd, dir, literal) abort
                              let literal_supported = fugitive#GitVersion(1, 9)
                              if a:literal && literal_supported
                                call insert(a:cmd, '--literal-pathspecs')
                              endif
                              let split = index(a:cmd, '--')
                              for i in range(split < 0 ? len(a:cmd) : split)
                                if type(a:cmd[i]) == type(0)
                                  let a:cmd[i] = fugitive#Path(bufname(a:cmd[i]), './', a:dir)
                                endif
                              endfor
                              if split < 0
                                return a:cmd
                              endif
                              for i in range(split + 1, len(a:cmd) - 1)
                                if type(a:cmd[i]) == type(0)
                                  let a:cmd[i] = fugitive#Path(bufname(a:cmd[i]), './', a:dir)
                                elseif a:literal
                                  let a:cmd[i] = fugitive#Path(a:cmd[i], './', a:dir)
                                elseif !literal_supported
                                  let a:cmd[i] = substitute(a:cmd[i], '^:\%(/\|([^)]*)\)\=:\=', './', '')
                                endif
                              endfor
                              return a:cmd
                            endfunction
                            
    1              0.000026 let s:prepare_env = {
                                  \ 'sequence.editor': 'GIT_SEQUENCE_EDITOR',
                                  \ 'core.editor': 'GIT_EDITOR',
                                  \ 'core.askpass': 'GIT_ASKPASS',
                                  \ }
    1              0.000006 function! fugitive#PrepareDirEnvArgv(...) abort
                              if a:0 && type(a:1) ==# type([])
                                let cmd = a:000[1:-1] + a:1
                              else
                                let cmd = copy(a:000)
                              endif
                              let env = {}
                              let i = 0
                              while i < len(cmd)
                                if cmd[i] =~# '^$\|[\/.]' && cmd[i] !~# '^-'
                                  let dir = remove(cmd, i)
                                elseif cmd[i] =~# '^--git-dir='
                                  let dir = remove(cmd, i)[10:-1]
                                elseif type(cmd[i]) ==# type(0)
                                  let dir = s:Dir(remove(cmd, i))
                                elseif cmd[i] ==# '-c' && len(cmd) > i + 1
                                  let key = matchstr(cmd[i+1], '^[^=]*')
                                  if has_key(s:prepare_env, tolower(key)) || key !~# '\.'
                                    let var = get(s:prepare_env, tolower(key), key)
                                    let val = matchstr(cmd[i+1], '=\zs.*')
                                    let env[var] = val
                                  endif
                                  if fugitive#GitVersion(1, 8) && cmd[i+1] =~# '\.'
                                    let i += 2
                                  else
                                    call remove(cmd, i, i + 1)
                                  endif
                                elseif cmd[i] =~# '^--.*pathspecs$'
                                  let explicit_pathspec_option = 1
                                  if fugitive#GitVersion(1, 9)
                                    let i += 1
                                  else
                                    call remove(cmd, i)
                                  endif
                                elseif cmd[i] !~# '^-'
                                  break
                                else
                                  let i += 1
                                endif
                              endwhile
                              if !exists('dir')
                                let dir = s:Dir()
                              endif
                              call s:PreparePathArgs(cmd, dir, !exists('explicit_pathspec_option'))
                              return [dir, env, cmd]
                            endfunction
                            
    1              0.000005 function! s:BuildEnvPrefix(env) abort
                              let pre = ''
                              let env = items(a:env)
                              if empty(env)
                                return ''
                              elseif &shellcmdflag =~# '-Command'
                                return join(map(env, '"$Env:" . v:val[0] . " = ''" . substitute(v:val[1], "''", "''''", "g") . "''; "'), '')
                              elseif s:winshell()
                                return join(map(env, '"set " . substitute(join(v:val, "="), "[&|<>^]", "^^^&", "g") . "& "'), '')
                              else
                                return 'env ' . s:shellesc(map(env, 'join(v:val, "=")')) . ' '
                              endif
                            endfunction
                            
    1              0.000005 function! s:JobOpts(cmd, env) abort
                              if empty(a:env)
                                return [a:cmd, {}]
                              elseif has('patch-8.2.0239') || has('patch-8.1.0902') && !has('nvim') && (!has('win32') || empty(filter(keys(a:env), 'exists("$" . v:val)')))
                                return [a:cmd, {'env': a:env}]
                              endif
                              let envlist = map(items(a:env), 'join(v:val, "=")')
                              if !has('win32')
                                return [['env'] + envlist + a:cmd, {}]
                              else
                                let pre = join(map(envlist, '"set " . substitute(v:val, "[&|<>^]", "^^^&", "g") . "& "'), '')
                                if len(a:cmd) == 3 && a:cmd[0] ==# 'cmd.exe' && a:cmd[1] ==# '/c'
                                  return [a:cmd[0:1] + [pre . a:cmd[2]], {}]
                                else
                                  return [['cmd.exe', '/c', pre . s:WinShellEsc(a:cmd)], {}]
                                endif
                              endif
                            endfunction
                            
    1              0.000006 function! s:BuildShell(dir, env, args) abort
                              let cmd = copy(a:args)
                              let tree = s:Tree(a:dir)
                              let pre = s:BuildEnvPrefix(a:env)
                              if empty(tree) || index(cmd, '--') == len(cmd) - 1
                                call insert(cmd, '--git-dir=' . FugitiveGitPath(a:dir))
                              elseif fugitive#GitVersion(1, 8, 5)
                                call extend(cmd, ['-C', FugitiveGitPath(tree)], 'keep')
                              else
                                let pre = 'cd ' . s:shellesc(tree) . (s:winshell() ? '& ' : '; ') . pre
                              endif
                              return pre . g:fugitive_git_executable . ' ' . join(map(cmd, 's:shellesc(v:val)'))
                            endfunction
                            
    1              0.000004 function! fugitive#Prepare(...) abort
                              let [dir, env, argv] = call('fugitive#PrepareDirEnvArgv', a:000)
                              return s:BuildShell(dir, env, argv)
                            endfunction
                            
    1              0.000005 function! s:SystemError(cmd, ...) abort
                              try
                                if &shellredir ==# '>' && &shell =~# 'sh\|cmd'
                                  let shellredir = &shellredir
                                  if &shell =~# 'csh'
                                    set shellredir=>&
                                  else
                                    set shellredir=>%s\ 2>&1
                                  endif
                                endif
                                let out = call('system', [type(a:cmd) ==# type([]) ? fugitive#Prepare(a:cmd) : a:cmd] + a:000)
                                return [out, v:shell_error]
                              catch /^Vim\%((\a\+)\)\=:E484:/
                                let opts = ['shell', 'shellcmdflag', 'shellredir', 'shellquote', 'shellxquote', 'shellxescape', 'shellslash']
                                call filter(opts, 'exists("+".v:val) && !empty(eval("&".v:val))')
                                call map(opts, 'v:val."=".eval("&".v:val)')
                                call s:throw('failed to run `' . a:cmd . '` with ' . join(opts, ' '))
                              finally
                                if exists('shellredir')
                                  let &shellredir = shellredir
                                endif
                              endtry
                            endfunction
                            
    1              0.000005 function! s:ChompError(...) abort
                              let [out, exec_error] = s:SystemError(call('fugitive#Prepare', a:000))
                              return [s:sub(out, '\n$', ''), exec_error]
                            endfunction
                            
    1              0.000005 function! s:ChompDefault(default, ...) abort
                              let [out, exec_error] = call('s:ChompError', a:000)
                              return exec_error ? a:default : out
                            endfunction
                            
    1              0.000004 function! s:LinesError(...) abort
                              let [out, exec_error] = call('s:ChompError', a:000)
                              return [len(out) && !exec_error ? split(out, "\n", 1) : [], exec_error]
                            endfunction
                            
    1              0.000004 function! s:NullError(...) abort
                              let [out, exec_error] = s:SystemError(call('fugitive#Prepare', a:000))
                              return [exec_error ? [] : split(out, "\1"), exec_error ? substitute(out, "\n$", "", "") : '', exec_error]
                            endfunction
                            
    1              0.000004 function! s:TreeChomp(...) abort
                              let cmd = call('fugitive#Prepare', a:000)
                              let [out, exec_error] = s:SystemError(cmd)
                              let out = s:sub(out, '\n$', '')
                              if !exec_error
                                return out
                              endif
                              throw 'fugitive: error running `' . cmd . '`: ' . out
                            endfunction
                            
    1              0.000004 function! s:EchoExec(...) abort
                              if s:RunJobs()
                                return 'Git ' . s:fnameescape(a:000)
                              else
                                echo call('s:ChompError', a:000)[0]
                                call fugitive#ReloadStatus(-1, 1)
                                return 'checktime'
                              endif
                            endfunction
                            
    1              0.000006 let s:head_cache = {}
                            
    1              0.000004 function! fugitive#Head(...) abort
                              let dir = a:0 > 1 ? a:2 : s:Dir()
                              if empty(dir)
                                return ''
                              endif
                              let file = fugitive#Find('.git/HEAD', dir)
                              let ftime = getftime(file)
                              if ftime == -1
                                return ''
                              elseif ftime != get(s:head_cache, dir, [-1])[0]
                                let s:head_cache[dir] = [ftime, readfile(file)[0]]
                              endif
                              let head = s:head_cache[dir][1]
                              if head =~# '^ref: '
                                return substitute(head, '\C^ref: \%(refs/\%(heads/\|remotes/\|tags/\)\=\)\=', '', '')
                              elseif head =~# '^\x\{40,\}$'
                                let len = a:0 ? a:1 : 0
                                return len < 0 ? head : len ? head[0:len-1] : ''
                              else
                                return ''
                              endif
                            endfunction
                            
    1              0.000005 function! fugitive#RevParse(rev, ...) abort
                              let [hash, exec_error] = s:ChompError([a:0 ? a:1 : s:Dir(), 'rev-parse', '--verify', a:rev, '--'])
                              if !exec_error && hash =~# '^\x\{40,\}$'
                                return hash
                              endif
                              throw 'fugitive: rev-parse '.a:rev.': '.hash
                            endfunction
                            
    1              0.000005 function! s:ConfigTimestamps(dir, dict) abort
                              let files = ['/etc/gitconfig', '~/.gitconfig',
                                    \ len($XDG_CONFIG_HOME) ? $XDG_CONFIG_HOME . '/git/config' : '~/.config/git/config']
                              if len(a:dir)
                                call add(files, fugitive#Find('.git/config', a:dir))
                              endif
                              call extend(files, get(a:dict, 'include.path', []))
                              return join(map(files, 'getftime(expand(v:val))'), ',')
                            endfunction
                            
    1              0.000005 let s:config = {}
    1              0.000004 function! fugitive#Config(...) abort
                              let dir = s:Dir()
                              let name = ''
                              if a:0 >= 2 && type(a:2) == type({})
                                let name = substitute(a:1, '^[^.]\+\|[^.]\+$', '\L&', 'g')
                                return len(a:1) ? get(get(a:2, name, []), 0, '') : a:2
                              elseif a:0 >= 2
                                let dir = a:2
                                let name = a:1
                              elseif a:0 == 1 && type(a:1) == type({})
                                return a:1
                              elseif a:0 == 1 && a:1 =~# '^[[:alnum:]-]\+\.'
                                let name = a:1
                              elseif a:0 == 1
                                let dir = a:1
                              endif
                              let name = substitute(name, '^[^.]\+\|[^.]\+$', '\L&', 'g')
                              let dir_key = len(dir) ? dir : '_'
                              if has_key(s:config, dir_key) && s:config[dir_key][0] ==# s:ConfigTimestamps(dir, s:config[dir_key][1])
                                let dict = s:config[dir_key][1]
                              else
                                let dict = {}
                                let [lines, message, exec_error] = s:NullError([dir, 'config', '--list', '-z'])
                                if exec_error
                                  return {}
                                endif
                                for line in lines
                                  let key = matchstr(line, "^[^\n]*")
                                  if !has_key(dict, key)
                                    let dict[key] = []
                                  endif
                                  if len(key) ==# len(line)
                                    call add(dict[key], 1)
                                  else
                                    call add(dict[key], strpart(line, len(key) + 1))
                                  endif
                                endfor
                                let s:config[dir_key] = [s:ConfigTimestamps(dir, dict), dict]
                                lockvar! dict
                              endif
                              return len(name) ? get(get(dict, name, []), 0, '') : dict
                            endfunction
                            
    1              0.000005 function! s:Remote(dir) abort
                              let head = FugitiveHead(0, a:dir)
                              let remote = len(head) ? fugitive#Config('branch.' . head . '.remote') : ''
                              let i = 10
                              while remote ==# '.' && i > 0
                                let head = matchstr(fugitive#Config('branch.' . head . '.merge'), 'refs/heads/\zs.*')
                                let remote = len(head) ? fugitive#Config('branch.' . head . '.remote') : ''
                                let i -= 1
                              endwhile
                              return remote =~# '^\.\=$' ? 'origin' : remote
                            endfunction
                            
    1              0.000004 function! fugitive#RemoteUrl(...) abort
                              let dir = a:0 > 1 ? a:2 : s:Dir()
                              let remote = !a:0 || a:1 =~# '^\.\=$' ? s:Remote(dir) : a:1
                              if !fugitive#GitVersion(2, 7)
                                return fugitive#Config('remote.' . remote . '.url')
                              endif
                              return s:ChompDefault('', [dir, 'remote', 'get-url', remote, '--'])
                            endfunction
                            
                            " Section: Quickfix
                            
    1              0.000004 function! s:QuickfixGet(nr, ...) abort
                              if a:nr < 0
                                return call('getqflist', a:000)
                              else
                                return call('getloclist', [a:nr] + a:000)
                              endif
                            endfunction
                            
    1              0.000004 function! s:QuickfixSet(nr, ...) abort
                              if a:nr < 0
                                return call('setqflist', a:000)
                              else
                                return call('setloclist', [a:nr] + a:000)
                              endif
                            endfunction
                            
    1              0.000005 function! s:QuickfixCreate(nr, opts) abort
                              if has('patch-7.4.2200')
                                call s:QuickfixSet(a:nr, [], ' ', a:opts)
                              else
                                call s:QuickfixSet(a:nr, [], ' ')
                              endif
                            endfunction
                            
    1              0.000008 function! s:QuickfixStream(nr, event, title, cmd, first, callback, ...) abort
                              let opts = {'title': a:title, 'context': {'items': []}}
                              call s:QuickfixCreate(a:nr, opts)
                              let event = (a:nr < 0 ? 'c' : 'l') . 'fugitive-' . a:event
                              silent exe s:DoAutocmd('QuickFixCmdPre ' . event)
                              let winnr = winnr()
                              exe a:nr < 0 ? 'copen' : 'lopen'
                              if winnr != winnr()
                                wincmd p
                              endif
                            
                              let buffer = []
                              let lines = split(s:SystemError(s:shellesc(a:cmd))[0], "\n")
                              for line in lines
                                call extend(buffer, call(a:callback, a:000 + [line]))
                                if len(buffer) >= 20
                                  let contexts = map(copy(buffer), 'get(v:val, "context", {})')
                                  lockvar contexts
                                  call extend(opts.context.items, contexts)
                                  unlet contexts
                                  call s:QuickfixSet(a:nr, remove(buffer, 0, -1), 'a')
                                  redraw
                                endif
                              endfor
                              call extend(buffer, call(a:callback, a:000 + [0]))
                              call extend(opts.context.items, map(copy(buffer), 'get(v:val, "context", {})'))
                              lockvar opts.context.items
                              call s:QuickfixSet(a:nr, buffer, 'a')
                            
                              silent exe s:DoAutocmd('QuickFixCmdPost ' . event)
                              if a:first && len(s:QuickfixGet(a:nr))
                                call s:BlurStatus()
                                return a:nr < 0 ? 'cfirst' : 'lfirst'
                              else
                                return 'exe'
                              endif
                            endfunction
                            
    1              0.000023 let s:common_efm = ''
                                  \ . '%+Egit:%.%#,'
                                  \ . '%+Eusage:%.%#,'
                                  \ . '%+Eerror:%.%#,'
                                  \ . '%+Efatal:%.%#,'
                                  \ . '%-G%.%#%\e[K%.%#,'
                                  \ . '%-G%.%#%\r%.%\+'
                            
    1              0.000004 function! fugitive#Cwindow() abort
                              if &buftype == 'quickfix'
                                cwindow
                              else
                                botright cwindow
                                if &buftype == 'quickfix'
                                  wincmd p
                                endif
                              endif
                            endfunction
                            
                            " Section: Repository Object
                            
    1              0.000006 function! s:add_methods(namespace, method_names) abort
                              for name in a:method_names
                                let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
                              endfor
                            endfunction
                            
    1              0.000006 let s:repo_prototype = {}
    1              0.000005 let s:repos = {}
                            
    1              0.000004 function! fugitive#repo(...) abort
                              let dir = a:0 ? s:Dir(a:1) : (len(s:Dir()) ? s:Dir() : FugitiveExtractGitDir(expand('%:p')))
                              if dir !=# ''
                                if has_key(s:repos, dir)
                                  let repo = get(s:repos, dir)
                                else
                                  let repo = {'git_dir': dir}
                                  let s:repos[dir] = repo
                                endif
                                return extend(repo, s:repo_prototype, 'keep')
                              endif
                              call s:throw('not a Git repository')
                            endfunction
                            
    1              0.000009 function! s:repo_dir(...) dict abort
                              return join([self.git_dir]+a:000,'/')
                            endfunction
                            
    1              0.000004 function! s:repo_tree(...) dict abort
                              let dir = s:Tree(self.git_dir)
                              if dir ==# ''
                                call s:throw('no work tree')
                              else
                                return join([dir]+a:000,'/')
                              endif
                            endfunction
                            
    1              0.000004 function! s:repo_bare() dict abort
                              if self.dir() =~# '/\.git$'
                                return 0
                              else
                                return s:Tree(self.git_dir) ==# ''
                              endif
                            endfunction
                            
    1              0.000004 function! s:repo_find(object) dict abort
                              return fugitive#Find(a:object, self.git_dir)
                            endfunction
                            
    1              0.000005 function! s:repo_translate(rev) dict abort
                              return s:Slash(fugitive#Find(substitute(a:rev, '^/', ':(top)', ''), self.git_dir))
                            endfunction
                            
    1              0.000004 function! s:repo_head(...) dict abort
                              return fugitive#Head(a:0 ? a:1 : 0, self.git_dir)
                            endfunction
                            
    1   0.000586   0.000036 call s:add_methods('repo',['dir','tree','bare','find','translate','head'])
                            
    1              0.000006 function! s:repo_prepare(...) dict abort
                              return call('fugitive#Prepare', [self.git_dir] + a:000)
                            endfunction
                            
    1              0.000005 function! s:repo_git_command(...) dict abort
                              let git = g:fugitive_git_executable . ' --git-dir='.s:shellesc(self.git_dir)
                              return git.join(map(copy(a:000),'" ".s:shellesc(v:val)'),'')
                            endfunction
                            
    1              0.000004 function! s:repo_git_chomp(...) dict abort
                              return s:sub(system(FugitivePrepare(a:000, self.git_dir)), '\n$', '')
                            endfunction
                            
    1              0.000005 function! s:repo_git_chomp_in_tree(...) dict abort
                              return call(self.git_chomp, a:000, self)
                            endfunction
                            
    1              0.000005 function! s:repo_rev_parse(rev) dict abort
                              return fugitive#RevParse(a:rev, self.git_dir)
                            endfunction
                            
    1   0.000428   0.000030 call s:add_methods('repo',['prepare','git_command','git_chomp','git_chomp_in_tree','rev_parse'])
                            
    1              0.000006 function! s:repo_superglob(base) dict abort
                              return map(fugitive#CompleteObject(a:base, self.git_dir), 'substitute(v:val, ''\\\(.\)'', ''\1'', "g")')
                            endfunction
                            
    1   0.000114   0.000017 call s:add_methods('repo',['superglob'])
                            
    1              0.000005 function! s:repo_config(name) dict abort
                              return fugitive#Config(a:name, self.git_dir)
                            endfunction
                            
    1              0.000004 function! s:repo_user() dict abort
                              let username = self.config('user.name')
                              let useremail = self.config('user.email')
                              return username.' <'.useremail.'>'
                            endfunction
                            
    1   0.000184   0.000018 call s:add_methods('repo',['config', 'user'])
                            
                            " Section: File API
                            
    1              0.000006 function! s:DirCommitFile(path) abort
                              let vals = matchlist(s:Slash(a:path), '\c^fugitive:\%(//\)\=\(.\{-\}\)\%(//\|::\)\(\x\{40,\}\|[0-3]\)\(/.*\)\=$')
                              if empty(vals)
                                return ['', '', '']
                              endif
                              return vals[1:3]
                            endfunction
                            
    1              0.000004 function! s:DirRev(url) abort
                              let [dir, commit, file] = s:DirCommitFile(a:url)
                              return [dir, (commit =~# '^.$' ? ':' : '') . commit . substitute(file, '^/', ':', '')]
                            endfunction
                            
    1              0.000012 let s:merge_heads = ['MERGE_HEAD', 'REBASE_HEAD', 'CHERRY_PICK_HEAD', 'REVERT_HEAD']
    1              0.000004 function! s:MergeHead(...) abort
                              let dir = fugitive#Find('.git/', a:0 ? a:1 : s:Dir())
                              for head in s:merge_heads
                                if filereadable(dir . head)
                                  return head
                                endif
                              endfor
                              return ''
                            endfunction
                            
    1              0.000005 function! s:Owner(path, ...) abort
                              let dir = a:0 ? a:1 : s:Dir()
                              if empty(dir)
                                return ''
                              endif
                              let actualdir = fugitive#Find('.git/', dir)
                              let [pdir, commit, file] = s:DirCommitFile(a:path)
                              if s:cpath(dir, pdir)
                                if commit =~# '^\x\{40,\}$'
                                  return commit
                                elseif commit ==# '2'
                                  return 'HEAD^{}'
                                elseif commit ==# '0'
                                  return ''
                                endif
                                let merge_head = s:MergeHead()
                                if empty(merge_head)
                                  return ''
                                endif
                                if commit ==# '3'
                                  return merge_head . '^{}'
                                elseif commit ==# '1'
                                  return s:TreeChomp('merge-base', 'HEAD', merge_head, '--')
                                endif
                              endif
                              let path = fnamemodify(a:path, ':p')
                              if s:cpath(actualdir, strpart(path, 0, len(actualdir))) && a:path =~# 'HEAD$'
                                return strpart(path, len(actualdir))
                              endif
                              let refs = fugitive#Find('.git/refs', dir)
                              if s:cpath(refs . '/', path[0 : len(refs)]) && path !~# '[\/]$'
                                return strpart(path, len(refs) - 4)
                              endif
                              return ''
                            endfunction
                            
    1              0.000005 function! fugitive#Real(url) abort
                              if empty(a:url)
                                return ''
                              endif
                              let [dir, commit, file] = s:DirCommitFile(a:url)
                              if len(dir)
                                let tree = s:Tree(dir)
                                return FugitiveVimPath((len(tree) ? tree : dir) . file)
                              endif
                              let pre = substitute(matchstr(a:url, '^\a\a\+\ze:'), '^.', '\u&', '')
                              if len(pre) && pre !=? 'fugitive' && exists('*' . pre . 'Real')
                                let url = {pre}Real(a:url)
                              else
                                let url = fnamemodify(a:url, ':p' . (a:url =~# '[\/]$' ? '' : ':s?[\/]$??'))
                              endif
                              return FugitiveVimPath(empty(url) ? a:url : url)
                            endfunction
                            
    1              0.000005 function! fugitive#Path(url, ...) abort
                              if empty(a:url)
                                return ''
                              endif
                              let dir = a:0 > 1 ? a:2 : s:Dir()
                              let tree = s:Tree(dir)
                              if !a:0
                                return fugitive#Real(a:url)
                              elseif a:1 =~# '\.$'
                                let path = s:Slash(fugitive#Real(a:url))
                                let cwd = getcwd()
                                let lead = ''
                                while s:cpath(tree . '/', (cwd . '/')[0 : len(tree)])
                                  if s:cpath(cwd . '/', path[0 : len(cwd)])
                                    if strpart(path, len(cwd) + 1) =~# '^\.git\%(/\|$\)'
                                      break
                                    endif
                                    return a:1[0:-2] . (empty(lead) ? './' : lead) . strpart(path, len(cwd) + 1)
                                  endif
                                  let cwd = fnamemodify(cwd, ':h')
                                  let lead .= '../'
                                endwhile
                                return a:1[0:-2] . path
                              endif
                              let url = a:url
                              let temp_state = s:TempState(url)
                              if has_key(temp_state, 'bufnr')
                                let url = bufname(temp_state.bufnr)
                              endif
                              let url = s:Slash(fnamemodify(url, ':p'))
                              if url =~# '/$' && s:Slash(a:url) !~# '/$'
                                let url = url[0:-2]
                              endif
                              let [argdir, commit, file] = s:DirCommitFile(a:url)
                              if len(argdir) && s:cpath(argdir) !=# s:cpath(dir)
                                let file = ''
                              elseif len(dir) && s:cpath(url[0 : len(dir)]) ==# s:cpath(dir . '/')
                                let file = '/.git'.url[strlen(dir) : -1]
                              elseif len(tree) && s:cpath(url[0 : len(tree)]) ==# s:cpath(tree . '/')
                                let file = url[len(tree) : -1]
                              elseif s:cpath(url) ==# s:cpath(tree)
                                let file = '/'
                              endif
                              if empty(file) && a:1 =~# '^$\|^[.:]/$'
                                return FugitiveGitPath(fugitive#Real(a:url))
                              endif
                              return substitute(file, '^/', a:1, '')
                            endfunction
                            
    1              0.000006 function! s:Relative(...) abort
                              return fugitive#Path(@%, a:0 ? a:1 : ':(top)', a:0 > 1 ? a:2 : s:Dir())
                            endfunction
                            
    1              0.000005 function! fugitive#Find(object, ...) abort
                              if type(a:object) == type(0)
                                let name = bufname(a:object)
                                return FugitiveVimPath(name =~# '^$\|^/\|^\a\+:' ? name : getcwd() . '/' . name)
                              elseif a:object =~# '^[~$]'
                                let prefix = matchstr(a:object, '^[~$]\i*')
                                let owner = expand(prefix)
                                return FugitiveVimPath((len(owner) ? owner : prefix) . strpart(a:object, len(prefix)))
                              elseif s:Slash(a:object) =~# '^$\|^/\|^\%(\a\a\+:\).*\%(//\|::\)' . (has('win32') ? '\|^\a:/' : '')
                                return FugitiveVimPath(a:object)
                              elseif s:Slash(a:object) =~# '^\.\.\=\%(/\|$\)'
                                return FugitiveVimPath(simplify(getcwd() . '/' . a:object))
                              endif
                              let dir = a:0 ? a:1 : s:Dir()
                              if empty(dir)
                                let file = matchstr(a:object, '^\%(:\d:\|[^:]*:\)\zs.*', '', '')
                                let dir = FugitiveExtractGitDir(file)
                                if empty(dir)
                                  return fnamemodify(FugitiveVimPath(len(file) ? file : a:object), ':p')
                                endif
                              endif
                              let rev = s:Slash(a:object)
                              let tree = s:Tree(dir)
                              let base = len(tree) ? tree : 'fugitive://' . dir . '//0'
                              if rev ==# '.git'
                                let f = len(tree) ? tree . '/.git' : dir
                              elseif rev =~# '^\.git/'
                                let f = substitute(rev, '^\.git', '', '')
                                let cdir = fugitive#CommonDir(dir)
                                if f =~# '^/\.\./\.\.\%(/\|$\)'
                                  let f = simplify(len(tree) ? tree . f[3:-1] : dir . f)
                                elseif f =~# '^/\.\.\%(/\|$\)'
                                  let f = base . f[3:-1]
                                elseif cdir !=# dir && (
                                      \ f =~# '^/\%(config\|hooks\|info\|logs/refs\|objects\|refs\|worktrees\)\%(/\|$\)' ||
                                      \ f !~# '^/\%(index$\|index\.lock$\|\w*MSG$\|\w*HEAD$\|logs/\w*HEAD$\|logs$\|rebase-\w\+\)\%(/\|$\)' &&
                                      \ getftime(FugitiveVimPath(dir . f)) < 0 && getftime(FugitiveVimPath(cdir . f)) >= 0)
                                  let f = simplify(cdir . f)
                                else
                                  let f = simplify(dir . f)
                                endif
                              elseif rev ==# ':/'
                                let f = base
                              elseif rev =~# '^\.\%(/\|$\)'
                                let f = base . rev[1:-1]
                              elseif rev =~# '^::\%(/\|\a\+\:\)'
                                let f = rev[2:-1]
                              elseif rev =~# '^::\.\.\=\%(/\|$\)'
                                let f = simplify(getcwd() . '/' . rev[2:-1])
                              elseif rev =~# '^::'
                                let f = base . '/' . rev[2:-1]
                              elseif rev =~# '^:\%([0-3]:\)\=\.\.\=\%(/\|$\)\|^:[0-3]:\%(/\|\a\+:\)'
                                let f = rev =~# '^:\%([0-3]:\)\=\.' ? simplify(getcwd() . '/' . matchstr(rev, '\..*')) : rev[3:-1]
                                if s:cpath(base . '/', (f . '/')[0 : len(base)])
                                  let f = 'fugitive://' . dir . '//' . +matchstr(rev, '^:\zs\d\ze:') . '/' . strpart(f, len(base) + 1)
                                else
                                  let altdir = FugitiveExtractGitDir(f)
                                  if len(altdir) && !s:cpath(dir, altdir)
                                    return fugitive#Find(a:object, altdir)
                                  endif
                                endif
                              elseif rev =~# '^:[0-3]:'
                                let f = 'fugitive://' . dir . '//' . rev[1] . '/' . rev[3:-1]
                              elseif rev ==# ':'
                                if $GIT_INDEX_FILE =~# '/[^/]*index[^/]*\.lock$' && s:cpath(fnamemodify($GIT_INDEX_FILE,':p')[0:strlen(dir)]) ==# s:cpath(dir . '/') && filereadable($GIT_INDEX_FILE)
                                  let f = fnamemodify($GIT_INDEX_FILE, ':p')
                                else
                                  let f = fugitive#Find('.git/index', dir)
                                endif
                              elseif rev =~# '^:(\%(top\|top,literal\|literal,top\|literal\))'
                                let f = matchstr(rev, ')\zs.*')
                                if f=~# '^\.\.\=\%(/\|$\)'
                                  let f = simplify(getcwd() . '/' . f)
                                elseif f !~# '^/\|^\%(\a\a\+:\).*\%(//\|::\)' . (has('win32') ? '\|^\a:/' : '')
                                  let f = base . '/' . f
                                endif
                              elseif rev =~# '^:/\@!'
                                let f = 'fugitive://' . dir . '//0/' . rev[1:-1]
                              else
                                if !exists('f')
                                  let commit = substitute(matchstr(rev, '^\%([^:.-]\|\.\.[^/:]\)[^:]*\|^:.*'), '^@\%($\|[~^]\|@{\)\@=', 'HEAD', '')
                                  let file = substitute(matchstr(rev, '^\%([^:.-]\|\.\.[^/:]\)[^:]*\zs:.*'), '^:', '/', '')
                                  if file =~# '^/\.\.\=\%(/\|$\)\|^//\|^/\a\+:'
                                    let file = file =~# '^/\.' ? simplify(getcwd() . file) : file[1:-1]
                                    if s:cpath(base . '/', (file . '/')[0 : len(base)])
                                      let file = '/' . strpart(file, len(base) + 1)
                                    else
                                      let altdir = FugitiveExtractGitDir(file)
                                      if len(altdir) && !s:cpath(dir, altdir)
                                        return fugitive#Find(a:object, altdir)
                                      endif
                                      return file
                                    endif
                                  endif
                                  let commits = split(commit, '\.\.\.-\@!', 1)
                                  if len(commits) == 2
                                    call map(commits, 'empty(v:val) || v:val ==# "@" ? "HEAD" : v:val')
                                    let commit = matchstr(s:ChompDefault('', [dir, 'merge-base'] + commits + ['--']), '\<[0-9a-f]\{40,\}\>')
                                  endif
                                  if commit !~# '^[0-9a-f]\{40,\}$'
                                    let commit = matchstr(s:ChompDefault('', [dir, 'rev-parse', '--verify', commit . (len(file) ? '^{}' : ''), '--']), '\<[0-9a-f]\{40,\}\>')
                                  endif
                                  if len(commit)
                                    let f = 'fugitive://' . dir . '//' . commit . file
                                  else
                                    let f = base . '/' . substitute(rev, '^:/:\=\|^[^:]\+:', '', '')
                                  endif
                                endif
                              endif
                              return FugitiveVimPath(f)
                            endfunction
                            
    1              0.000006 function! s:Generate(rev, ...) abort
                              return fugitive#Find(a:rev, a:0 ? a:1 : s:Dir())
                            endfunction
                            
    1              0.000005 function! s:DotRelative(path, ...) abort
                              let cwd = a:0 ? a:1 : getcwd()
                              let path = substitute(a:path, '^[~$]\i*', '\=expand(submatch(0))', '')
                              if len(cwd) && s:cpath(cwd . '/', (path . '/')[0 : len(cwd)])
                                return '.' . strpart(path, len(cwd))
                              endif
                              return a:path
                            endfunction
                            
    1              0.000004 function! fugitive#Object(...) abort
                              let dir = a:0 > 1 ? a:2 : s:Dir()
                              let [fdir, rev] = s:DirRev(a:0 ? a:1 : @%)
                              if s:cpath(dir) !=# s:cpath(fdir)
                                let rev = ''
                              endif
                              let tree = s:Tree(dir)
                              let full = a:0 ? a:1 : @%
                              let full = fnamemodify(full, ':p' . (s:Slash(full) =~# '/$' ? '' : ':s?/$??'))
                              if empty(rev) && empty(tree)
                                return FugitiveGitPath(full)
                              elseif empty(rev)
                                let rev = fugitive#Path(full, './', dir)
                                if rev =~# '^\./.git\%(/\|$\)'
                                  return FugitiveGitPath(full)
                                endif
                              endif
                              if rev !~# '^\.\%(/\|$\)' || s:cpath(getcwd(), tree)
                                return rev
                              else
                                return FugitiveGitPath(tree . rev[1:-1])
                              endif
                            endfunction
                            
    1              0.000008 let s:var = '\%(%\|#<\=\d\+\|##\=\)'
    1              0.000008 let s:flag = '\%(:[p8~.htre]\|:g\=s\(.\).\{-\}\1.\{-\}\1\)'
    1              0.000014 let s:expand = '\%(\(' . s:var . '\)\(' . s:flag . '*\)\(:S\)\=\)'
                            
    1              0.000005 function! s:BufName(var) abort
                              if a:var ==# '%'
                                return bufname(get(s:TempState(), 'bufnr', ''))
                              elseif a:var =~# '^#\d*$'
                                let nr = get(s:TempState(bufname(+a:var[1:-1])), 'bufnr', '')
                                return bufname(nr ? nr : +a:var[1:-1])
                              else
                                return expand(a:var)
                              endif
                            endfunction
                            
    1              0.000005 function! s:ExpandVarLegacy(str) abort
                              if get(g:, 'fugitive_legacy_quoting', 1)
                                return substitute(a:str, '\\\ze[%#!]', '', 'g')
                              else
                                return a:str
                              endif
                            endfunction
                            
    1              0.000007 function! s:ExpandVar(other, var, flags, esc, ...) abort
                              let cwd = a:0 ? a:1 : getcwd()
                              if a:other =~# '^\'
                                return a:other[1:-1]
                              elseif a:other =~# '^'''
                                return s:ExpandVarLegacy(substitute(a:other[1:-2], "''", "'", "g"))
                              elseif a:other =~# '^"'
                                return s:ExpandVarLegacy(substitute(a:other[1:-2], '""', '"', "g"))
                              elseif a:other =~# '^!'
                                let buffer = s:BufName(len(a:other) > 1 ? '#'. a:other[1:-1] : '%')
                                let owner = s:Owner(buffer)
                                return len(owner) ? owner : '@'
                              endif
                              let flags = a:flags
                              let file = s:DotRelative(fugitive#Real(s:BufName(a:var)), cwd)
                              while len(flags)
                                let flag = matchstr(flags, s:flag)
                                let flags = strpart(flags, len(flag))
                                if flag ==# ':.'
                                  let file = s:DotRelative(file, cwd)
                                else
                                  let file = fnamemodify(file, flag)
                                endif
                              endwhile
                              let file = s:Slash(file)
                              return (len(a:esc) ? shellescape(file) : file)
                            endfunction
                            
    1              0.000004 function! s:Expand(rev, ...) abort
                              if a:rev =~# '^:[0-3]$'
                                let file = len(expand('%')) ? a:rev . ':%' : '%'
                              elseif a:rev ==# '>'
                                let file = '%'
                              elseif a:rev =~# '^>[~^]'
                                let file = len(expand('%')) ? '!' . a:rev[1:-1] . ':%' : '%'
                              elseif a:rev =~# '^>[> ]\@!'
                                let file = len(expand('%')) ? a:rev[1:-1] . ':%' : '%'
                              else
                                let file = a:rev
                              endif
                              return substitute(file,
                                    \ '\(\\[' . s:fnameescape . ']\|^\\[>+-]\|!\d*\)\|' . s:expand,
                                    \ '\=s:ExpandVar(submatch(1),submatch(2),submatch(3),"", a:0 ? a:1 : getcwd())', 'g')
                            endfunction
                            
    1              0.000005 function! fugitive#Expand(object) abort
                              return substitute(a:object,
                                    \ '\(\\[' . s:fnameescape . ']\|^\\[>+-]\|!\d*\)\|' . s:expand,
                                    \ '\=s:ExpandVar(submatch(1),submatch(2),submatch(3),submatch(5))', 'g')
                            endfunction
                            
    1              0.000005 function! s:ExpandSplit(string, ...) abort
                              let list = []
                              let string = a:string
                              let handle_bar = a:0 && a:1
                              let dquote = handle_bar ? '"\%([^"]\|""\|\\"\)*"\|' : ''
                              let cwd = a:0 > 1 ? a:2 : getcwd()
                              while string =~# '\S'
                                if handle_bar && string =~# '^\s*|'
                                  return [list, substitute(string, '^\s*', '', '')]
                                endif
                                let arg = matchstr(string, '^\s*\%(' . dquote . '''[^'']*''\|\\.\|[^[:space:] ' . (handle_bar ? '|' : '') . ']\)\+')
                                let string = strpart(string, len(arg))
                                let arg = substitute(arg, '^\s\+', '', '')
                                if !exists('seen_separator')
                                  let arg = substitute(arg, '^\%([^:.][^:]*:\|^:\|^:[0-3]:\)\=\zs\.\.\=\%(/.*\)\=$',
                                        \ '\=s:DotRelative(s:Slash(simplify(getcwd() . "/" . submatch(0))), cwd)', '')
                                endif
                                let arg = substitute(arg,
                                      \ '\(' . dquote . '''\%(''''\|[^'']\)*''\|\\[' . s:fnameescape . ']\|^\\[>+-]\|!\d*\)\|' . s:expand,
                                      \ '\=s:ExpandVar(submatch(1),submatch(2),submatch(3),submatch(5), cwd)', 'g')
                                call add(list, arg)
                                if arg ==# '--'
                                  let seen_separator = 1
                                endif
                              endwhile
                              return handle_bar ? [list, ''] : list
                            endfunction
                            
    1              0.000004 function! s:SplitExpand(string, ...) abort
                              return s:ExpandSplit(a:string, 0, a:0 ? a:1 : getcwd())
                            endfunction
                            
    1              0.000005 function! s:SplitExpandChain(string, ...) abort
                              return s:ExpandSplit(a:string, 1, a:0 ? a:1 : getcwd())
                            endfunction
                            
    1              0.000009 let s:trees = {}
    1              0.000005 let s:indexes = {}
    1              0.000005 function! s:TreeInfo(dir, commit) abort
                              if a:commit =~# '^:\=[0-3]$'
                                let index = get(s:indexes, a:dir, [])
                                let newftime = getftime(fugitive#Find('.git/index', a:dir))
                                if get(index, 0, -1) < newftime
                                  let [lines, exec_error] = s:LinesError([a:dir, 'ls-files', '--stage', '--'])
                                  let s:indexes[a:dir] = [newftime, {'0': {}, '1': {}, '2': {}, '3': {}}]
                                  if exec_error
                                    return [{}, -1]
                                  endif
                                  for line in lines
                                    let [info, filename] = split(line, "\t")
                                    let [mode, sha, stage] = split(info, '\s\+')
                                    let s:indexes[a:dir][1][stage][filename] = [newftime, mode, 'blob', sha, -2]
                                    while filename =~# '/'
                                      let filename = substitute(filename, '/[^/]*$', '', '')
                                      let s:indexes[a:dir][1][stage][filename] = [newftime, '040000', 'tree', '', 0]
                                    endwhile
                                  endfor
                                endif
                                return [get(s:indexes[a:dir][1], a:commit[-1:-1], {}), newftime]
                              elseif a:commit =~# '^\x\{40,\}$'
                                if !has_key(s:trees, a:dir)
                                  let s:trees[a:dir] = {}
                                endif
                                if !has_key(s:trees[a:dir], a:commit)
                                  let [ftime, exec_error] = s:ChompError([a:dir, 'log', '-1', '--pretty=format:%ct', a:commit, '--'])
                                  if exec_error
                                    let s:trees[a:dir][a:commit] = [{}, -1]
                                    return s:trees[a:dir][a:commit]
                                  endif
                                  let s:trees[a:dir][a:commit] = [{}, +ftime]
                                  let [lines, exec_error] = s:LinesError([a:dir, 'ls-tree', '-rtl', '--full-name', a:commit, '--'])
                                  if exec_error
                                    return s:trees[a:dir][a:commit]
                                  endif
                                  for line in lines
                                    let [info, filename] = split(line, "\t")
                                    let [mode, type, sha, size] = split(info, '\s\+')
                                    let s:trees[a:dir][a:commit][0][filename] = [+ftime, mode, type, sha, +size, filename]
                                  endfor
                                endif
                                return s:trees[a:dir][a:commit]
                              endif
                              return [{}, -1]
                            endfunction
                            
    1              0.000005 function! s:PathInfo(url) abort
                              let [dir, commit, file] = s:DirCommitFile(a:url)
                              if empty(dir) || !get(g:, 'fugitive_file_api', 1)
                                return [-1, '000000', '', '', -1]
                              endif
                              let path = substitute(file[1:-1], '/*$', '', '')
                              let [tree, ftime] = s:TreeInfo(dir, commit)
                              let entry = empty(path) ? [ftime, '040000', 'tree', '', -1] : get(tree, path, [])
                              if empty(entry) || file =~# '/$' && entry[2] !=# 'tree'
                                return [-1, '000000', '', '', -1]
                              else
                                return entry
                              endif
                            endfunction
                            
    1              0.000005 function! fugitive#simplify(url) abort
                              let [dir, commit, file] = s:DirCommitFile(a:url)
                              if empty(dir)
                                return ''
                              endif
                              if file =~# '/\.\.\%(/\|$\)'
                                let tree = s:Tree(dir)
                                if len(tree)
                                  let path = simplify(tree . file)
                                  if strpart(path . '/', 0, len(tree) + 1) !=# tree . '/'
                                    return FugitiveVimPath(path)
                                  endif
                                endif
                              endif
                              return FugitiveVimPath('fugitive://' . simplify(dir) . '//' . commit . simplify(file))
                            endfunction
                            
    1              0.000005 function! fugitive#resolve(url) abort
                              let url = fugitive#simplify(a:url)
                              if url =~? '^fugitive:'
                                return url
                              else
                                return resolve(url)
                              endif
                            endfunction
                            
    1              0.000005 function! fugitive#getftime(url) abort
                              return s:PathInfo(a:url)[0]
                            endfunction
                            
    1              0.000004 function! fugitive#getfsize(url) abort
                              let entry = s:PathInfo(a:url)
                              if entry[4] == -2 && entry[2] ==# 'blob' && len(entry[3])
                                let dir = s:DirCommitFile(a:url)[0]
                                let entry[4] = +s:ChompDefault(-1, [dir, 'cat-file', '-s', entry[3]])
                              endif
                              return entry[4]
                            endfunction
                            
    1              0.000004 function! fugitive#getftype(url) abort
                              return get({'tree': 'dir', 'blob': 'file'}, s:PathInfo(a:url)[2], '')
                            endfunction
                            
    1              0.000004 function! fugitive#filereadable(url) abort
                              return s:PathInfo(a:url)[2] ==# 'blob'
                            endfunction
                            
    1              0.000004 function! fugitive#filewritable(url) abort
                              let [dir, commit, file] = s:DirCommitFile(a:url)
                              if commit !~# '^\d$' || !filewritable(fugitive#Find('.git/index', dir))
                                return 0
                              endif
                              return s:PathInfo(a:url)[2] ==# 'blob' ? 1 : 2
                            endfunction
                            
    1              0.000005 function! fugitive#isdirectory(url) abort
                              return s:PathInfo(a:url)[2] ==# 'tree'
                            endfunction
                            
    1              0.000004 function! fugitive#getfperm(url) abort
                              let [dir, commit, file] = s:DirCommitFile(a:url)
                              let perm = getfperm(dir)
                              let fperm = s:PathInfo(a:url)[1]
                              if fperm ==# '040000'
                                let fperm = '000755'
                              endif
                              if fperm !~# '[15]'
                                let perm = tr(perm, 'x', '-')
                              endif
                              if fperm !~# '[45]$'
                                let perm = tr(perm, 'rw', '--')
                              endif
                              if commit !~# '^\d$'
                                let perm = tr(perm, 'w', '-')
                              endif
                              return perm ==# '---------' ? '' : perm
                            endfunction
                            
    1              0.000005 function s:UpdateIndex(dir, info) abort
                              let info = join(a:info[0:-2]) . "\t" . a:info[-1] . "\n"
                              let [error, exec_error] = s:SystemError([a:dir, 'update-index', '--index-info'], info)
                              return !exec_error ? '' : len(error) ? error : 'fugitive: unknown update-index error'
                            endfunction
                            
    1              0.000005 function! fugitive#setfperm(url, perm) abort
                              let [dir, commit, file] = s:DirCommitFile(a:url)
                              let entry = s:PathInfo(a:url)
                              let perm = fugitive#getfperm(a:url)
                              if commit !~# '^\d$' || entry[2] !=# 'blob' ||
                                  \ substitute(perm, 'x', '-', 'g') !=# substitute(a:perm, 'x', '-', 'g')
                                return -2
                              endif
                              let error = s:UpdateIndex(dir, [a:perm =~# 'x' ? '000755' : '000644', entry[3], commit, file[1:-1]])
                              return len(error) ? -1 : 0
                            endfunction
                            
    1              0.000005 function! s:TempCmd(out, cmd) abort
                              try
                                let cmd = (type(a:cmd) == type([]) ? fugitive#Prepare(a:cmd) : a:cmd)
                                let redir = ' > ' . a:out
                                if (s:winshell() || &shellcmdflag ==# '-Command') && !has('nvim')
                                  let cmd_escape_char = &shellxquote == '(' ?  '^' : '^^^'
                                  return s:SystemError('cmd /c "' . s:gsub(cmd, '[<>%]', cmd_escape_char . '&') . redir . '"')
                                elseif &shell =~# 'fish'
                                  return s:SystemError(' begin;' . cmd . redir . ';end ')
                                else
                                  return s:SystemError(' (' . cmd . redir . ') ')
                                endif
                              endtry
                            endfunction
                            
    1              0.000010 if !exists('s:blobdirs')
    1              0.000010   let s:blobdirs = {}
    1              0.000003 endif
    1              0.000004 function! s:BlobTemp(url) abort
                              let [dir, commit, file] = s:DirCommitFile(a:url)
                              if empty(file)
                                return ''
                              endif
                              if !has_key(s:blobdirs, dir)
                                let s:blobdirs[dir] = tempname()
                              endif
                              let tempfile = s:blobdirs[dir] . '/' . commit . file
                              let tempparent = fnamemodify(tempfile, ':h')
                              if !isdirectory(tempparent)
                                call mkdir(tempparent, 'p')
                              endif
                              if commit =~# '^\d$' || !filereadable(tempfile)
                                let rev = s:DirRev(a:url)[1]
                                let exec_error = s:TempCmd(tempfile, [dir, 'cat-file', 'blob', rev])[1]
                                if exec_error
                                  call delete(tempfile)
                                  return ''
                                endif
                              endif
                              return s:Resolve(tempfile)
                            endfunction
                            
    1              0.000004 function! fugitive#readfile(url, ...) abort
                              let entry = s:PathInfo(a:url)
                              if entry[2] !=# 'blob'
                                return []
                              endif
                              let temp = s:BlobTemp(a:url)
                              if empty(temp)
                                return []
                              endif
                              return call('readfile', [temp] + a:000)
                            endfunction
                            
    1              0.000005 function! fugitive#writefile(lines, url, ...) abort
                              let url = type(a:url) ==# type('') ? a:url : ''
                              let [dir, commit, file] = s:DirCommitFile(url)
                              let entry = s:PathInfo(url)
                              if commit =~# '^\d$' && entry[2] !=# 'tree'
                                let temp = tempname()
                                if a:0 && a:1 =~# 'a' && entry[2] ==# 'blob'
                                  call writefile(fugitive#readfile(url, 'b'), temp, 'b')
                                endif
                                call call('writefile', [a:lines, temp] + a:000)
                                let [hash, exec_error] = s:ChompError([dir, 'hash-object', '-w', temp])
                                let mode = len(entry[1]) ? entry[1] : '100644'
                                if !exec_error && hash =~# '^\x\{40,\}$'
                                  let error = s:UpdateIndex(dir, [mode, hash, commit, file[1:-1]])
                                  if empty(error)
                                    return 0
                                  endif
                                endif
                              endif
                              return call('writefile', [a:lines, a:url] + a:000)
                            endfunction
                            
    1              0.000031 let s:globsubs = {
                                  \ '/**/': '/\%([^./][^/]*/\)*',
                                  \ '/**': '/\%([^./][^/]\+/\)*[^./][^/]*',
                                  \ '**/': '[^/]*\%(/[^./][^/]*\)*',
                                  \ '**': '.*',
                                  \ '/*': '/[^/.][^/]*',
                                  \ '*': '[^/]*',
                                  \ '?': '[^/]'}
    1              0.000005 function! fugitive#glob(url, ...) abort
                              let [dirglob, commit, glob] = s:DirCommitFile(a:url)
                              let append = matchstr(glob, '/*$')
                              let glob = substitute(glob, '/*$', '', '')
                              let pattern = '^' . substitute(glob, '/\=\*\*/\=\|/\=\*\|[.?\$]\|^^', '\=get(s:globsubs, submatch(0), "\\" . submatch(0))', 'g')[1:-1] . '$'
                              let results = []
                              for dir in dirglob =~# '[*?]' ? split(glob(dirglob), "\n") : [dirglob]
                                if empty(dir) || !get(g:, 'fugitive_file_api', 1) || !filereadable(fugitive#Find('.git/HEAD', dir))
                                  continue
                                endif
                                let files = items(s:TreeInfo(dir, commit)[0])
                                if len(append)
                                  call filter(files, 'v:val[1][2] ==# "tree"')
                                endif
                                call map(files, 'v:val[0]')
                                call filter(files, 'v:val =~# pattern')
                                let prepend = 'fugitive://' . dir . '//' . substitute(commit, '^:', '', '') . '/'
                                call sort(files)
                                call map(files, 'FugitiveVimPath(prepend . v:val . append)')
                                call extend(results, files)
                              endfor
                              if a:0 > 1 && a:2
                                return results
                              else
                                return join(results, "\n")
                              endif
                            endfunction
                            
    1              0.000004 function! fugitive#delete(url, ...) abort
                              let [dir, commit, file] = s:DirCommitFile(a:url)
                              if a:0 && len(a:1) || commit !~# '^\d$'
                                return -1
                              endif
                              let entry = s:PathInfo(a:url)
                              if entry[2] !=# 'blob'
                                return -1
                              endif
                              let error = s:UpdateIndex(dir, ['000000', '0000000000000000000000000000000000000000', commit, file[1:-1]])
                              return len(error) ? -1 : 0
                            endfunction
                            
                            " Section: Buffer Object
                            
    1              0.000006 let s:buffer_prototype = {}
                            
    1              0.000004 function! fugitive#buffer(...) abort
                              let buffer = {'#': bufnr(a:0 ? a:1 : '%')}
                              call extend(buffer, s:buffer_prototype, 'keep')
                              return buffer
                            endfunction
                            
    1              0.000004 function! s:buffer_repo() dict abort
                              return fugitive#repo(self['#'])
                            endfunction
                            
    1              0.000004 function! s:buffer_type(...) dict abort
                              return 'see b:fugitive_type'
                            endfunction
                            
    1   0.000231   0.000027 call s:add_methods('buffer', ['repo', 'type'])
                            
                            " Section: Completion
                            
    1              0.000006 function! s:FilterEscape(items, ...) abort
                              let items = copy(a:items)
                              call map(items, 's:fnameescape(v:val)')
                              if a:0 && type(a:1) == type('')
                                let cmp = s:FileIgnoreCase(1) ? '==?' : '==#'
                                call filter(items, 'strpart(v:val, 0, strlen(a:1)) ' . cmp . ' a:1')
                              endif
                              return items
                            endfunction
                            
    1              0.000005 function! s:GlobComplete(lead, pattern) abort
                              if a:lead ==# '/'
                                return []
                              elseif v:version >= 704
                                let results = glob(a:lead . a:pattern, 0, 1)
                              else
                                let results = split(glob(a:lead . a:pattern), "\n")
                              endif
                              call map(results, 'v:val !~# "/$" && isdirectory(v:val) ? v:val."/" : v:val')
                              call map(results, 'v:val[ strlen(a:lead) : -1 ]')
                              return results
                            endfunction
                            
    1              0.000005 function! fugitive#CompletePath(base, ...) abort
                              let dir = a:0 == 1 ? a:1 : a:0 >= 3 ? a:3 : s:Dir()
                              let stripped = matchstr(a:base, '^\%(:/:\=\|:(top)\|:(top,literal)\|:(literal,top)\)')
                              let base = strpart(a:base, len(stripped))
                              if len(stripped) || a:0 < 4
                                let root = s:Tree(dir)
                              else
                                let root = a:4
                              endif
                              if root !=# '/' && len(root)
                                let root .= '/'
                              endif
                              if empty(stripped)
                                let stripped = matchstr(a:base, '^\%(:(literal)\|:\)')
                                let base = strpart(a:base, len(stripped))
                              endif
                              if base =~# '^\.git/'
                                let pattern = s:gsub(base[5:-1], '/', '*&').'*'
                                let matches = s:GlobComplete(dir . '/', pattern)
                                let cdir = fugitive#CommonDir(dir)
                                if len(cdir) && s:cpath(dir) !=# s:cpath(cdir)
                                  call extend(matches, s:GlobComplete(cdir . '/', pattern))
                                endif
                                call s:Uniq(matches)
                                call map(matches, "'.git/' . v:val")
                              elseif base =~# '^\~/'
                                let matches = map(s:GlobComplete(expand('~/'), base[2:-1] . '*'), '"~/" . v:val')
                              elseif a:base =~# '^/\|^\a\+:\|^\.\.\=/'
                                let matches = s:GlobComplete('', base . '*')
                              elseif len(root)
                                let matches = s:GlobComplete(root, s:gsub(base, '/', '*&').'*')
                              else
                                let matches = []
                              endif
                              call map(matches, 's:fnameescape(s:Slash(stripped . v:val))')
                              return matches
                            endfunction
                            
    1              0.000005 function! fugitive#PathComplete(...) abort
                              return call('fugitive#CompletePath', a:000)
                            endfunction
                            
    1              0.000005 function! s:CompleteHeads(dir) abort
                              if empty(a:dir)
                                return []
                              endif
                              let dir = fugitive#Find('.git/', a:dir)
                              return sort(filter(['HEAD', 'FETCH_HEAD', 'ORIG_HEAD'] + s:merge_heads, 'filereadable(dir . v:val)')) +
                                    \ sort(s:LinesError([a:dir, 'rev-parse', '--symbolic', '--branches', '--tags', '--remotes'])[0])
                            endfunction
                            
    1              0.000005 function! fugitive#CompleteObject(base, ...) abort
                              let dir = a:0 == 1 ? a:1 : a:0 >= 3 ? a:3 : s:Dir()
                              let tree = s:Tree(dir)
                              let cwd = getcwd()
                              let subdir = ''
                              if len(tree) && s:cpath(tree . '/', cwd[0 : len(tree)])
                                let subdir = strpart(cwd, len(tree) + 1) . '/'
                              endif
                            
                              if a:base =~# '^\.\=/\|^:(' || a:base !~# ':'
                                let results = []
                                if a:base =~# '^refs/'
                                  let results += map(s:GlobComplete(fugitive#CommonDir(dir) . '/', a:base . '*'), 's:Slash(v:val)')
                                  call map(results, 's:fnameescape(v:val)')
                                elseif a:base !~# '^\.\=/\|^:('
                                  let heads = s:CompleteHeads(dir)
                                  if filereadable(fugitive#Find('.git/refs/stash', dir))
                                    let heads += ["stash"]
                                    let heads += sort(s:LinesError(["stash","list","--pretty=format:%gd"], dir)[0])
                                  endif
                                  let results += s:FilterEscape(heads, a:base)
                                endif
                                let results += a:0 == 1 || a:0 >= 3 ? fugitive#CompletePath(a:base, 0, '', dir, a:0 >= 4 ? a:4 : tree) : fugitive#CompletePath(a:base)
                                return results
                            
                              elseif a:base =~# '^:'
                                let entries = s:LinesError(['ls-files','--stage'], dir)[0]
                                if a:base =~# ':\./'
                                  call map(entries, 'substitute(v:val, "\\M\t\\zs" . subdir, "./", "")')
                                endif
                                call map(entries,'s:sub(v:val,".*(\\d)\\t(.*)",":\\1:\\2")')
                                if a:base !~# '^:[0-3]\%(:\|$\)'
                                  call filter(entries,'v:val[1] == "0"')
                                  call map(entries,'v:val[2:-1]')
                                endif
                            
                              else
                                let parent = matchstr(a:base, '.*[:/]')
                                let entries = s:LinesError(['ls-tree', substitute(parent,  ':\zs\./', '\=subdir', '')], dir)[0]
                                call map(entries,'s:sub(v:val,"^04.*\\zs$","/")')
                                call map(entries,'tree.s:sub(v:val,".*\t","")')
                            
                              endif
                              return s:FilterEscape(entries, a:base)
                            endfunction
                            
    1              0.000007 function! s:CompleteSub(subcommand, A, L, P, ...) abort
                              let pre = strpart(a:L, 0, a:P)
                              if pre =~# ' -- '
                                return fugitive#CompletePath(a:A)
                              elseif a:A =~# '^-' || a:A is# 0
                                return s:FilterEscape(split(s:ChompDefault('', a:subcommand, '--git-completion-helper'), ' '), a:A)
                              elseif !a:0
                                return fugitive#CompleteObject(a:A, s:Dir())
                              elseif type(a:1) == type(function('tr'))
                                return call(a:1, [a:A, a:L, a:P] + (a:0 > 1 ? a:2 : []))
                              else
                                return s:FilterEscape(a:1, a:A)
                              endif
                            endfunction
                            
    1              0.000006 function! s:CompleteRevision(A, L, P, ...) abort
                              return s:FilterEscape(s:CompleteHeads(a:0 ? a:1 : s:Dir()), a:A)
                            endfunction
                            
    1              0.000005 function! s:CompleteRemote(A, L, P, ...) abort
                              let dir = a:0 ? a:1 : s:Dir()
                              let remote = matchstr(a:L, '\u\w*[! ] *.\{-\}\s\@<=\zs[^-[:space:]]\S*\ze ')
                              if !empty(remote)
                                let matches = s:LinesError([dir, 'ls-remote', remote])[0]
                                call filter(matches, 'v:val =~# "\t" && v:val !~# "{"')
                                call map(matches, 's:sub(v:val, "^.*\t%(refs/%(heads/|tags/)=)=", "")')
                              else
                                let matches = s:LinesError([dir, 'remote'])[0]
                              endif
                              return s:FilterEscape(matches, a:A)
                            endfunction
                            
                            " Section: Buffer auto-commands
                            
    1              0.000004 function! s:ReplaceCmd(cmd) abort
                              let temp = tempname()
                              let [err, exec_error] = s:TempCmd(temp, a:cmd)
                              if exec_error
                                call s:throw((len(err) ? err : filereadable(temp) ? join(readfile(temp), ' ') : 'unknown error running ' . a:cmd))
                              endif
                              setlocal noswapfile
                              silent exe 'lockmarks keepalt 0read ++edit' s:fnameescape(temp)
                              if &foldenable && foldlevel('$') > 0
                                set nofoldenable
                                silent keepjumps $delete _
                                set foldenable
                              else
                                silent keepjumps $delete _
                              endif
                              call delete(temp)
                              if s:cpath(fnamemodify(bufname('$'), ':p'), temp)
                                silent! execute bufnr('$') . 'bwipeout'
                              endif
                            endfunction
                            
    1              0.000008 function! s:QueryLog(refspec) abort
                              let lines = s:LinesError(['log', '-n', '256', '--pretty=format:%h%x09%s', a:refspec, '--'])[0]
                              call map(lines, 'split(v:val, "\t")')
                              call map(lines, '{"type": "Log", "commit": v:val[0], "subject": v:val[-1]}')
                              return lines
                            endfunction
                            
    1              0.000008 function! s:FormatLog(dict) abort
                              return a:dict.commit . ' ' . a:dict.subject
                            endfunction
                            
    1              0.000005 function! s:FormatRebase(dict) abort
                              return a:dict.status . ' ' . a:dict.commit . ' ' . a:dict.subject
                            endfunction
                            
    1              0.000004 function! s:FormatFile(dict) abort
                              return a:dict.status . ' ' . a:dict.filename
                            endfunction
                            
    1              0.000004 function! s:Format(val) abort
                              if type(a:val) == type({})
                                return s:Format{a:val.type}(a:val)
                              elseif type(a:val) == type([])
                                return map(copy(a:val), 's:Format(v:val)')
                              else
                                return '' . a:val
                              endif
                            endfunction
                            
    1              0.000005 function! s:AddHeader(key, value) abort
                              if empty(a:value)
                                return
                              endif
                              let before = 1
                              while !empty(getline(before))
                                let before += 1
                              endwhile
                              call append(before - 1, [a:key . ':' . (len(a:value) ? ' ' . a:value : '')])
                              if before == 1 && line('$') == 2
                                silent keepjumps 2delete _
                              endif
                            endfunction
                            
    1              0.000005 function! s:AddSection(label, lines, ...) abort
                              let note = a:0 ? a:1 : ''
                              if empty(a:lines) && empty(note)
                                return
                              endif
                              call append(line('$'), ['', a:label . (len(note) ? ': ' . note : ' (' . len(a:lines) . ')')] + s:Format(a:lines))
                            endfunction
                            
    1              0.000043 let s:rebase_abbrevs = {
                                  \ 'p': 'pick',
                                  \ 'r': 'reword',
                                  \ 'e': 'edit',
                                  \ 's': 'squash',
                                  \ 'f': 'fixup',
                                  \ 'x': 'exec',
                                  \ 'd': 'drop',
                                  \ 'l': 'label',
                                  \ 't': 'reset',
                                  \ 'm': 'merge',
                                  \ 'b': 'break',
                                  \ }
                            
    1              0.000005 function! fugitive#BufReadStatus() abort
                              let amatch = s:Slash(expand('%:p'))
                              let b:fugitive_type = 'index'
                              unlet! b:fugitive_reltime
                              try
                                silent doautocmd BufReadPre
                                let config = fugitive#Config()
                            
                                let cmd = [fnamemodify(amatch, ':h')]
                                setlocal noro ma nomodeline buftype=nowrite
                                if s:cpath(fnamemodify($GIT_INDEX_FILE !=# '' ? $GIT_INDEX_FILE : fugitive#Find('.git/index'), ':p')) !=# s:cpath(amatch)
                                  let cmd += ['-c', 'GIT_INDEX_FILE=' . amatch]
                                endif
                            
                                if fugitive#GitVersion(2, 15)
                                  call add(cmd, '--no-optional-locks')
                                endif
                            
                                let b:fugitive_files = {'Staged': {}, 'Unstaged': {}}
                                let [staged, unstaged, untracked] = [[], [], []]
                                let props = {}
                            
                                if fugitive#GitVersion(2, 11)
                                  let cmd += ['status', '--porcelain=v2', '-bz']
                                  let [output, message, exec_error] = s:NullError(cmd)
                                  if exec_error
                                    throw 'fugitive: ' . message
                                  endif
                            
                                  let i = 0
                                  while i < len(output)
                                    let line = output[i]
                                    let prop = matchlist(line, '# \(\S\+\) \(.*\)')
                                    if len(prop)
                                      let props[prop[1]] = prop[2]
                                    elseif line[0] ==# '?'
                                      call add(untracked, {'type': 'File', 'status': line[0], 'filename': line[2:-1]})
                                    elseif line[0] !=# '#'
                                      if line[0] ==# 'u'
                                        let file = matchstr(line, '^.\{37\} \x\{40,\} \x\{40,\} \x\{40,\} \zs.*$')
                                      else
                                        let file = matchstr(line, '^.\{30\} \x\{40,\} \x\{40,\} \zs.*$')
                                      endif
                                      if line[0] ==# '2'
                                        let i += 1
                                        let file = matchstr(file, ' \zs.*')
                                        let files = output[i] . ' -> ' . file
                                      else
                                        let files = file
                                      endif
                                      let sub = matchstr(line, '^[12u] .. \zs....')
                                      if line[2] !=# '.'
                                        call add(staged, {'type': 'File', 'status': line[2], 'filename': files, 'sub': sub})
                                      endif
                                      if line[3] !=# '.'
                                        call add(unstaged, {'type': 'File', 'status': get({'C':'M','M':'?','U':'?'}, matchstr(sub, 'S\.*\zs[CMU]'), line[3]), 'filename': file, 'sub': sub})
                                      endif
                                    endif
                                    let i += 1
                                  endwhile
                                  let branch = substitute(get(props, 'branch.head', '(unknown)'), '\C^(\%(detached\|unknown\))$', '', '')
                                  if len(branch)
                                    let head = branch
                                  elseif has_key(props, 'branch.oid')
                                    let head = props['branch.oid'][0:10]
                                  else
                                    let head = FugitiveHead(11)
                                  endif
                                  let pull = get(props, 'branch.upstream', '')
                                else " git < 2.11
                                  let cmd += ['status', '--porcelain', '-bz']
                                  let [output, message, exec_error] = s:NullError(cmd)
                                  if exec_error
                                    throw 'fugitive: ' . message
                                  endif
                            
                                  while get(output, 0, '') =~# '^\l\+:'
                                    call remove(output, 0)
                                  endwhile
                                  let head = matchstr(output[0], '^## \zs\S\+\ze\%($\| \[\)')
                                  let pull = ''
                                  if head =~# '\.\.\.'
                                    let [head, pull] = split(head, '\.\.\.')
                                    let branch = head
                                  elseif head ==# 'HEAD' || empty(head)
                                    let head = FugitiveHead(11)
                                    let branch = ''
                                  else
                                    let branch = head
                                  endif
                            
                                  let i = 0
                                  while i < len(output)
                                    let line = output[i]
                                    let file = line[3:-1]
                                    let files = file
                                    let i += 1
                                    if line[2] !=# ' '
                                      continue
                                    endif
                                    if line[0:1] =~# '[RC]'
                                      let files = output[i] . ' -> ' . file
                                      let i += 1
                                    endif
                                    if line[0] !~# '[ ?!#]'
                                      call add(staged, {'type': 'File', 'status': line[0], 'filename': files, 'sub': ''})
                                    endif
                                    if line[0:1] ==# '??'
                                      call add(untracked, {'type': 'File', 'status': line[1], 'filename': files})
                                    elseif line[1] !~# '[ !#]'
                                      call add(unstaged, {'type': 'File', 'status': line[1], 'filename': file, 'sub': ''})
                                    endif
                                  endwhile
                                endif
                            
                                if empty(s:Tree())
                                  let [unstaged, untracked] = [[], []]
                                endif
                            
                                for dict in staged
                                  let b:fugitive_files['Staged'][dict.filename] = dict
                                endfor
                                for dict in unstaged
                                  let b:fugitive_files['Unstaged'][dict.filename] = dict
                                endfor
                            
                                let pull_type = 'Pull'
                                if len(pull)
                                  let rebase = fugitive#Config('branch.' . branch . '.rebase', config)
                                  if empty(rebase)
                                    let rebase = fugitive#Config('pull.rebase', config)
                                  endif
                                  if rebase =~# '^\%(true\|yes\|on\|1\|interactive\|merges\|preserve\)$'
                                    let pull_type = 'Rebase'
                                  elseif rebase =~# '^\%(false\|no|off\|0\|\)$'
                                    let pull_type = 'Merge'
                                  endif
                                endif
                            
                                let push_remote = fugitive#Config('branch.' . branch . '.pushRemote', config)
                                if empty(push_remote)
                                  let push_remote = fugitive#Config('remote.pushDefault', config)
                                endif
                                let fetch_remote = fugitive#Config('branch.' . branch . '.remote', config)
                                if empty(fetch_remote)
                                  let fetch_remote = 'origin'
                                endif
                                if empty(push_remote)
                                  let push_remote = fetch_remote
                                endif
                            
                                let push_default = fugitive#Config('push.default')
                                if empty(push_default)
                                  let push_default = fugitive#GitVersion(2) ? 'simple' : 'matching'
                                endif
                                if push_default ==# 'upstream'
                                  let push = pull
                                else
                                  let push = len(branch) ? (push_remote ==# '.' ? '' : push_remote . '/') . branch : ''
                                endif
                            
                                if isdirectory(fugitive#Find('.git/rebase-merge/'))
                                  let rebasing_dir = fugitive#Find('.git/rebase-merge/')
                                elseif isdirectory(fugitive#Find('.git/rebase-apply/'))
                                  let rebasing_dir = fugitive#Find('.git/rebase-apply/')
                                endif
                            
                                let rebasing = []
                                let rebasing_head = 'detached HEAD'
                                if exists('rebasing_dir') && filereadable(rebasing_dir . 'git-rebase-todo')
                                  let rebasing_head = substitute(readfile(rebasing_dir . 'head-name')[0], '\C^refs/heads/', '', '')
                                  let len = 11
                                  let lines = readfile(rebasing_dir . 'git-rebase-todo')
                                  for line in lines
                                    let hash = matchstr(line, '^[^a-z].*\s\zs[0-9a-f]\{4,\}\ze\.\.')
                                    if len(hash)
                                      let len = len(hash)
                                      break
                                    endif
                                  endfor
                                  if getfsize(rebasing_dir . 'done') > 0
                                    let done = readfile(rebasing_dir . 'done')
                                    call map(done, 'substitute(v:val, ''^\l\+\>'', "done", "")')
                                    let done[-1] = substitute(done[-1], '^\l\+\>', 'stop', '')
                                    let lines = done + lines
                                  endif
                                  call reverse(lines)
                                  for line in lines
                                    let match = matchlist(line, '^\(\l\+\)\s\+\(\x\{4,\}\)\s\+\(.*\)')
                                    if len(match) && match[1] !~# 'exec\|merge\|label'
                                      call add(rebasing, {'type': 'Rebase', 'status': get(s:rebase_abbrevs, match[1], match[1]), 'commit': strpart(match[2], 0, len), 'subject': match[3]})
                                    endif
                                  endfor
                                endif
                            
                                let diff = {'Staged': [], 'Unstaged': []}
                                if len(staged)
                                  let diff['Staged'] =
                                      \ s:LinesError(['diff', '--color=never', '--no-ext-diff', '--no-prefix', '--cached'])[0]
                                endif
                                if len(unstaged)
                                  let diff['Unstaged'] =
                                      \ s:LinesError(['diff', '--color=never', '--no-ext-diff', '--no-prefix'])[0]
                                endif
                                let b:fugitive_diff = diff
                                let expanded = get(b:, 'fugitive_expanded', {'Staged': {}, 'Unstaged': {}})
                                let b:fugitive_expanded = {'Staged': {}, 'Unstaged': {}}
                            
                                silent keepjumps %delete_
                            
                                call s:AddHeader('Head', head)
                                call s:AddHeader(pull_type, pull)
                                if push !=# pull
                                  call s:AddHeader('Push', push)
                                endif
                                if empty(s:Tree())
                                  call s:AddHeader('Bare', 'yes')
                                endif
                                call s:AddSection('Rebasing ' . rebasing_head, rebasing)
                                call s:AddSection('Untracked', untracked)
                                call s:AddSection('Unstaged', unstaged)
                                let unstaged_end = len(unstaged) ? line('$') : 0
                                call s:AddSection('Staged', staged)
                                let staged_end = len(staged) ? line('$') : 0
                            
                                if len(pull) && get(props, 'branch.ab') !~# ' -0$'
                                  call s:AddSection('Unpulled from ' . pull, s:QueryLog(head . '..' . pull))
                                endif
                                if len(push) && push !=# pull
                                  call s:AddSection('Unpulled from ' . push, s:QueryLog(head . '..' . push))
                                endif
                                if len(pull) && push !=# pull
                                  call s:AddSection('Unpushed to ' . pull, s:QueryLog(pull . '..' . head))
                                endif
                                if len(push) && !(push ==# pull && get(props, 'branch.ab') =~# '^+0 ')
                                  call s:AddSection('Unpushed to ' . push, s:QueryLog(push . '..' . head))
                                endif
                            
                                setlocal nomodified readonly noswapfile
                                silent doautocmd BufReadPost
                                setlocal nomodifiable
                                if &bufhidden ==# ''
                                  setlocal bufhidden=delete
                                endif
                                let b:dispatch = ':Git fetch --all'
                                call fugitive#MapJumps()
                                call s:Map('n', '-', ":<C-U>execute <SID>Do('Toggle',0)<CR>", '<silent>')
                                call s:Map('x', '-', ":<C-U>execute <SID>Do('Toggle',1)<CR>", '<silent>')
                                call s:Map('n', 's', ":<C-U>execute <SID>Do('Stage',0)<CR>", '<silent>')
                                call s:Map('x', 's', ":<C-U>execute <SID>Do('Stage',1)<CR>", '<silent>')
                                call s:Map('n', 'u', ":<C-U>execute <SID>Do('Unstage',0)<CR>", '<silent>')
                                call s:Map('x', 'u', ":<C-U>execute <SID>Do('Unstage',1)<CR>", '<silent>')
                                call s:Map('n', 'U', ":exe <SID>EchoExec('reset', '-q')<CR>", '<silent>')
                                call s:MapMotion('gu', "exe <SID>StageJump(v:count, 'Untracked', 'Unstaged')")
                                call s:MapMotion('gU', "exe <SID>StageJump(v:count, 'Unstaged', 'Untracked')")
                                call s:MapMotion('gs', "exe <SID>StageJump(v:count, 'Staged')")
                                call s:MapMotion('gp', "exe <SID>StageJump(v:count, 'Unpushed')")
                                call s:MapMotion('gP', "exe <SID>StageJump(v:count, 'Unpulled')")
                                call s:MapMotion('gr', "exe <SID>StageJump(v:count, 'Rebasing')")
                                call s:Map('n', 'C', ":echoerr ':Gstatus C has been removed in favor of cc'<CR>", '<silent>')
                                call s:Map('n', 'a', ":<C-U>execute <SID>Do('Toggle',0)<CR>", '<silent>')
                                call s:Map('n', 'i', ":<C-U>execute <SID>NextExpandedHunk(v:count1)<CR>", '<silent>')
                                call s:Map('n', "=", ":<C-U>execute <SID>StageInline('toggle',line('.'),v:count)<CR>", '<silent>')
                                call s:Map('n', "<", ":<C-U>execute <SID>StageInline('hide',  line('.'),v:count)<CR>", '<silent>')
                                call s:Map('n', ">", ":<C-U>execute <SID>StageInline('show',  line('.'),v:count)<CR>", '<silent>')
                                call s:Map('x', "=", ":<C-U>execute <SID>StageInline('toggle',line(\"'<\"),line(\"'>\")-line(\"'<\")+1)<CR>", '<silent>')
                                call s:Map('x', "<", ":<C-U>execute <SID>StageInline('hide',  line(\"'<\"),line(\"'>\")-line(\"'<\")+1)<CR>", '<silent>')
                                call s:Map('x', ">", ":<C-U>execute <SID>StageInline('show',  line(\"'<\"),line(\"'>\")-line(\"'<\")+1)<CR>", '<silent>')
                                call s:Map('n', 'D', ":<C-U>execute <SID>StageDiff('Gdiffsplit')<Bar>redraw<Bar>echohl WarningMsg<Bar> echo ':Gstatus D is deprecated in favor of dd'<Bar>echohl NONE<CR>", '<silent>')
                                call s:Map('n', 'dd', ":<C-U>execute <SID>StageDiff('Gdiffsplit')<CR>", '<silent>')
                                call s:Map('n', 'dh', ":<C-U>execute <SID>StageDiff('Ghdiffsplit')<CR>", '<silent>')
                                call s:Map('n', 'ds', ":<C-U>execute <SID>StageDiff('Ghdiffsplit')<CR>", '<silent>')
                                call s:Map('n', 'dp', ":<C-U>execute <SID>StageDiffEdit()<CR>", '<silent>')
                                call s:Map('n', 'dv', ":<C-U>execute <SID>StageDiff('Gvdiffsplit')<CR>", '<silent>')
                                call s:Map('n', 'd?', ":<C-U>help fugitive_d<CR>", '<silent>')
                                call s:Map('n', 'P', ":<C-U>execute <SID>StagePatch(line('.'),line('.')+v:count1-1)<CR>", '<silent>')
                                call s:Map('x', 'P', ":<C-U>execute <SID>StagePatch(line(\"'<\"),line(\"'>\"))<CR>", '<silent>')
                                call s:Map('n', 'p', ":<C-U>if v:count<Bar>silent exe <SID>GF('pedit')<Bar>else<Bar>echoerr 'Use = for inline diff, P for :Git add/reset --patch, 1p for :pedit'<Bar>endif<CR>", '<silent>')
                                call s:Map('x', 'p', ":<C-U>execute <SID>StagePatch(line(\"'<\"),line(\"'>\"))<CR>", '<silent>')
                                call s:Map('n', 'I', ":<C-U>execute <SID>StagePatch(line('.'),line('.'))<CR>", '<silent>')
                                call s:Map('x', 'I', ":<C-U>execute <SID>StagePatch(line(\"'<\"),line(\"'>\"))<CR>", '<silent>')
                                if empty(mapcheck('q', 'n'))
                                  nnoremap <buffer> <silent> q :<C-U>if bufnr('$') == 1<Bar>quit<Bar>else<Bar>bdelete<Bar>endif<Bar>echohl WarningMsg<Bar>echo ':Gstatus q is deprecated in favor of gq or the built-in <Lt>C-W>q'<Bar>echohl NONE<CR>
                                endif
                                call s:Map('n', 'gq', ":<C-U>if bufnr('$') == 1<Bar>quit<Bar>else<Bar>bdelete<Bar>endif<CR>", '<silent>')
                                call s:Map('n', 'R', ":echohl WarningMsg<Bar>echo 'Reloading is automatic.  Use :e to force'<Bar>echohl NONE<CR>", '<silent>')
                                call s:Map('n', 'g<Bar>', ":<C-U>echoerr 'Changed to X'<CR>", '<silent>')
                                call s:Map('x', 'g<Bar>', ":<C-U>echoerr 'Changed to X'<CR>", '<silent>')
                                call s:Map('n', 'X', ":<C-U>execute <SID>StageDelete(line('.'), 0, v:count)<CR>", '<silent>')
                                call s:Map('x', 'X', ":<C-U>execute <SID>StageDelete(line(\"'<\"), line(\"'>\"), v:count)<CR>", '<silent>')
                                call s:Map('n', 'gI', ":<C-U>execute <SID>StageIgnore(line('.'), line('.'), v:count)<CR>", '<silent>')
                                call s:Map('x', 'gI', ":<C-U>execute <SID>StageIgnore(line(\"'<\"), line(\"'>\"), v:count)<CR>", '<silent>')
                                call s:Map('n', '.', ':<C-U> <C-R>=<SID>StageArgs(0)<CR><Home>')
                                call s:Map('x', '.', ':<C-U> <C-R>=<SID>StageArgs(1)<CR><Home>')
                                setlocal filetype=fugitive
                            
                                for [lnum, section] in [[staged_end, 'Staged'], [unstaged_end, 'Unstaged']]
                                  while len(getline(lnum))
                                    let filename = matchstr(getline(lnum), '^[A-Z?] \zs.*')
                                    if has_key(expanded[section], filename)
                                      call s:StageInline('show', lnum)
                                    endif
                                    let lnum -= 1
                                  endwhile
                                endfor
                            
                                let b:fugitive_reltime = reltime()
                                return 'silent ' . s:DoAutocmd('User FugitiveIndex')
                              catch /^fugitive:/
                                return 'echoerr ' . string(v:exception)
                              endtry
                            endfunction
                            
    1              0.000015 function! fugitive#FileReadCmd(...) abort
                              let amatch = a:0 ? a:1 : expand('<amatch>')
                              let [dir, rev] = s:DirRev(amatch)
                              let line = a:0 > 1 ? a:2 : line("'[")
                              if empty(dir)
                                return 'noautocmd ' . line . 'read ' . s:fnameescape(amatch)
                              endif
                              if rev !~# ':' && s:ChompDefault('', [dir, 'cat-file', '-t', rev]) =~# '^\%(commit\|tag\)$'
                                let cmd = fugitive#Prepare(dir, 'log', '--pretty=format:%B', '-1', rev, '--')
                              else
                                let cmd = fugitive#Prepare(dir, 'cat-file', '-p', rev)
                              endif
                              return line . 'read !' . escape(cmd, '!#%')
                            endfunction
                            
    1              0.000013 function! fugitive#FileWriteCmd(...) abort
                              let tmp = tempname()
                              let amatch = a:0 ? a:1 : expand('<amatch>')
                              let autype = a:0 > 1 ? 'Buf' : 'File'
                              if exists('#' . autype . 'WritePre')
                                execute s:DoAutocmd(autype . 'WritePre ' . s:fnameescape(amatch))
                              endif
                              try
                                let [dir, commit, file] = s:DirCommitFile(amatch)
                                if commit !~# '^[0-3]$' || !v:cmdbang && (line("'[") != 1 || line("']") != line('$'))
                                  return "noautocmd '[,']write" . (v:cmdbang ? '!' : '') . ' ' . s:fnameescape(amatch)
                                endif
                                silent execute "'[,']write !".fugitive#Prepare(dir, 'hash-object', '-w', '--stdin', '--').' > '.tmp
                                let sha1 = readfile(tmp)[0]
                                let old_mode = matchstr(s:SystemError([dir, 'ls-files', '--stage', '.' . file])[0], '^\d\+')
                                if empty(old_mode)
                                  let old_mode = executable(s:Tree(dir) . file) ? '100755' : '100644'
                                endif
                                let error = s:UpdateIndex(dir, [old_mode, sha1, commit, file[1:-1]])
                                if empty(error)
                                  setlocal nomodified
                                  if exists('#' . autype . 'WritePost')
                                    execute s:DoAutocmd(autype . 'WritePost ' . s:fnameescape(amatch))
                                  endif
                                  return ''
                                else
                                  return 'echoerr '.string('fugitive: '.error)
                                endif
                              finally
                                call delete(tmp)
                              endtry
                            endfunction
                            
    1              0.000005 function! fugitive#BufReadCmd(...) abort
                              let amatch = a:0 ? a:1 : expand('<amatch>')
                              try
                                let [dir, rev] = s:DirRev(amatch)
                                if empty(dir)
                                  return 'echo "Invalid Fugitive URL"'
                                endif
                                if rev =~# '^:\d$'
                                  let b:fugitive_type = 'stage'
                                else
                                  let [b:fugitive_type, exec_error] = s:ChompError([dir, 'cat-file', '-t', rev])
                                  if exec_error && rev =~# '^:0'
                                    let sha = s:ChompDefault('', dir, 'write-tree', '--prefix=' . rev[3:-1])
                                    let exec_error = empty(sha)
                                    let b:fugitive_type = exec_error ? '' : 'tree'
                                  endif
                                  if exec_error
                                    let error = b:fugitive_type
                                    unlet b:fugitive_type
                                    setlocal noswapfile
                                    if empty(&bufhidden)
                                      setlocal bufhidden=delete
                                    endif
                                    if rev =~# '^:\d:'
                                      let &l:readonly = !filewritable(fugitive#Find('.git/index', dir))
                                      return 'silent doautocmd BufNewFile'
                                    else
                                      setlocal readonly nomodifiable
                                      return 'silent doautocmd BufNewFile|echo ' . string(error)
                                    endif
                                  elseif b:fugitive_type !~# '^\%(tag\|commit\|tree\|blob\)$'
                                    return "echoerr ".string("fugitive: unrecognized git type '".b:fugitive_type."'")
                                  endif
                                  if !exists('b:fugitive_display_format') && b:fugitive_type != 'blob'
                                    let b:fugitive_display_format = +getbufvar('#','fugitive_display_format')
                                  endif
                                endif
                            
                                if b:fugitive_type !=# 'blob'
                                  setlocal nomodeline
                                endif
                            
                                setlocal noreadonly modifiable
                                let pos = getpos('.')
                                silent keepjumps %delete_
                                setlocal endofline
                            
                                try
                                  silent exe s:DoAutocmd('BufReadPre')
                                  if b:fugitive_type ==# 'tree'
                                    let b:fugitive_display_format = b:fugitive_display_format % 2
                                    if b:fugitive_display_format
                                      call s:ReplaceCmd([dir, 'ls-tree', exists('sha') ? sha : rev])
                                    else
                                      if !exists('sha')
                                        let sha = s:TreeChomp(dir, 'rev-parse', '--verify', rev, '--')
                                      endif
                                      call s:ReplaceCmd([dir, 'show', '--no-color', sha])
                                    endif
                                  elseif b:fugitive_type ==# 'tag'
                                    let b:fugitive_display_format = b:fugitive_display_format % 2
                                    if b:fugitive_display_format
                                      call s:ReplaceCmd([dir, 'cat-file', b:fugitive_type, rev])
                                    else
                                      call s:ReplaceCmd([dir, 'cat-file', '-p', rev])
                                    endif
                                  elseif b:fugitive_type ==# 'commit'
                                    let b:fugitive_display_format = b:fugitive_display_format % 2
                                    if b:fugitive_display_format
                                      call s:ReplaceCmd([dir, 'cat-file', b:fugitive_type, rev])
                                    else
                                      call s:ReplaceCmd([dir, 'show', '--no-color', '-m', '--first-parent', '--pretty=format:tree%x20%T%nparent%x20%P%nauthor%x20%an%x20<%ae>%x20%ad%ncommitter%x20%cn%x20<%ce>%x20%cd%nencoding%x20%e%n%n%s%n%n%b', rev])
                                      keepjumps 1
                                      keepjumps call search('^parent ')
                                      if getline('.') ==# 'parent '
                                        silent keepjumps delete_
                                      else
                                        silent exe (exists(':keeppatterns') ? 'keeppatterns' : '') 'keepjumps s/\m\C\%(^parent\)\@<! /\rparent /e' . (&gdefault ? '' : 'g')
                                      endif
                                      keepjumps let lnum = search('^encoding \%(<unknown>\)\=$','W',line('.')+3)
                                      if lnum
                                        silent keepjumps delete_
                                      end
                                      silent exe (exists(':keeppatterns') ? 'keeppatterns' : '') 'keepjumps 1,/^diff --git\|\%$/s/\r$//e'
                                      keepjumps 1
                                    endif
                                  elseif b:fugitive_type ==# 'stage'
                                    call s:ReplaceCmd([dir, 'ls-files', '--stage'])
                                  elseif b:fugitive_type ==# 'blob'
                                    call s:ReplaceCmd([dir, 'cat-file', b:fugitive_type, rev])
                                  endif
                                finally
                                  keepjumps call setpos('.',pos)
                                  setlocal nomodified noswapfile
                                  let modifiable = rev =~# '^:.:' && b:fugitive_type !=# 'tree'
                                  let &l:readonly = !modifiable || !filewritable(fugitive#Find('.git/index', dir))
                                  if empty(&bufhidden)
                                    setlocal bufhidden=delete
                                  endif
                                  let &l:modifiable = modifiable
                                  if b:fugitive_type !=# 'blob'
                                    setlocal filetype=git foldmethod=syntax
                                    call s:Map('n', 'a', ":<C-U>let b:fugitive_display_format += v:count1<Bar>exe fugitive#BufReadCmd(@%)<CR>", '<silent>')
                                    call s:Map('n', 'i', ":<C-U>let b:fugitive_display_format -= v:count1<Bar>exe fugitive#BufReadCmd(@%)<CR>", '<silent>')
                                  endif
                                  call fugitive#MapJumps()
                                endtry
                            
                                setlocal modifiable
                            
                                let browsex = maparg('<Plug>NetrwBrowseX', 'n')
                                let remote_check = '\Cnetrw#CheckIfRemote(\%(netrw#GX()\)\=)'
                                if browsex =~# remote_check
                                  exe 'nnoremap <silent> <buffer> <Plug>NetrwBrowseX' substitute(browsex, remote_check, '0', 'g')
                                endif
                            
                                return 'silent ' . s:DoAutocmd('BufReadPost') .
                                      \ (modifiable ? '' : '|setl nomodifiable') . '|silent ' .
                                      \ s:DoAutocmd('User Fugitive' . substitute(b:fugitive_type, '^\l', '\u&', ''))
                              catch /^fugitive:/
                                return 'echoerr ' . string(v:exception)
                              endtry
                            endfunction
                            
    1              0.000012 function! fugitive#BufWriteCmd(...) abort
                              return fugitive#FileWriteCmd(a:0 ? a:1 : expand('<amatch>'), 1)
                            endfunction
                            
    1              0.000005 function! fugitive#SourceCmd(...) abort
                              let amatch = a:0 ? a:1 : expand('<amatch>')
                              let temp = s:BlobTemp(amatch)
                              if empty(temp)
                                return 'noautocmd source ' . s:fnameescape(amatch)
                              endif
                              if !exists('g:virtual_scriptnames')
                                let g:virtual_scriptnames = {}
                              endif
                              let g:virtual_scriptnames[temp] = amatch
                              return 'source ' . s:fnameescape(temp)
                            endfunction
                            
                            " Section: Temp files
                            
    1              0.000019 if !exists('s:temp_files')
    1              0.000012   let s:temp_files = {}
    1              0.000003 endif
                            
    1              0.000010 function! s:TempState(...) abort
                              return get(s:temp_files, s:cpath(fnamemodify(a:0 ? a:1 : @%, ':p')), {})
                            endfunction
                            
    1              0.000006 function! s:TempReadPre(file) abort
                              if has_key(s:temp_files, s:cpath(a:file))
                                let dict = s:temp_files[s:cpath(a:file)]
                                setlocal nomodeline
                                setlocal bufhidden=delete
                                setlocal buftype=nowrite
                                setlocal nomodifiable
                                if len(dict.dir)
                                  let b:git_dir = dict.dir
                                  call extend(b:, {'fugitive_type': 'temp'}, 'keep')
                                endif
                              endif
                            endfunction
                            
    1              0.000005 function! s:TempReadPost(file) abort
                              if has_key(s:temp_files, s:cpath(a:file))
                                let dict = s:temp_files[s:cpath(a:file)]
                                setlocal nobuflisted
                                if has_key(dict, 'filetype') && dict.filetype !=# &l:filetype
                                  let &l:filetype = dict.filetype
                                endif
                                setlocal foldmarker=<<<<<<<,>>>>>>>
                                if empty(mapcheck('q', 'n'))
                                  nnoremap <buffer> <silent> q    :<C-U>bdelete<Bar>echohl WarningMsg<Bar>echo "Temp file q is deprecated in favor of the built-in <Lt>C-W>q"<Bar>echohl NONE<CR>
                                endif
                                if !&modifiable
                                  call s:Map('n', 'gq', ":<C-U>bdelete<CR>", '<silent> <unique>')
                                endif
                              endif
                              return ''
                            endfunction
                            
    1              0.000009 augroup fugitive_temp
    1              0.000305   autocmd!
    1              0.000020   autocmd BufReadPre  * exe s:TempReadPre( expand('<amatch>:p'))
    1              0.000009   autocmd BufReadPost * exe s:TempReadPost(expand('<amatch>:p'))
    1              0.000003 augroup END
                            
                            " Section: :Git
                            
    1              0.000008 function! s:AskPassArgs(dir) abort
                              if (len($DISPLAY) || len($TERM_PROGRAM) || has('gui_running')) && fugitive#GitVersion(1, 8) &&
                                    \ empty($GIT_ASKPASS) && empty($SSH_ASKPASS) && empty(FugitiveConfigGetAll('core.askpass', a:dir))
                                if s:executable(s:ExecPath() . '/git-gui--askpass')
                                  return ['-c', 'core.askPass=' . s:ExecPath() . '/git-gui--askpass']
                                elseif s:executable('ssh-askpass')
                                  return ['-c', 'core.askPass=ssh-askpass']
                                endif
                              endif
                              return []
                            endfunction
                            
    1              0.000005 function! s:RunJobs() abort
                              return exists('*job_start') || exists('*jobstart')
                            endfunction
                            
    1              0.000005 function! s:RunEdit(state, job) abort
                              if get(a:state, 'request', '') == 'edit'
                                call remove(a:state, 'request')
                                let file = readfile(a:state.temp . '.edit')[0]
                                exe substitute(a:state.mods, '\<tab\>', '-tab', 'g') 'keepalt split' s:fnameescape(file)
                                set bufhidden=wipe
                                let s:edit_jobs[bufnr('')] = [a:state, a:job]
                                return 1
                              endif
                            endfunction
                            
    1              0.000006 function! s:RunReceive(state, job, data, ...) abort
                              call add(a:state.log, a:data)
                              let data = type(a:data) == type([]) ? join(a:data, "\n") : a:data
                              if has_key(a:state, 'buffer')
                                let data = remove(a:state, 'buffer') . data
                              endif
                              let escape = "\033]51;[^\007]*"
                              let a:state.escape_buffer = matchstr(data, escape . '$')
                              if len(a:state.escape_buffer)
                                let data = strpart(data, 0, len(data) - len(a:state.escape_buffer))
                              endif
                              let cmd = matchstr(data, escape . "\007")[5:-2]
                              let data = substitute(data, escape . "\007", '', 'g')
                              if cmd =~# '^fugitive:'
                                let a:state.request = strpart(cmd, 9)
                              endif
                              let data = a:state.echo_buffer . data
                              let a:state.echo_buffer = matchstr(data, "[\r\n]\\+$")
                              if len(a:state.echo_buffer)
                                let data = strpart(data, 0, len(data) - len(a:state.echo_buffer))
                              endif
                              echon substitute(data, "\r\\ze\n", '', 'g')
                            endfunction
                            
    1              0.000005 function! s:RunSend(job, str) abort
                              try
                                if type(a:job) == type(0)
                                  call chansend(a:job, a:str)
                                else
                                  call ch_sendraw(a:job, a:str)
                                endif
                                return len(a:str)
                              catch /^Vim\%((\a\+)\)\=:E90[06]:/
                                return 0
                              endtry
                            endfunction
                            
    1              0.000011 if !exists('s:edit_jobs')
    1              0.000014   let s:edit_jobs = {}
    1              0.000003 endif
    1              0.000005 function! s:RunWait(state, job) abort
                              let finished = 0
                              try
                                while get(a:state, 'request', '') !=# 'edit' && (type(a:job) == type(0) ? jobwait([a:job], 1)[0] == -1 : ch_status(a:job) !=# 'closed' || job_status(a:job) ==# 'run')
                                  if !exists('*jobwait')
                                    sleep 1m
                                  endif
                                  if !get(a:state, 'closed')
                                    let peek = getchar(1)
                                    if peek != 0 && !(has('win32') && peek == 128)
                                      let c = getchar()
                                      let c = type(c) == type(0) ? nr2char(c) : c
                                      if c ==# "\<C-D>"
                                        let a:state.closed = 1
                                        if type(a:job) ==# type(0)
                                          call chanclose(a:job, 'stdin')
                                        else
                                          call ch_close_in(a:job)
                                        endif
                                      else
                                        call s:RunSend(a:job, c)
                                        if !a:state.pty
                                          echon c
                                        endif
                                      endif
                                    endif
                                  endif
                                endwhile
                                sleep 1m
                                echo
                                call s:RunEdit(a:state, a:job)
                                let finished = 1
                              finally
                                if !finished
                                  try
                                    if a:state.pty
                                      call s:RunSend(a:job, "\<C-C>")
                                    elseif type(a:job) == type(0)
                                      call jobstop(a:job)
                                    else
                                      call job_stop(a:job)
                                    endif
                                  catch /.*/
                                  endtry
                                endif
                              endtry
                              call fugitive#ReloadStatus(a:state.dir, 1)
                              return ''
                            endfunction
                            
    1              0.000008 if !exists('s:resume_queue')
    1              0.000006   let s:resume_queue = []
    1              0.000002 endif
    1              0.000004 function! fugitive#Resume() abort
                              while len(s:resume_queue)
                                let [state, job] = remove(s:resume_queue, 0)
                                if filereadable(state.temp . '.edit')
                                  call delete(state.temp . '.edit')
                                endif
                                call s:RunWait(state, job)
                              endwhile
                            endfunction
                            
    1              0.000005 function! s:RunBufDelete(bufnr) abort
                              if has_key(s:edit_jobs, a:bufnr) |
                                call add(s:resume_queue, remove(s:edit_jobs, a:bufnr))
                                call feedkeys(":redraw!|call fugitive#Resume()|silent checktime\r", 'n')
                              endif
                            endfunction
                            
    1              0.000005 augroup fugitive_job
    1              0.000108   autocmd!
    1              0.000011   autocmd BufDelete * call s:RunBufDelete(expand('<abuf>'))
    1              0.000024   autocmd VimLeave *
                                    \ for s:jobbuf in keys(s:edit_jobs) |
                                    \   call writefile([], s:edit_jobs[s:jobbuf][0].temp . '.exit') |
                                    \   redraw! |
                                    \   call call('s:RunWait', remove(s:edit_jobs, s:jobbuf)) |
                                    \ endfor
    1              0.000003 augroup END
                            
    1              0.000006 function! fugitive#PagerFor(argv, ...) abort
                              let args = a:argv
                              if empty(args)
                                return 0
                              elseif (args[0] ==# 'help' || get(args, 1, '') ==# '--help') && !s:HasOpt(args, '--web')
                                return 1
                              endif
                              if args[0] ==# 'config' && (s:HasOpt(args, '-e', '--edit') ||
                                    \   !s:HasOpt(args, '--list', '--get-all', '--get-regexp', '--get-urlmatch')) ||
                                    \ args[0] =~# '^\%(tag\|branch\)$' && (
                                    \    s:HasOpt(args, '--edit-description', '--unset-upstream', '-m', '-M', '--move', '-c', '-C', '--copy', '-d', '-D', '--delete') ||
                                    \   len(filter(args[1:-1], 'v:val =~# "^[^-]\\|^--set-upstream-to="')) &&
                                    \   !s:HasOpt(args, '--contains', '--no-contains', '--merged', '--no-merged', '--points-at'))
                                return 0
                              endif
                              let config = a:0 ? a:1 : fugitive#Config()
                              let value = get(FugitiveConfigGetAll('pager.' . args[0], config), 0, -1)
                              if value =~# '^\%(true\|yes\|on\|1\)$'
                                return 1
                              elseif value =~# '^\%(false\|no|off\|0\|\)$'
                                return 0
                              elseif type(value) == type('')
                                return value
                              elseif args[0] =~# 'diff\%(tool\)\@!\|log\|^show$\|^config$\|^branch$\|^tag$' ||
                                    \ (args[0] ==# 'stash' && get(args, 1, '') ==# 'show') ||
                                    \ (args[0] ==# 'am' && s:HasOpt(args, '--show-current-patch'))
                                return 1
                              else
                                return 0
                              endif
                            endfunction
                            
    1              0.000007 let s:disable_colors = []
   13              0.000068 for s:colortype in ['advice', 'branch', 'diff', 'grep', 'interactive', 'pager', 'push', 'remote', 'showBranch', 'status', 'transport', 'ui']
   12              0.000177   call extend(s:disable_colors, ['-c', 'color.' . s:colortype . '=false'])
   13              0.000024 endfor
    1              0.000007 unlet s:colortype
    1              0.000009 function! fugitive#Command(line1, line2, range, bang, mods, arg) abort
                              let dir = s:Dir()
                              let config = copy(fugitive#Config(dir))
                              let [args, after] = s:SplitExpandChain(a:arg, s:Tree(dir))
                              let flags = []
                              let pager = -1
                              while len(args)
                                if args[0] ==# '-c' && len(args) > 1
                                  call extend(flags, remove(args, 0, 1))
                                elseif args[0] =~# '^-p$\|^--paginate$'
                                  let pager = 1
                                  call remove(args, 0)
                                elseif args[0] =~# '^-P$\|^--no-pager$'
                                  let pager = 0
                                  call remove(args, 0)
                                elseif args[0] =~# '^--\%([[:lower:]-]\+-pathspecs\|no-optional-locks\)$'
                                  call add(flags, remove(args, 0))
                                elseif args[0] =~# '^-C$\|^--\%(exec-path=\|git-dir=\|work-tree=\|bare$\)'
                                  return 'echoerr ' . string('fugitive: ' . args[0] . ' is not supported')
                                else
                                  break
                                endif
                              endwhile
                              if pager is# 0
                                call add(flags, '--no-pager')
                              endif
                              if empty(args) && pager is# -1
                                let cmd = s:StatusCommand(a:line1, a:line2, a:range, a:line2, a:bang, a:mods, '', '', [])
                                return (empty(cmd) ? 'exe' : cmd) . after
                              endif
                              let alias = fugitive#Config('alias.' . get(args, 0, ''), config)
                              if get(args, 1, '') !=# '--help' && alias !~# '^$\|^!\|[\"'']' && !filereadable(s:ExecPath() . '/git-' . args[0])
                                    \ && !(has('win32') && filereadable(s:ExecPath() . '/git-' . args[0] . '.exe'))
                                call remove(args, 0)
                                call extend(args, split(alias, '\s\+'), 'keep')
                              endif
                              let name = substitute(get(args, 0, ''), '\%(^\|-\)\(\l\)', '\u\1', 'g')
                              let git = split(get(g:, 'fugitive_git_command', g:fugitive_git_executable), '\s\+')
                              let options = {'git': git, 'dir': dir, 'flags': flags}
                              if pager is# -1 && exists('*s:' . name . 'Subcommand') && get(args, 1, '') !=# '--help'
                                try
                                  let overrides = s:{name}Subcommand(a:line1, a:line2, a:range, a:bang, a:mods, extend({'command': args[0], 'args': args[1:-1]}, options))
                                  if type(overrides) == type('')
                                    return 'exe ' . string(overrides) . after
                                  endif
                                  let args = [get(overrides, 'command', args[0])] + get(overrides, 'insert_args', []) + args[1:-1]
                                catch /^fugitive:/
                                  return 'echoerr ' . string(v:exception)
                                endtry
                              else
                                let overrides = {}
                              endif
                              let env = get(overrides, 'env', {})
                              let i = 0
                              while i < len(flags) - 1
                                if flags[i] ==# '-c'
                                  let i += 1
                                  let config_name = tolower(matchstr(flags[i], '^[^=]\+'))
                                  if has_key(s:prepare_env, config_name) && flags[i] =~# '=.'
                                    let env[s:prepare_env[config_name]] = matchstr(flags[i], '=\zs.*')
                                  endif
                                  if flags[i] =~# '='
                                    let config[config_name] = [matchstr(flags[i], '=\zs.*')]
                                  else
                                    let config[config_name] = [1]
                                  endif
                                endif
                                let i += 1
                              endwhile
                              let editcmd = a:line2 ? 'split' : 'edit'
                              if pager is# 1
                                if a:bang && a:line2 >= 0
                                  let editcmd = 'read'
                                elseif a:bang
                                  let editcmd = 'pedit'
                                endif
                              elseif pager is# -1
                                let pager = fugitive#PagerFor(args, config)
                                if a:bang && pager isnot# 1
                                  return 'echoerr ' .  string('fugitive: :Git! for temp buffer output has been replaced by :Git --paginate')
                                endif
                              endif
                              if pager is# 1
                                if editcmd ==# 'read'
                                  return s:ReadExec(a:line1, a:line2, a:range, a:mods, env, args, options) . after
                                else
                                  return s:OpenExec(editcmd, a:mods, env, args, options) . after
                                endif
                              endif
                              if s:HasOpt(args, ['add', 'checkout', 'commit', 'stage', 'stash', 'reset'], '-p', '--patch') ||
                                    \ s:HasOpt(args, ['add', 'clean', 'stage'], '-i', '--interactive') ||
                                    \ type(pager) == type('')
                                let mods = substitute(s:Mods(a:mods), '\<tab\>', '-tab', 'g')
                                let assign = len(dir) ? '|let b:git_dir = ' . string(dir) : ''
                                if has('nvim')
                                  if &autowrite || &autowriteall | silent! wall | endif
                                  return mods . (a:line2 ? 'split' : 'edit') . ' term://' . s:fnameescape(s:UserCommand(options, args)) . assign . '|startinsert' . after
                                elseif has('terminal')
                                  if &autowrite || &autowriteall | silent! wall | endif
                                  return 'exe ' . string(mods . 'terminal ' . (a:line2 ? '' : '++curwin ') . join(map(s:UserCommandList(options) + args, 's:fnameescape(v:val)'))) . assign . after
                                endif
                              endif
                              if s:RunJobs()
                                let state = {
                                      \ 'dir': dir,
                                      \ 'mods': s:Mods(a:mods),
                                      \ 'title': ':Git ' . a:arg,
                                      \ 'echo_buffer': '',
                                      \ 'escape_buffer': '',
                                      \ 'log': [],
                                      \ 'temp': tempname()}
                                let state.pty = get(g:, 'fugitive_pty', has('unix') && (has('patch-8.0.0744') || has('nvim')))
                                if !state.pty
                                  let args = s:AskPassArgs(dir) + args
                                endif
                                let env.FUGITIVE_TEMP = state.temp
                                let editor = 'sh ' . s:TempScript(
                                      \ '[ -f "$FUGITIVE_TEMP.exit" ] && exit 1',
                                      \ 'echo "$1" > "$FUGITIVE_TEMP.edit"',
                                      \ 'printf "\033]51;fugitive:edit\007"',
                                      \ 'while [ -f "$FUGITIVE_TEMP.edit" -a ! -f "$FUGITIVE_TEMP.exit" ]; do sleep 0.05 2>/dev/null || sleep 1; done',
                                      \ 'exit 0')
                                call extend(env, {
                                      \ 'NO_COLOR': '1',
                                      \ 'GIT_EDITOR': editor,
                                      \ 'GIT_SEQUENCE_EDITOR': editor,
                                      \ 'GIT_MERGE_AUTOEDIT': '1',
                                      \ 'GIT_PAGER': 'cat',
                                      \ 'PAGER': 'cat'}, 'keep')
                                let args = s:disable_colors + flags + ['-c', 'advice.waitingForEditor=false'] + args
                                let argv = s:UserCommandList({'git': git, 'dir': dir}) + args
                                let [argv, jobopts] = s:JobOpts(argv, env)
                                let state.cmd = argv
                                let g:_fugitive_last_job = state
                                if &autowrite || &autowriteall | silent! wall | endif
                                if exists('*job_start')
                                  call extend(jobopts, {
                                        \ 'mode': 'raw',
                                        \ 'callback': function('s:RunReceive', [state]),
                                        \ })
                                  if state.pty
                                    let jobopts.pty = 1
                                  endif
                                  let job = job_start(argv, jobopts)
                                else
                                  let job = jobstart(argv, extend(jobopts, {
                                        \ 'pty': state.pty,
                                        \ 'TERM': 'dumb',
                                        \ 'on_stdout': function('s:RunReceive', [state]),
                                        \ 'on_stderr': function('s:RunReceive', [state]),
                                        \ }))
                                endif
                                let state.job = job
                                call s:RunWait(state, job)
                                return 'silent checktime' . after
                              elseif has('win32')
                                return 'echoerr ' . string('fugitive: Vim 8 with job support required to use :Git on Windows')
                              elseif has('gui_running')
                                return 'echoerr ' . string('fugitive: Vim 8 with job support required to use :Git in GVim')
                              else
                                let pre = s:BuildEnvPrefix(env)
                                return 'exe ' . string('noautocmd !' . escape(pre . s:UserCommand(options, args), '!#%')) .
                                      \ '|call fugitive#ReloadStatus(' . string(dir) . ', 1)' .
                                      \ after
                              endif
                            endfunction
                            
    1              0.000010 let s:exec_paths = {}
    1              0.000008 function! s:ExecPath() abort
                              if !has_key(s:exec_paths, g:fugitive_git_executable)
                                let s:exec_paths[g:fugitive_git_executable] = s:sub(system(g:fugitive_git_executable.' --exec-path'),'\n$','')
                              endif
                              return s:exec_paths[g:fugitive_git_executable]
                            endfunction
                            
    1              0.000005 function! s:Subcommands() abort
                              let exec_path = s:ExecPath()
                              return map(split(glob(exec_path.'/git-*'),"\n"),'s:sub(v:val[strlen(exec_path)+5 : -1],"\\.exe$","")')
                            endfunction
                            
    1              0.000006 let s:aliases = {}
    1              0.000005 function! s:Aliases(dir) abort
                              let dir_key = len(a:dir) ? a:dir : '_'
                              if !has_key(s:aliases, dir_key)
                                let s:aliases[dir_key] = {}
                                let lines = s:NullError([a:dir, 'config', '-z', '--get-regexp', '^alias[.]'])[0]
                                for line in lines
                                  let s:aliases[dir_key][matchstr(line, '\.\zs.\{-}\ze\n')] = matchstr(line, '\n\zs.*')
                                endfor
                              endif
                              return s:aliases[dir_key]
                            endfunction
                            
    1              0.000005 function! fugitive#Complete(lead, ...) abort
                              let dir = a:0 == 1 ? a:1 : a:0 >= 3 ? a:3 : s:Dir()
                              let root = a:0 >= 4 ? a:4 : s:Tree(s:Dir())
                              let pre = a:0 > 1 ? strpart(a:1, 0, a:2) : ''
                              let subcmd = matchstr(pre, '\u\w*[! ] *\zs[[:alnum:]-]\+\ze ')
                              if empty(subcmd)
                                let results = sort(s:Subcommands() + keys(s:Aliases(dir)))
                              elseif a:0 ==# 2 && subcmd =~# '^\%(commit\|revert\|push\|fetch\|pull\|merge\|rebase\)$'
                                let cmdline = substitute(a:1, '\u\w*\([! ] *\)' . subcmd, 'G' . subcmd, '')
                                let caps_subcmd = substitute(subcmd, '\%(^\|-\)\l', '\u&', 'g')
                                return fugitive#{caps_subcmd}Complete(a:lead, cmdline, a:2 + len(cmdline) - len(a:1), dir, root)
                              elseif pre =~# ' -- '
                                return fugitive#CompletePath(a:lead, a:1, a:2, dir, root)
                              elseif a:lead =~# '^-'
                                let results = split(s:ChompDefault('', dir, subcmd, '--git-completion-helper'), ' ')
                              else
                                return fugitive#CompleteObject(a:lead, a:1, a:2, dir, root)
                              endif
                              return filter(results, 'strpart(v:val, 0, strlen(a:lead)) ==# a:lead')
                            endfunction
                            
    1              0.000008 function! fugitive#CompleteForWorkingDir(A, L, P, ...) abort
                              let path = a:0 ? a:1 : getcwd()
                              return fugitive#Complete(a:A, a:L, a:P, FugitiveExtractGitDir(path), path)
                            endfunction
                            
                            " Section: :Gcd, :Glcd
                            
    1              0.000006 function! fugitive#CdComplete(A, L, P) abort
                              return filter(fugitive#CompletePath(a:A), 'v:val =~# "/$"')
                            endfunction
                            
    1              0.000004 function! fugitive#Cd(path, ...) abort
                              let path = substitute(a:path, '^:/:\=\|^:(\%(top\|top,literal\|literal,top\|literal\))', '', '')
                              if path !~# '^/\|^\a\+:\|^\.\.\=\%(/\|$\)'
                                let dir = s:Dir()
                                exe s:DirCheck(dir)
                                let path = (empty(s:Tree(dir)) ? dir : s:Tree(dir)) . '/' . path
                              endif
                              return (a:0 && a:1 ? 'lcd ' : 'cd ') . s:fnameescape(FugitiveVimPath(path))
                            endfunction
                            
                            " Section: :Gstatus
                            
    1              0.000010 function! s:StatusCommand(line1, line2, range, count, bang, mods, reg, arg, args, ...) abort
                              let dir = a:0 ? a:1 : s:Dir()
                              exe s:DirCheck(dir)
                              try
                                let mods = s:Mods(a:mods, &splitbelow ? 'botright' : 'topleft')
                                let file = fugitive#Find(':', dir)
                                let arg = ' +setl\ foldmethod=syntax\ foldlevel=1\|let\ w:fugitive_status=FugitiveGitDir() ' .
                                      \ s:fnameescape(file)
                                for winnr in range(1, winnr('$'))
                                  if s:cpath(file, fnamemodify(bufname(winbufnr(winnr)), ':p'))
                                    if winnr == winnr()
                                      call s:ReloadStatus()
                                    else
                                      call s:ExpireStatus(dir)
                                      exe winnr . 'wincmd w'
                                    endif
                                    let w:fugitive_status = dir
                                    1
                                    return ''
                                  endif
                                endfor
                                if a:count ==# 0
                                  return mods . 'edit' . (a:bang ? '!' : '') . arg
                                elseif a:bang
                                  return mods . 'pedit' . arg . '|wincmd P'
                                else
                                  return mods . 'keepalt split' . arg
                                endif
                              catch /^fugitive:/
                                return 'echoerr ' . string(v:exception)
                              endtry
                              return ''
                            endfunction
                            
    1              0.000011 function! s:StageJump(offset, section, ...) abort
                              let line = search('^\%(' . a:section . '\)', 'nw')
                              if !line && a:0
                                let line = search('^\%(' . a:1 . '\)', 'nw')
                              endif
                              if line
                                exe line
                                if a:offset
                                  for i in range(a:offset)
                                    call search(s:file_commit_pattern . '\|^$', 'W')
                                    if empty(getline('.')) && a:0 && getline(line('.') + 1) =~# '^\%(' . a:1 . '\)'
                                      call search(s:file_commit_pattern . '\|^$', 'W')
                                    endif
                                    if empty(getline('.'))
                                      return ''
                                    endif
                                  endfor
                                  call s:StageReveal()
                                else
                                  call s:StageReveal()
                                  +
                                endif
                              endif
                              return ''
                            endfunction
                            
    1              0.000018 function! s:StageSeek(info, fallback) abort
                              let info = a:info
                              if empty(info.section)
                                return a:fallback
                              endif
                              let line = search('^' . info.section, 'wn')
                              if !line
                                for section in get({'Staged': ['Unstaged', 'Untracked'], 'Unstaged': ['Untracked', 'Staged'], 'Untracked': ['Unstaged', 'Staged']}, info.section, [])
                                  let line = search('^' . section, 'wn')
                                  if line
                                    return line + (info.index > 0 ? 1 : 0)
                                  endif
                                endfor
                                return 1
                              endif
                              let i = 0
                              while len(getline(line))
                                let filename = matchstr(getline(line), '^[A-Z?] \zs.*')
                                if len(filename) &&
                                      \ ((info.filename[-1:-1] ==# '/' && filename[0 : len(info.filename) - 1] ==# info.filename) ||
                                      \ (filename[-1:-1] ==# '/' && filename ==# info.filename[0 : len(filename) - 1]) ||
                                      \ filename ==# info.filename)
                                  if info.offset < 0
                                    return line
                                  else
                                    if getline(line+1) !~# '^@'
                                      exe s:StageInline('show', line)
                                    endif
                                    if getline(line+1) !~# '^@'
                                      return line
                                    endif
                                    let type = info.sigil ==# '-' ? '-' : '+'
                                    let offset = -1
                                    while offset < info.offset
                                      let line += 1
                                      if getline(line) =~# '^@'
                                        let offset = +matchstr(getline(line), type . '\zs\d\+') - 1
                                      elseif getline(line) =~# '^[ ' . type . ']'
                                        let offset += 1
                                      elseif getline(line) !~# '^[ @\+-]'
                                        return line - 1
                                      endif
                                    endwhile
                                    return line
                                  endif
                                endif
                                let commit = matchstr(getline(line), '^\%(\%(\x\x\x\)\@!\l\+\s\+\)\=\zs[0-9a-f]\+')
                                if len(commit) && commit ==# info.commit
                                  return line
                                endif
                                if i ==# info.index
                                  let backup = line
                                endif
                                let i += getline(line) !~# '^[ @\+-]'
                                let line += 1
                              endwhile
                              return exists('backup') ? backup : line - 1
                            endfunction
                            
    1              0.000021 function! s:DoAutocmdChanged(dir) abort
                              let dir = a:dir is# -2 ? '' : FugitiveGitDir(a:dir)
                              if empty(dir) || !exists('#User#FugitiveChanged') || exists('g:fugitive_event')
                                return ''
                              endif
                              try
                                let g:fugitive_event = dir
                                exe s:DoAutocmd('User FugitiveChanged')
                              finally
                                unlet! g:fugitive_event
                                " Force statusline reload with the buffer's Git dir
                                let &ro = &ro
                              endtry
                              return ''
                            endfunction
                            
    1              0.000006 function! s:ReloadStatusBuffer(...) abort
                              if get(b:, 'fugitive_type', '') !=# 'index'
                                return ''
                              endif
                              let original_lnum = a:0 ? a:1 : line('.')
                              let info = s:StageInfo(original_lnum)
                              call fugitive#BufReadStatus()
                              exe s:StageSeek(info, original_lnum)
                              normal! 0
                              return ''
                            endfunction
                            
    1              0.000005 function! s:ReloadStatus(...) abort
                              call s:ExpireStatus(-1)
                              call s:ReloadStatusBuffer(a:0 ? a:1 : line('.'))
                              exe s:DoAutocmdChanged(-1)
                              return ''
                            endfunction
                            
    1              0.000021 let s:last_time = reltime()
    1              0.000013 if !exists('s:last_times')
    1              0.000008   let s:last_times = {}
    1              0.000003 endif
                            
    1              0.000006 function! s:ExpireStatus(bufnr) abort
                              if a:bufnr == -2
                                let s:head_cache = {}
                                let s:last_time = reltime()
                                return ''
                              endif
                              let dir = s:Dir(a:bufnr)
                              if len(dir)
                                let s:last_times[s:cpath(dir)] = reltime()
                                if has_key(s:head_cache, dir)
                                  call remove(s:head_cache, dir)
                                endif
                              endif
                              return ''
                            endfunction
                            
    1              0.000004 function! s:ReloadWinStatus(...) abort
                              if get(b:, 'fugitive_type', '') !=# 'index' || &modified
                                return
                              endif
                              if !exists('b:fugitive_reltime')
                                exe s:ReloadStatusBuffer()
                                return
                              endif
                              let t = b:fugitive_reltime
                              if reltimestr(reltime(s:last_time, t)) =~# '-\|\d\{10\}\.' ||
                                    \ reltimestr(reltime(get(s:last_times, s:cpath(s:Dir()), t), t)) =~# '-\|\d\{10\}\.'
                                exe s:ReloadStatusBuffer()
                              endif
                            endfunction
                            
    1              0.000005 function! s:ReloadTabStatus(...) abort
                              let mytab = tabpagenr()
                              let tab = a:0 ? a:1 : mytab
                              for winnr in range(1, tabpagewinnr(tab, '$'))
                                if getbufvar(tabpagebuflist(tab)[winnr-1], 'fugitive_type') ==# 'index'
                                  execute 'tabnext '.tab
                                  if winnr != winnr()
                                    execute winnr.'wincmd w'
                                    let restorewinnr = 1
                                  endif
                                  try
                                    call s:ReloadWinStatus()
                                  finally
                                    if exists('restorewinnr')
                                      unlet restorewinnr
                                      wincmd p
                                    endif
                                    execute 'tabnext '.mytab
                                  endtry
                                endif
                              endfor
                              unlet! t:fugitive_reload_status
                            endfunction
                            
    1              0.000005 function! fugitive#ReloadStatus(...) abort
                              call s:ExpireStatus(a:0 ? a:1 : -1)
                              if a:0 > 1 ? a:2 : 1
                                let t = reltime()
                                let t:fugitive_reload_status = t
                                for tabnr in exists('*settabvar') ? range(1, tabpagenr('$')) : []
                                  call settabvar(tabnr, 'fugitive_reload_status', t)
                                endfor
                                call s:ReloadTabStatus()
                                exe s:DoAutocmdChanged(a:0 ? a:1 : -1)
                              else
                                call s:ReloadWinStatus()
                              endif
                              return ''
                            endfunction
                            
    1              0.000004 function! fugitive#EfmDir(...) abort
                              let dir = matchstr(a:0 ? a:1 : &errorformat, '\c,%\\&\%(git\|fugitive\)_\=dir=\zs\%(\\.\|[^,]\)*')
                              let dir = substitute(dir, '%%', '%', 'g')
                              let dir = substitute(dir, '\\\ze[\,]', '', 'g')
                              return dir
                            endfunction
                            
    1              0.000011 augroup fugitive_status
    1              0.000350   autocmd!
    1              0.000022   autocmd BufWritePost         * call fugitive#ReloadStatus(-1, 0)
    1              0.000017   autocmd ShellCmdPost,ShellFilterPost * nested call fugitive#ReloadStatus(-2, 0)
    1              0.000038   autocmd BufDelete * nested
                                    \ if getbufvar(+expand('<abuf>'), 'buftype') ==# 'terminal' |
                                    \   if !empty(FugitiveGitDir(+expand('<abuf>'))) |
                                    \     call fugitive#ReloadStatus(+expand('<abuf>'), 1) |
                                    \   else |
                                    \     call fugitive#ReloadStatus(-2, 0) |
                                    \  endif |
                                    \ endif
    1              0.000037   autocmd QuickFixCmdPost make,lmake,[cl]file,[cl]getfile nested
                                    \ call fugitive#ReloadStatus(fugitive#EfmDir(), 1)
    1              0.000016   if !has('win32')
    1              0.000011     autocmd FocusGained        * call fugitive#ReloadStatus(-2, 0)
    1              0.000003   endif
    1              0.000019   autocmd BufEnter index,index.lock
                                    \ call s:ReloadWinStatus()
    1              0.000014   autocmd TabEnter *
                                    \ if exists('t:fugitive_reload_status') |
                                    \    call s:ReloadTabStatus() |
                                    \ endif
    1              0.000003 augroup END
                            
    1              0.000006 function! s:StageInfo(...) abort
                              let lnum = a:0 ? a:1 : line('.')
                              let sigil = matchstr(getline(lnum), '^[ @\+-]')
                              let offset = -1
                              if len(sigil)
                                let type = sigil ==# '-' ? '-' : '+'
                                while lnum > 0 && getline(lnum) !~# '^@'
                                  if getline(lnum) =~# '^[ '.type.']'
                                    let offset += 1
                                  endif
                                  let lnum -= 1
                                endwhile
                                let offset += matchstr(getline(lnum), type.'\zs\d\+')
                                while getline(lnum) =~# '^[ @\+-]'
                                  let lnum -= 1
                                endwhile
                              endif
                              let slnum = lnum + 1
                              let section = ''
                              let index = 0
                              while len(getline(slnum - 1)) && empty(section)
                                let slnum -= 1
                                let section = matchstr(getline(slnum), '^\u\l\+\ze.* (\d\+)$')
                                if empty(section) && getline(slnum) !~# '^[ @\+-]'
                                  let index += 1
                                endif
                              endwhile
                              let text = matchstr(getline(lnum), '^[A-Z?] \zs.*')
                              return {'section': section,
                                    \ 'heading': getline(slnum),
                                    \ 'sigil': sigil,
                                    \ 'offset': offset,
                                    \ 'filename': text,
                                    \ 'relative': reverse(split(text, ' -> ')),
                                    \ 'paths': map(reverse(split(text, ' -> ')), 's:Tree() . "/" . v:val'),
                                    \ 'commit': matchstr(getline(lnum), '^\%(\%(\x\x\x\)\@!\l\+\s\+\)\=\zs[0-9a-f]\{4,\}\ze '),
                                    \ 'status': matchstr(getline(lnum), '^[A-Z?]\ze \|^\%(\x\x\x\)\@!\l\+\ze [0-9a-f]'),
                                    \ 'sub': get(get(get(b:fugitive_files, section, {}), text, {}), 'sub', ''),
                                    \ 'index': index}
                            endfunction
                            
    1              0.000006 function! s:Selection(arg1, ...) abort
                              if a:arg1 ==# 'n'
                                let arg1 = line('.')
                                let arg2 = -v:count
                              elseif a:arg1 ==# 'v'
                                let arg1 = line("'<")
                                let arg2 = line("'>")
                              else
                                let arg1 = a:arg1
                                let arg2 = a:0 ? a:1 : 0
                              endif
                              let first = arg1
                              if arg2 < 0
                                let last = first - arg2 - 1
                              elseif arg2 > 0
                                let last = arg2
                              else
                                let last = first
                              endif
                              while getline(first) =~# '^$\|^[A-Z][a-z]'
                                let first += 1
                              endwhile
                              if first > last || &filetype !=# 'fugitive'
                                return []
                              endif
                              let flnum = first
                              while getline(flnum) =~# '^[ @\+-]'
                                let flnum -= 1
                              endwhile
                              let slnum = flnum + 1
                              let section = ''
                              let index = 0
                              while len(getline(slnum - 1)) && empty(section)
                                let slnum -= 1
                                let heading = matchstr(getline(slnum), '^\u\l\+.* (\d\+)$')
                                if empty(heading) && getline(slnum) !~# '^[ @\+-]'
                                  let index += 1
                                endif
                              endwhile
                              let results = []
                              let template = {
                                    \ 'heading': heading,
                                    \ 'section': matchstr(heading, '^\u\l\+\ze.* (\d\+)$'),
                                    \ 'filename': '',
                                    \ 'relative': [],
                                    \ 'paths': [],
                                    \ 'commit': '',
                                    \ 'status': '',
                                    \ 'patch': 0,
                                    \ 'index': index}
                              let line = getline(flnum)
                              let lnum = first - (arg1 == flnum ? 0 : 1)
                              let root = s:Tree() . '/'
                              while lnum <= last
                                if line =~# '^\u\l\+\ze.* (\d\+)$'
                                  let template.heading = getline(lnum)
                                  let template.section = matchstr(template.heading, '^\u\l\+\ze.* (\d\+)$')
                                  let template.index = 0
                                elseif line =~# '^[ @\+-]'
                                  let template.index -= 1
                                  if !results[-1].patch
                                    let results[-1].patch = lnum
                                  endif
                                  let results[-1].lnum = lnum
                                elseif line =~# '^[A-Z?] '
                                  let filename = matchstr(line, '^[A-Z?] \zs.*')
                                  call add(results, extend(deepcopy(template), {
                                        \ 'lnum': lnum,
                                        \ 'filename': filename,
                                        \ 'relative': reverse(split(filename, ' -> ')),
                                        \ 'paths': map(reverse(split(filename, ' -> ')), 'root . v:val'),
                                        \ 'status': matchstr(line, '^[A-Z?]'),
                                        \ }))
                                elseif line =~# '^\x\x\x\+ '
                                  call add(results, extend({
                                        \ 'lnum': lnum,
                                        \ 'commit': matchstr(line, '^\x\x\x\+'),
                                        \ }, template, 'keep'))
                                elseif line =~# '^\l\+ \x\x\x\+ '
                                  call add(results, extend({
                                        \ 'lnum': lnum,
                                        \ 'commit': matchstr(line, '^\l\+ \zs\x\x\x\+'),
                                        \ 'status': matchstr(line, '^\l\+'),
                                        \ }, template, 'keep'))
                                endif
                                let lnum += 1
                                let template.index += 1
                                let line = getline(lnum)
                              endwhile
                              if len(results) && results[0].patch && arg2 == 0
                                while getline(results[0].patch) =~# '^[ \+-]'
                                  let results[0].patch -= 1
                                endwhile
                                while getline(results[0].lnum + 1) =~# '^[ \+-]'
                                  let results[0].lnum += 1
                                endwhile
                              endif
                              return results
                            endfunction
                            
    1              0.000005 function! s:StageArgs(visual) abort
                              let commits = []
                              let paths = []
                              for record in s:Selection(a:visual ? 'v' : 'n')
                                if len(record.commit)
                                  call add(commits, record.commit)
                                endif
                                call extend(paths, record.paths)
                              endfor
                              if s:cpath(s:Tree(), getcwd())
                                call map(paths, 'fugitive#Path(v:val, "./")')
                              endif
                              return join(map(commits + paths, 's:fnameescape(v:val)'), ' ')
                            endfunction
                            
    1              0.000005 function! s:Do(action, visual) abort
                              let line = getline('.')
                              let reload = 0
                              if !a:visual && !v:count && line =~# '^[A-Z][a-z]'
                                let header = matchstr(line, '^\S\+\ze:')
                                if len(header) && exists('*s:Do' . a:action . header . 'Header')
                                  let reload = s:Do{a:action}{header}Header(matchstr(line, ': \zs.*')) > 0
                                else
                                  let section = matchstr(line, '^\S\+')
                                  if exists('*s:Do' . a:action . section . 'Heading')
                                    let reload = s:Do{a:action}{section}Heading(line) > 0
                                  endif
                                endif
                                return reload ? s:ReloadStatus() : ''
                              endif
                              let selection = s:Selection(a:visual ? 'v' : 'n')
                              if empty(selection)
                                return ''
                              endif
                              call filter(selection, 'v:val.section ==# selection[0].section')
                              let status = 0
                              let err = ''
                              try
                                for record in selection
                                  if exists('*s:Do' . a:action . record.section)
                                    let status = s:Do{a:action}{record.section}(record)
                                  else
                                    continue
                                  endif
                                  if !status
                                    return ''
                                  endif
                                  let reload = reload || (status > 0)
                                endfor
                                if status < 0
                                  execute record.lnum + 1
                                endif
                                let success = 1
                              catch /^fugitive:/
                                return 'echoerr ' . string(v:exception)
                              finally
                                if reload
                                  execute s:ReloadStatus()
                                endif
                                if exists('success')
                                  call s:StageReveal()
                                endif
                              endtry
                              return ''
                            endfunction
                            
    1              0.000004 function! s:StageReveal() abort
                              exe 'normal! zv'
                              let begin = line('.')
                              if getline(begin) =~# '^@'
                                let end = begin + 1
                                while getline(end) =~# '^[ \+-]'
                                  let end += 1
                                endwhile
                              elseif getline(begin) =~# '^commit '
                                let end = begin
                                while end < line('$') && getline(end + 1) !~# '^commit '
                                  let end += 1
                                endwhile
                              elseif getline(begin) =~# s:section_pattern
                                let end = begin
                                while len(getline(end + 1))
                                  let end += 1
                                endwhile
                              endif
                              if exists('end')
                                while line('.') > line('w0') + &scrolloff && end > line('w$')
                                  execute "normal! \<C-E>"
                                endwhile
                              endif
                            endfunction
                            
    1              0.000009 let s:file_pattern = '^[A-Z?] .\|^diff --'
    1              0.000013 let s:file_commit_pattern = s:file_pattern . '\|^\%(\l\{3,\} \)\=[0-9a-f]\{4,\} '
    1              0.000010 let s:item_pattern = s:file_commit_pattern . '\|^@@'
                            
    1              0.000005 function! s:NextHunk(count) abort
                              if &filetype ==# 'fugitive' && getline('.') =~# s:file_pattern
                                exe s:StageInline('show')
                              endif
                              for i in range(a:count)
                                if &filetype ==# 'fugitive'
                                  call search(s:file_pattern . '\|^@', 'W')
                                  if getline('.') =~# s:file_pattern
                                    exe s:StageInline('show')
                                    if getline(line('.') + 1) =~# '^@'
                                      +
                                    endif
                                  endif
                                else
                                  call search('^@@', 'W')
                                endif
                              endfor
                              call s:StageReveal()
                              return '.'
                            endfunction
                            
    1              0.000005 function! s:PreviousHunk(count) abort
                              for i in range(a:count)
                                if &filetype ==# 'fugitive'
                                  let lnum = search(s:file_pattern . '\|^@','Wbn')
                                  call s:StageInline('show', lnum)
                                  call search('^? .\|^@','Wb')
                                else
                                  call search('^@@', 'Wb')
                                endif
                              endfor
                              call s:StageReveal()
                              return '.'
                            endfunction
                            
    1              0.000005 function! s:NextFile(count) abort
                              for i in range(a:count)
                                exe s:StageInline('hide')
                                if !search(s:file_pattern, 'W')
                                  break
                                endif
                              endfor
                              exe s:StageInline('hide')
                              return '.'
                            endfunction
                            
    1              0.000005 function! s:PreviousFile(count) abort
                              exe s:StageInline('hide')
                              for i in range(a:count)
                                if !search(s:file_pattern, 'Wb')
                                  break
                                endif
                                exe s:StageInline('hide')
                              endfor
                              return '.'
                            endfunction
                            
    1              0.000004 function! s:NextItem(count) abort
                              for i in range(a:count)
                                if !search(s:item_pattern, 'W') && getline('.') !~# s:item_pattern
                                  call search('^commit ', 'W')
                                endif
                              endfor
                              call s:StageReveal()
                              return '.'
                            endfunction
                            
    1              0.000005 function! s:PreviousItem(count) abort
                              for i in range(a:count)
                                if !search(s:item_pattern, 'Wbe') && getline('.') !~# s:item_pattern
                                  call search('^commit ', 'Wbe')
                                endif
                              endfor
                              call s:StageReveal()
                              return '.'
                            endfunction
                            
    1              0.000007 let s:section_pattern = '^[A-Z][a-z][^:]*$'
    1              0.000010 let s:section_commit_pattern = s:section_pattern . '\|^commit '
                            
    1              0.000004 function! s:NextSection(count) abort
                              let orig = line('.')
                              if getline('.') !~# '^commit '
                                -
                              endif
                              for i in range(a:count)
                                if !search(s:section_commit_pattern, 'W')
                                  break
                                endif
                              endfor
                              if getline('.') =~# s:section_commit_pattern
                                call s:StageReveal()
                                return getline('.') =~# s:section_pattern ? '+' : ':'
                              else
                                return orig
                              endif
                            endfunction
                            
    1              0.000004 function! s:PreviousSection(count) abort
                              let orig = line('.')
                              if getline('.') !~# '^commit '
                                -
                              endif
                              for i in range(a:count)
                                if !search(s:section_commit_pattern . '\|\%^', 'bW')
                                  break
                                endif
                              endfor
                              if getline('.') =~# s:section_commit_pattern || line('.') == 1
                                call s:StageReveal()
                                return getline('.') =~# s:section_pattern ? '+' : ':'
                              else
                                return orig
                              endif
                            endfunction
                            
    1              0.000005 function! s:NextSectionEnd(count) abort
                              +
                              if empty(getline('.'))
                                +
                              endif
                              for i in range(a:count)
                                if !search(s:section_commit_pattern, 'W')
                                  return '$'
                                endif
                              endfor
                              return search('^.', 'Wb')
                            endfunction
                            
    1              0.000005 function! s:PreviousSectionEnd(count) abort
                              let old = line('.')
                              for i in range(a:count)
                                if search(s:section_commit_pattern, 'Wb') <= 1
                                  exe old
                                  if i
                                    break
                                  else
                                    return ''
                                  endif
                                endif
                                let old = line('.')
                              endfor
                              return search('^.', 'Wb')
                            endfunction
                            
    1              0.000005 function! s:PatchSearchExpr(reverse) abort
                              let line = getline('.')
                              if col('.') ==# 1 && line =~# '^[+-]'
                                if line =~# '^[+-]\{3\} '
                                  let pattern = '^[+-]\{3\} ' . substitute(escape(strpart(line, 4), '^$.*[]~\'), '^\w/', '\\w/', '') . '$'
                                else
                                  let pattern = '^[+-]\s*' . escape(substitute(strpart(line, 1), '^\s*\|\s*$', '', ''), '^$.*[]~\') . '\s*$'
                                endif
                                if a:reverse
                                  return '?' . escape(pattern, '/?') . "\<CR>"
                                else
                                  return '/' . escape(pattern, '/') . "\<CR>"
                                endif
                              endif
                              return a:reverse ? '#' : '*'
                            endfunction
                            
    1              0.000005 function! s:StageInline(mode, ...) abort
                              if &filetype !=# 'fugitive'
                                return ''
                              endif
                              let lnum1 = a:0 ? a:1 : line('.')
                              let lnum = lnum1 + 1
                              if a:0 > 1 && a:2 == 0
                                let info = s:StageInfo(lnum - 1)
                                if empty(info.paths) && len(info.section)
                                  while len(getline(lnum))
                                    let lnum += 1
                                  endwhile
                                endif
                              elseif a:0 > 1
                                let lnum += a:2 - 1
                              endif
                              while lnum > lnum1
                                let lnum -= 1
                                while lnum > 0 && getline(lnum) =~# '^[ @\+-]'
                                  let lnum -= 1
                                endwhile
                                let info = s:StageInfo(lnum)
                                if !has_key(b:fugitive_diff, info.section)
                                  continue
                                endif
                                if getline(lnum + 1) =~# '^[ @\+-]'
                                  let lnum2 = lnum + 1
                                  while getline(lnum2 + 1) =~# '^[ @\+-]'
                                    let lnum2 += 1
                                  endwhile
                                  if a:mode !=# 'show'
                                    setlocal modifiable noreadonly
                                    exe 'silent keepjumps ' . (lnum + 1) . ',' . lnum2 . 'delete _'
                                    call remove(b:fugitive_expanded[info.section], info.filename)
                                    setlocal nomodifiable readonly nomodified
                                  endif
                                  continue
                                endif
                                if !has_key(b:fugitive_diff, info.section) || info.status !~# '^[ADMRU]$' || a:mode ==# 'hide'
                                  continue
                                endif
                                let mode = ''
                                let diff = []
                                let index = 0
                                let start = -1
                                for line in b:fugitive_diff[info.section]
                                  if mode ==# 'await' && line[0] ==# '@'
                                    let mode = 'capture'
                                  endif
                                  if mode !=# 'head' && line !~# '^[ @\+-]'
                                    if len(diff)
                                      break
                                    endif
                                    let start = index
                                    let mode = 'head'
                                  elseif mode ==# 'head' && line =~# '^diff '
                                    let start = index
                                  elseif mode ==# 'head' && substitute(line, "\t$", '', '') ==# '--- ' . info.relative[-1]
                                    let mode = 'await'
                                  elseif mode ==# 'head' && substitute(line, "\t$", '', '') ==# '+++ ' . info.relative[0]
                                    let mode = 'await'
                                  elseif mode ==# 'capture'
                                    call add(diff, line)
                                  elseif line[0] ==# '@'
                                    let mode = ''
                                  endif
                                  let index += 1
                                endfor
                                if len(diff)
                                  setlocal modifiable noreadonly
                                  silent call append(lnum, diff)
                                  let b:fugitive_expanded[info.section][info.filename] = [start, len(diff)]
                                  setlocal nomodifiable readonly nomodified
                                endif
                              endwhile
                              return lnum
                            endfunction
                            
    1              0.000006 function! s:NextExpandedHunk(count) abort
                              for i in range(a:count)
                                call s:StageInline('show', line('.'), 1)
                                call search(s:file_pattern . '\|^@','W')
                              endfor
                              return '.'
                            endfunction
                            
    1              0.000004 function! s:StageDiff(diff) abort
                              let lnum = line('.')
                              let info = s:StageInfo(lnum)
                              let prefix = info.offset > 0 ? '+' . info.offset : ''
                              if info.sub =~# '^S'
                                if info.section ==# 'Staged'
                                  return 'Git --paginate diff --no-ext-diff --submodule=log --cached -- ' . info.paths[0]
                                elseif info.sub =~# '^SC'
                                  return 'Git --paginate diff --no-ext-diff --submodule=log -- ' . info.paths[0]
                                else
                                  return 'Git --paginate diff --no-ext-diff --submodule=diff -- ' . info.paths[0]
                                endif
                              elseif empty(info.paths) && info.section ==# 'Staged'
                                return 'Git --paginate diff --no-ext-diff --cached'
                              elseif empty(info.paths)
                                return 'Git --paginate diff --no-ext-diff'
                              elseif len(info.paths) > 1
                                execute 'Gedit' . prefix s:fnameescape(':0:' . info.paths[0])
                                return a:diff . '! HEAD:'.s:fnameescape(info.paths[1])
                              elseif info.section ==# 'Staged' && info.sigil ==# '-'
                                execute 'Gedit' prefix s:fnameescape(':0:'.info.paths[0])
                                return a:diff . '! :0:%'
                              elseif info.section ==# 'Staged'
                                execute 'Gedit' prefix s:fnameescape(':0:'.info.paths[0])
                                return a:diff . '! @:%'
                              elseif info.sigil ==# '-'
                                execute 'Gedit' prefix s:fnameescape(':0:'.info.paths[0])
                                return a:diff . '! :(top)%'
                              else
                                execute 'Gedit' prefix s:fnameescape(':(top)'.info.paths[0])
                                return a:diff . '!'
                              endif
                            endfunction
                            
    1              0.000004 function! s:StageDiffEdit() abort
                              let info = s:StageInfo(line('.'))
                              let arg = (empty(info.paths) ? s:Tree() : info.paths[0])
                              if info.section ==# 'Staged'
                                return 'Git --paginate diff --no-ext-diff --cached '.s:fnameescape(arg)
                              elseif info.status ==# '?'
                                call s:TreeChomp('add', '--intent-to-add', '--', arg)
                                return s:ReloadStatus()
                              else
                                return 'Git --paginate diff --no-ext-diff '.s:fnameescape(arg)
                              endif
                            endfunction
                            
    1              0.000006 function! s:StageApply(info, reverse, extra) abort
                              if a:info.status ==# 'R'
                                call s:throw('fugitive: patching renamed file not yet supported')
                              endif
                              let cmd = ['apply', '-p0', '--recount'] + a:extra
                              let info = a:info
                              let start = info.patch
                              let end = info.lnum
                              let lines = getline(start, end)
                              if empty(filter(copy(lines), 'v:val =~# "^[+-]"'))
                                return -1
                              endif
                              while getline(end) =~# '^[-+ ]'
                                let end += 1
                                if getline(end) =~# '^[' . (a:reverse ? '+' : '-') . ' ]'
                                  call add(lines, ' ' . getline(end)[1:-1])
                                endif
                              endwhile
                              while start > 0 && getline(start) !~# '^@'
                                let start -= 1
                                if getline(start) =~# '^[' . (a:reverse ? '+' : '-') . ' ]'
                                  call insert(lines, ' ' . getline(start)[1:-1])
                                elseif getline(start) =~# '^@'
                                  call insert(lines, getline(start))
                                endif
                              endwhile
                              if start == 0
                                throw 'fugitive: cold not find hunk'
                              elseif getline(start) !~# '^@@ '
                                throw 'fugitive: cannot apply conflict hunk'
                              endif
                              let i = b:fugitive_expanded[info.section][info.filename][0]
                              let head = []
                              while get(b:fugitive_diff[info.section], i, '@') !~# '^@'
                                let line = b:fugitive_diff[info.section][i]
                                if line ==# '--- /dev/null'
                                  call add(head, '--- ' . get(b:fugitive_diff[info.section], i + 1, '')[4:-1])
                                elseif line !~# '^new file '
                                  call add(head, line)
                                endif
                                let i += 1
                              endwhile
                              call extend(lines, head, 'keep')
                              let temp = tempname()
                              call writefile(lines, temp)
                              if a:reverse
                                call add(cmd, '--reverse')
                              endif
                              call extend(cmd, ['--', temp])
                              let [output, exec_error] = s:ChompError(cmd)
                              if !exec_error
                                return 1
                              endif
                              call s:throw(output)
                            endfunction
                            
    1              0.000009 function! s:StageDelete(lnum1, lnum2, count) abort
                              let restore = []
                              let err = ''
                              try
                                for info in s:Selection(a:lnum1, a:lnum2)
                                  if empty(info.paths)
                                    continue
                                  endif
                                  let sub = get(get(get(b:fugitive_files, info.section, {}), info.filename, {}), 'sub')
                                  if sub =~# '^S'
                                    if info.status ==# 'A'
                                      continue
                                    endif
                                    if info.section ==# 'Staged'
                                      call s:TreeChomp('reset', '--', info.paths[0])
                                    endif
                                    if info.status =~# '[MD]'
                                      call s:TreeChomp('submodule', 'update', '--', info.paths[0])
                                      call add(restore, ':Git -C ' . info.relative[0] . ' checkout -')
                                    endif
                                    continue
                                  endif
                                  if info.status ==# 'D'
                                    let undo = 'Gremove'
                                  elseif info.paths[0] =~# '/$'
                                    let err .= '|echoerr ' . string('fugitive: will not delete directory ' . string(info.relative[0]))
                                    break
                                  else
                                    let undo = 'Gread ' . s:TreeChomp('hash-object', '-w', '--', info.paths[0])[0:10]
                                  endif
                                  if info.patch
                                    call s:StageApply(info, 1, info.section ==# 'Staged' ? ['--index'] : [])
                                  elseif info.status ==# '?'
                                    call s:TreeChomp('clean', '-f', '--', info.paths[0])
                                  elseif a:count == 2
                                    call s:TreeChomp('checkout', '--ours', '--', info.paths[0])
                                  elseif a:count == 3
                                    call s:TreeChomp('checkout', '--theirs', '--', info.paths[0])
                                  elseif info.status =~# '[ADU]' &&
                                        \ get(b:fugitive_files[info.section ==# 'Staged' ? 'Unstaged' : 'Staged'], info.filename, {'status': ''}).status =~# '[AU]'
                                    call s:TreeChomp('checkout', info.section ==# 'Staged' ? '--ours' : '--theirs', '--', info.paths[0])
                                  elseif info.status ==# 'U'
                                    call s:TreeChomp('rm', '--', info.paths[0])
                                  elseif info.status ==# 'A'
                                    call s:TreeChomp('rm', '-f', '--', info.paths[0])
                                  elseif info.section ==# 'Unstaged'
                                    call s:TreeChomp('checkout', '--', info.paths[0])
                                  else
                                    call s:TreeChomp('checkout', 'HEAD^{}', '--', info.paths[0])
                                  endif
                                  call add(restore, ':Gsplit ' . s:fnameescape(info.relative[0]) . '|' . undo)
                                endfor
                              catch /^fugitive:/
                                let err .= '|echoerr ' . string(v:exception)
                              endtry
                              if empty(restore)
                                return err[1:-1]
                              endif
                              exe s:ReloadStatus()
                              call s:StageReveal()
                              if len(restore)
                                return 'checktime|redraw|echomsg ' . string('To restore, ' . join(restore, '|')) . err
                              else
                                return 'checktime|redraw' . err
                              endif
                            endfunction
                            
    1              0.000006 function! s:StageIgnore(lnum1, lnum2, count) abort
                              let paths = []
                              for info in s:Selection(a:lnum1, a:lnum2)
                                call extend(paths, info.relative)
                              endfor
                              call map(paths, '"/" . v:val')
                              exe 'Gsplit' (a:count ? '.gitignore' : '.git/info/exclude')
                              let last = line('$')
                              if last == 1 && empty(getline(1))
                                call setline(last, paths)
                              else
                                call append(last, paths)
                                exe last + 1
                              endif
                              return ''
                            endfunction
                            
    1              0.000005 function! s:DoToggleHeadHeader(value) abort
                              exe 'edit' s:fnameescape(s:Dir())
                              call search('\C^index$', 'wc')
                            endfunction
                            
    1              0.000005 function! s:DoToggleHelpHeader(value) abort
                              exe 'help fugitive-map'
                            endfunction
                            
    1              0.000005 function! s:DoStagePushHeader(value) abort
                              let remote = matchstr(a:value, '\zs[^/]\+\ze/')
                              if empty(remote)
                                let remote = '.'
                              endif
                              let branch = matchstr(a:value, '\%([^/]\+/\)\=\zs\S\+')
                              call feedkeys(':Git push ' . remote . ' ' . branch)
                            endfunction
                            
    1              0.000005 function! s:DoTogglePushHeader(value) abort
                              return s:DoStagePushHeader(a:value)
                            endfunction
                            
    1              0.000005 function! s:DoStageUnpushedHeading(heading) abort
                              let remote = matchstr(a:heading, 'to \zs[^/]\+\ze/')
                              if empty(remote)
                                let remote = '.'
                              endif
                              let branch = matchstr(a:heading, 'to \%([^/]\+/\)\=\zs\S\+')
                              call feedkeys(':Git push ' . remote . ' ' . 'HEAD:' . 'refs/heads/' . branch)
                            endfunction
                            
    1              0.000005 function! s:DoToggleUnpushedHeading(heading) abort
                              return s:DoStageUnpushedHeading(a:heading)
                            endfunction
                            
    1              0.000005 function! s:DoStageUnpushed(record) abort
                              let remote = matchstr(a:record.heading, 'to \zs[^/]\+\ze/')
                              if empty(remote)
                                let remote = '.'
                              endif
                              let branch = matchstr(a:record.heading, 'to \%([^/]\+/\)\=\zs\S\+')
                              call feedkeys(':Git push ' . remote . ' ' . a:record.commit . ':' . 'refs/heads/' . branch)
                            endfunction
                            
    1              0.000005 function! s:DoToggleUnpushed(record) abort
                              return s:DoStageUnpushed(a:record)
                            endfunction
                            
    1              0.000005 function! s:DoUnstageUnpulledHeading(heading) abort
                              call feedkeys(':Git rebase')
                            endfunction
                            
    1              0.000005 function! s:DoToggleUnpulledHeading(heading) abort
                              call s:DoUnstageUnpulledHeading(a:heading)
                            endfunction
                            
    1              0.000005 function! s:DoUnstageUnpulled(record) abort
                              call feedkeys(':Git rebase ' . a:record.commit)
                            endfunction
                            
    1              0.000005 function! s:DoToggleUnpulled(record) abort
                              call s:DoUnstageUnpulled(a:record)
                            endfunction
                            
    1              0.000004 function! s:DoUnstageUnpushed(record) abort
                              call feedkeys(':Git -c sequence.editor=true rebase --interactive --autosquash ' . a:record.commit . '^')
                            endfunction
                            
    1              0.000004 function! s:DoToggleStagedHeading(...) abort
                              call s:TreeChomp('reset', '-q')
                              return 1
                            endfunction
                            
    1              0.000005 function! s:DoUnstageStagedHeading(heading) abort
                              return s:DoToggleStagedHeading(a:heading)
                            endfunction
                            
    1              0.000004 function! s:DoToggleUnstagedHeading(...) abort
                              call s:TreeChomp('add', '-u')
                              return 1
                            endfunction
                            
    1              0.000005 function! s:DoStageUnstagedHeading(heading) abort
                              return s:DoToggleUnstagedHeading(a:heading)
                            endfunction
                            
    1              0.000004 function! s:DoToggleUntrackedHeading(...) abort
                              call s:TreeChomp('add', '.')
                              return 1
                            endfunction
                            
    1              0.000005 function! s:DoStageUntrackedHeading(heading) abort
                              return s:DoToggleUntrackedHeading(a:heading)
                            endfunction
                            
    1              0.000005 function! s:DoToggleStaged(record) abort
                              if a:record.patch
                                return s:StageApply(a:record, 1, ['--cached'])
                              else
                                call s:TreeChomp(['reset', '-q', '--'] + a:record.paths)
                                return 1
                              endif
                            endfunction
                            
    1              0.000005 function! s:DoUnstageStaged(record) abort
                              return s:DoToggleStaged(a:record)
                            endfunction
                            
    1              0.000005 function! s:DoToggleUnstaged(record) abort
                              if a:record.patch
                                return s:StageApply(a:record, 0, ['--cached'])
                              else
                                call s:TreeChomp(['add', '-A', '--'] + a:record.paths)
                                return 1
                              endif
                            endfunction
                            
    1              0.000004 function! s:DoStageUnstaged(record) abort
                              return s:DoToggleUnstaged(a:record)
                            endfunction
                            
    1              0.000004 function! s:DoUnstageUnstaged(record) abort
                              if a:record.status ==# 'A'
                                call s:TreeChomp(['reset', '-q', '--'] + a:record.paths)
                                return 1
                              else
                                return -1
                              endif
                            endfunction
                            
    1              0.000005 function! s:DoToggleUntracked(record) abort
                              call s:TreeChomp(['add', '--'] + a:record.paths)
                              return 1
                            endfunction
                            
    1              0.000004 function! s:DoStageUntracked(record) abort
                              return s:DoToggleUntracked(a:record)
                            endfunction
                            
    1              0.000005 function! s:StagePatch(lnum1,lnum2) abort
                              let add = []
                              let reset = []
                              let intend = []
                            
                              for lnum in range(a:lnum1,a:lnum2)
                                let info = s:StageInfo(lnum)
                                if empty(info.paths) && info.section ==# 'Staged'
                                  return 'Git reset --patch'
                                elseif empty(info.paths) && info.section ==# 'Unstaged'
                                  return 'Git add --patch'
                                elseif empty(info.paths) && info.section ==# 'Untracked'
                                  return 'Git add --interactive'
                                elseif empty(info.paths)
                                  continue
                                endif
                                execute lnum
                                if info.section ==# 'Staged'
                                  let reset += info.relative
                                elseif info.section ==# 'Untracked'
                                  let intend += info.paths
                                elseif info.status !~# '^D'
                                  let add += info.relative
                                endif
                              endfor
                              try
                                if !empty(intend)
                                  call s:TreeChomp(['add', '--intent-to-add', '--'] + intend)
                                endif
                                if !empty(add)
                                  execute "Git add --patch -- ".join(map(add,'s:fnameescape(v:val)'))
                                endif
                                if !empty(reset)
                                  execute "Git reset --patch -- ".join(map(reset,'s:fnameescape(v:val)'))
                                endif
                              catch /^fugitive:/
                                return 'echoerr ' . string(v:exception)
                              endtry
                              return s:ReloadStatus()
                            endfunction
                            
                            " Section: :Git commit, :Git revert
                            
    1              0.000010 function! s:CommitInteractive(line1, line2, range, bang, mods, options, patch) abort
                              let status = s:StatusCommand(a:line1, a:line2, a:range, a:line2, a:bang, a:mods, '', '', [], a:options.dir)
                              let status = len(status) ? status . '|' : ''
                              if a:patch
                                return status . 'if search("^Unstaged")|exe "normal >"|exe "+"|endif'
                              else
                                return status . 'if search("^Untracked\\|^Unstaged")|exe "+"|endif'
                              endif
                            endfunction
                            
    1              0.000007 function! s:CommitSubcommand(line1, line2, range, bang, mods, options) abort
                              let argv = copy(a:options.args)
                              let i = 0
                              while get(argv, i, '--') !=# '--'
                                if argv[i] =~# '^-[apzsneiovq].'
                                  call insert(argv, argv[i][0:1])
                                  let argv[i+1] = '-' . argv[i+1][2:-1]
                                else
                                  let i += 1
                                endif
                              endwhile
                              if s:HasOpt(argv, '-i', '--interactive')
                                return s:CommitInteractive(a:line1, a:line2, a:range, a:bang, a:mods, a:options, 0)
                              elseif s:HasOpt(argv, '-p', '--patch')
                                return s:CommitInteractive(a:line1, a:line2, a:range, a:bang, a:mods, a:options, 1)
                              else
                                return {}
                              endif
                            endfunction
                            
    1              0.000008 function! s:RevertSubcommand(line1, line2, range, bang, mods, options) abort
                              return {'insert_args': ['--edit']}
                            endfunction
                            
    1              0.000007 function! fugitive#CommitComplete(A, L, P, ...) abort
                              let dir = a:0 ? a:1 : s:Dir()
                              if a:A =~# '^--fixup=\|^--squash='
                                let commits = s:LinesError([dir, 'log', '--pretty=format:%s', '@{upstream}..'])[0]
                                let pre = matchstr(a:A, '^--\w*=''\=') . ':/^'
                                if pre =~# "'"
                                  call map(commits, 'pre . string(tr(v:val, "|\"^$*[]", "......."))[1:-1]')
                                  call filter(commits, 'strpart(v:val, 0, strlen(a:A)) ==# a:A')
                                  return commits
                                else
                                  return s:FilterEscape(map(commits, 'pre . tr(v:val, "\\ !^$*?[]()''\"`&;<>|#", "....................")'), a:A)
                                endif
                              else
                                return s:CompleteSub('commit', a:A, a:L, a:P, function('fugitive#CompletePath'), a:000)
                              endif
                              return []
                            endfunction
                            
    1              0.000006 function! fugitive#RevertComplete(A, L, P, ...) abort
                              return s:CompleteSub('revert', a:A, a:L, a:P, function('s:CompleteRevision'), a:000)
                            endfunction
                            
                            " Section: :Git merge, :Git rebase, :Git pull
                            
    1              0.000005 function! fugitive#MergeComplete(A, L, P, ...) abort
                              return s:CompleteSub('merge', a:A, a:L, a:P, function('s:CompleteRevision'), a:000)
                            endfunction
                            
    1              0.000005 function! fugitive#RebaseComplete(A, L, P, ...) abort
                              return s:CompleteSub('rebase', a:A, a:L, a:P, function('s:CompleteRevision'), a:000)
                            endfunction
                            
    1              0.000005 function! fugitive#PullComplete(A, L, P, ...) abort
                              return s:CompleteSub('pull', a:A, a:L, a:P, function('s:CompleteRemote'), a:000)
                            endfunction
                            
    1              0.000008 function! s:MergeSubcommand(line1, line2, range, bang, mods, options) abort
                              let dir = a:options.dir
                              if empty(a:options.args) && (
                                    \ filereadable(fugitive#Find('.git/MERGE_MSG', dir)) ||
                                    \ isdirectory(fugitive#Find('.git/rebase-apply', dir)) ||
                                    \  !empty(s:TreeChomp(dir, 'diff-files', '--diff-filter=U')))
                                return 'echohl WarningMsg|echo ":Git merge for loading conflicts is deprecated in favor of :Git mergetool"|echohl NONE|silent Git' . (a:bang ? '!' : '') . s:fnameescape(a:options.flags + ['mergetool'])
                              endif
                              return {}
                            endfunction
                            
    1              0.000007 function! s:RebaseSubcommand(line1, line2, range, bang, mods, options) abort
                              let args = a:options.args
                              if s:HasOpt(args, '--autosquash') && !s:HasOpt(args, '-i', '--interactive')
                                return {'env': {'GIT_SEQUENCE_EDITOR': 'true'}, 'insert_args': ['--interactive']}
                              endif
                              return {}
                            endfunction
                            
                            " Section: :Git difftool, :Git mergetool
                            
    1              0.000007 function! s:ToolItems(state, from, to, offsets, text, ...) abort
                              let items = []
                              for i in range(len(a:state.diff))
                                let diff = a:state.diff[i]
                                let path = (i == len(a:state.diff) - 1) ? a:to : a:from
                                if empty(path)
                                  return []
                                endif
                                let item = {
                                      \ 'valid': a:0 ? a:1 : 1,
                                      \ 'filename': diff.filename . FugitiveVimPath(path),
                                      \ 'lnum': matchstr(get(a:offsets, i), '\d\+'),
                                      \ 'text': a:text}
                                if len(get(diff, 'module', ''))
                                  let item.module = diff.module . path
                                endif
                                call add(items, item)
                              endfor
                              let diff = items[0:-2]
                              let items[-1].context = {'diff': items[0:-2]}
                              return [items[-1]]
                            endfunction
                            
    1              0.000020 function! s:ToolToFrom(str) abort
                              if a:str =~# ' => '
                                let str = a:str =~# '{.* => .*}' ? a:str : '{' . a:str . '}'
                                return [substitute(str, '{.* => \(.*\)}', '\1', ''),
                                      \ substitute(str, '{\(.*\) => .*}', '\1', '')]
                              else
                                return [a:str, a:str]
                              endif
                            endfunction
                            
    1              0.000007 function! s:ToolParse(state, line) abort
                              if type(a:line) !=# type('') || a:state.mode ==# 'hunk' && a:line =~# '^[ +-]'
                                return []
                              elseif a:line =~# '^diff '
                                let a:state.mode = 'diffhead'
                                let a:state.from = ''
                                let a:state.to = ''
                              elseif a:state.mode ==# 'diffhead' && a:line =~# '^--- [^/]'
                                let a:state.from = a:line[4:-1]
                                let a:state.to = a:state.from
                              elseif a:state.mode ==# 'diffhead' && a:line =~# '^+++ [^/]'
                                let a:state.to = a:line[4:-1]
                                if empty(get(a:state, 'from', ''))
                                  let a:state.from = a:state.to
                                endif
                              elseif a:line[0] ==# '@'
                                let a:state.mode = 'hunk'
                                if has_key(a:state, 'from')
                                  let offsets = split(matchstr(a:line, '^@\+ \zs[-+0-9, ]\+\ze @'), ' ')
                                  return s:ToolItems(a:state, a:state.from, a:state.to, offsets, matchstr(a:line, ' @@\+ \zs.*'))
                                endif
                              elseif a:line =~# '^\* Unmerged path .'
                                let file = a:line[16:-1]
                                return s:ToolItems(a:state, file, file, [], '')
                              elseif a:line =~# '^[A-Z]\d*\t.\|^:.*\t.'
                                " --raw, --name-status
                                let [status; files] = split(a:line, "\t")
                                return s:ToolItems(a:state, files[0], files[-1], [], a:state.name_only ? '' : status)
                              elseif a:line =~# '^ \S.* |'
                                " --stat
                                let [_, to, changes; __] = matchlist(a:line, '^ \(.\{-\}\) \+|\zs \(.*\)$')
                                let [to, from] = s:ToolToFrom(to)
                                return s:ToolItems(a:state, from, to, [], changes)
                              elseif a:line =~# '^ *\([0-9.]\+%\) .'
                                " --dirstat
                                let [_, changes, to; __] = matchlist(a:line, '^ *\([0-9.]\+%\) \(.*\)')
                                return s:ToolItems(a:state, to, to, [], changes)
                              elseif a:line =~# '^\(\d\+\|-\)\t\(\d\+\|-\)\t.'
                                " --numstat
                                let [_, add, remove, to; __] = matchlist(a:line, '^\(\d\+\|-\)\t\(\d\+\|-\)\t\(.*\)')
                                let [to, from] = s:ToolToFrom(to)
                                return s:ToolItems(a:state, from, to, [], add ==# '-' ? 'Binary file' : '+' . add . ' -' . remove, add !=# '-')
                              elseif a:state.mode !=# 'diffhead' && a:state.mode !=# 'hunk' && len(a:line) || a:line =~# '^git: \|^usage: \|^error: \|^fatal: '
                                return [{'text': a:line}]
                              endif
                              return []
                            endfunction
                            
    1              0.000011 function! s:ToolStream(line1, line2, range, bang, mods, options, args, state) abort
                              let i = 0
                              let argv = copy(a:args)
                              let prompt = 1
                              let state = a:state
                              while i < len(argv)
                                let match = matchlist(argv[i], '^\(-[a-zABDFH-KN-RT-Z]\)\ze\(.*\)')
                                if len(match) && len(match[2])
                                  call insert(argv, match[1])
                                  let argv[i+1] = '-' . match[2]
                                  continue
                                endif
                                let arg = argv[i]
                                if arg =~# '^-t$\|^--tool=\|^--tool-help$\|^--help$'
                                  return {}
                                elseif arg =~# '^-y$\|^--no-prompt$'
                                  let prompt = 0
                                  call remove(argv, i)
                                  continue
                                elseif arg ==# '--prompt'
                                  let prompt = 1
                                  call remove(argv, i)
                                  continue
                                elseif arg =~# '^--\%(no-\)\=\(symlinks\|trust-exit-code\|gui\)$'
                                  call remove(argv, i)
                                  continue
                                elseif arg ==# '--'
                                  break
                                endif
                                let i += 1
                              endwhile
                              let a:state.mode = 'init'
                              let a:state.from = ''
                              let a:state.to = ''
                              let exec = s:UserCommandList({'git': a:options.git, 'dir': a:options.dir})
                              if fugitive#GitVersion(1, 9) || (!s:HasOpt(argv, '--name-status') && !prompt)
                                let exec += ['-c', 'diff.context=0']
                              endif
                              let exec += a:options.flags + ['--no-pager', 'diff', '--no-ext-diff', '--no-color', '--no-prefix'] + argv
                              if prompt
                                let title = ':Git ' . s:fnameescape(a:options.flags + [a:options.command] + a:options.args)
                                return s:QuickfixStream(a:line2, 'difftool', title, exec, !a:bang, s:function('s:ToolParse'), a:state)
                              else
                                let filename = ''
                                let cmd = []
                                let tabnr = tabpagenr() + 1
                                for line in split(s:SystemError(s:shellesc(exec))[0], "\n")
                                  for item in s:ToolParse(a:state, line)
                                    if len(get(item, 'filename', '')) && item.filename != filename
                                      call add(cmd, 'tabedit ' . s:fnameescape(item.filename))
                                      for i in reverse(range(len(get(item.context, 'diff', []))))
                                        call add(cmd, (i ? 'rightbelow' : 'leftabove') . ' vert Gdiffsplit! ' . s:fnameescape(item.context.diff[i].filename))
                                      endfor
                                      call add(cmd, 'wincmd =')
                                      let filename = item.filename
                                    endif
                                  endfor
                                endfor
                                return join(cmd, '|') . (empty(cmd) ? '' : '|' . tabnr . 'tabnext')
                              endif
                            endfunction
                            
    1              0.000009 function! s:MergetoolSubcommand(line1, line2, range, bang, mods, options) abort
                              let dir = a:options.dir
                              exe s:DirCheck(dir)
                              let i = 0
                              let prompt = 1
                              let cmd = ['diff', '--diff-filter=U']
                              let state = {'name_only': 0}
                              let state.diff = [{'prefix': ':2:', 'module': ':2:'}, {'prefix': ':3:', 'module': ':3:'}, {'prefix': ':(top)'}]
                              call map(state.diff, 'extend(v:val, {"filename": fugitive#Find(v:val.prefix, dir)})')
                              return s:ToolStream(a:line1, a:line2, a:range, a:bang, a:mods, a:options, ['--diff-filter=U'] + a:options.args, state)
                            endfunction
                            
    1              0.000007 function! s:DifftoolSubcommand(line1, line2, range, bang, mods, options) abort
                              let dir = a:options.dir
                              exe s:DirCheck(dir)
                              let i = 0
                              let argv = copy(a:options.args)
                              let commits = []
                              let cached = 0
                              let reverse = 1
                              let prompt = 1
                              let state = {'name_only': 0}
                              let merge_base_against = {}
                              let dash = (index(argv, '--') > i ? ['--'] : [])
                              while i < len(argv)
                                let match = matchlist(argv[i], '^\(-[a-zABDFH-KN-RT-Z]\)\ze\(.*\)')
                                if len(match) && len(match[2])
                                  call insert(argv, match[1])
                                  let argv[i+1] = '-' . match[2]
                                  continue
                                endif
                                let arg = argv[i]
                                if arg ==# '--cached'
                                  let cached = 1
                                elseif arg ==# '-R'
                                  let reverse = 1
                                elseif arg ==# '--name-only'
                                  let state.name_only = 1
                                  let argv[0] = '--name-status'
                                elseif arg ==# '--'
                                  break
                                elseif arg !~# '^-\|^\.\.\=\%(/\|$\)'
                                  let parsed = s:LinesError(['rev-parse', '--revs-only', substitute(arg, ':.*', '', '')] + dash)[0]
                                  call map(parsed, '{"uninteresting": v:val =~# "^\\^", "prefix": substitute(v:val, "^\\^", "", "") . ":"}')
                                  let merge_base_against = {}
                                  if arg =~# '\.\.\.' && len(parsed) > 2
                                    let display = map(split(arg, '\.\.\.', 1), 'empty(v:val) ? "@" : v:val')
                                    if len(display) == 2
                                      let parsed[0].module = display[1] . ':'
                                      let parsed[1].module = display[0] . ':'
                                    endif
                                    let parsed[2].module = arg . ':'
                                    if empty(commits)
                                      let merge_base_against = parsed[0]
                                      let parsed = [parsed[2]]
                                    endif
                                  elseif arg =~# '\.\.' && len(parsed) == 2
                                    let display = map(split(arg, '\.\.', 1), 'empty(v:val) ? "@" : v:val')
                                    if len(display) == 2
                                      let parsed[0].module = display[0] . ':'
                                      let parsed[1].module = display[1] . ':'
                                    endif
                                  elseif len(parsed) == 1
                                    let parsed[0].module = arg . ':'
                                  endif
                                  call extend(commits, parsed)
                                endif
                                let i += 1
                              endwhile
                              if len(merge_base_against)
                                call add(commits, merge_base_against)
                              endif
                              let commits = filter(copy(commits), 'v:val.uninteresting') + filter(commits, '!v:val.uninteresting')
                              if cached
                                if empty(commits)
                                  call add(commits, {'prefix': '@:', 'module': '@:'})
                                endif
                                call add(commits, {'prefix': ':0:', 'module': ':0:'})
                              elseif len(commits) < 2
                                call add(commits, {'prefix': ':(top)'})
                                if len(commits) < 2
                                  call insert(commits, {'prefix': ':0:', 'module': ':0:'})
                                endif
                              endif
                              if reverse
                                let commits = [commits[-1]] + repeat([commits[0]], len(commits) - 1)
                                call reverse(commits)
                              endif
                              if len(commits) > 2
                                call add(commits, remove(commits, 0))
                              endif
                              call map(commits, 'extend(v:val, {"filename": fugitive#Find(v:val.prefix, dir)})')
                              let state.diff = commits
                              return s:ToolStream(a:line1, a:line2, a:range, a:bang, a:mods, a:options, argv, state)
                            endfunction
                            
                            " Section: :Ggrep, :Glog
                            
    1              0.000020 if !exists('g:fugitive_summary_format')
    1              0.000017   let g:fugitive_summary_format = '%s'
    1              0.000003 endif
                            
    1              0.000007 function! fugitive#GrepComplete(A, L, P) abort
                              return s:CompleteSub('grep', a:A, a:L, a:P)
                            endfunction
                            
    1              0.000006 function! fugitive#LogComplete(A, L, P) abort
                              return s:CompleteSub('log', a:A, a:L, a:P)
                            endfunction
                            
    1              0.000008 function! s:GrepParseLine(prefix, name_only, dir, line) abort
                              let entry = {'valid': 1}
                              let match = matchlist(a:line, '^\(.\{-\}\):\(\d\+\):\(\d\+:\)\=\(.*\)$')
                              if len(match)
                                let entry.module = match[1]
                                let entry.lnum = +match[2]
                                let entry.col = +match[3]
                                let entry.text = match[4]
                              elseif a:line =~# '^git: \|^usage: \|^error: \|^fatal: '
                                return {'text': a:line}
                              else
                                let entry.module = matchstr(a:line, '\CBinary file \zs.*\ze matches$')
                                if len(entry.module)
                                  let entry.text = 'Binary file'
                                  let entry.valid = 0
                                endif
                              endif
                              if empty(entry.module) && a:name_only
                                let entry.module = a:line
                              endif
                              if empty(entry.module)
                                return {'text': a:line}
                              endif
                              if entry.module !~# ':'
                                let entry.filename = a:prefix . entry.module
                              else
                                let entry.filename = fugitive#Find(entry.module, a:dir)
                              endif
                              return entry
                            endfunction
                            
    1              0.000007 function! s:GrepSubcommand(line1, line2, range, bang, mods, options) abort
                              let dir = a:options.dir
                              exe s:DirCheck(dir)
                              let listnr = a:line1 == 0 ? a:line1 : a:line2
                              let cmd = ['--no-pager', 'grep', '-n', '--no-color', '--full-name']
                              let tree = s:Tree(dir)
                              let args = a:options.args
                              if get(args, 0, '') =~# '^-O\|--open-files-in-pager$'
                                let args = args[1:-1]
                              endif
                              let name_only = s:HasOpt(args, '-l', '--files-with-matches', '--name-only', '-L', '--files-without-match')
                              if listnr > 0
                                exe listnr 'wincmd w'
                              else
                                call s:BlurStatus()
                              endif
                              redraw
                              call s:QuickfixCreate(listnr, {'title': (listnr < 0 ? ':Git grep ' : ':0Git grep ') . s:fnameescape(args)})
                              let tempfile = tempname()
                              let event = listnr < 0 ? 'grep-fugitive' : 'lgrep-fugitive'
                              silent exe s:DoAutocmd('QuickFixCmdPre ' . event)
                              let prefix = FugitiveVimPath(s:HasOpt(args, '--cached') || empty(tree) ?
                                    \ 'fugitive://' . dir . '//0/' :
                                    \ s:cpath(getcwd(), tree) ? '' : tree . '/')
                              exe '!' . escape(s:UserCommand(a:options, cmd + args), '%#!')
                                    \ printf(&shellpipe . (&shellpipe =~# '%s' ? '' : ' %s'), s:shellesc(tempfile))
                              let list = map(readfile(tempfile), 's:GrepParseLine(prefix, name_only, dir, v:val)')
                              call s:QuickfixSet(listnr, list, 'a')
                              silent exe s:DoAutocmd('QuickFixCmdPost ' . event)
                              if !has('gui_running')
                                redraw
                              endif
                              if !a:bang && !empty(list)
                                return (listnr < 0 ? 'c' : 'l').'first'
                              else
                                return ''
                              endif
                            endfunction
                            
    1              0.000007 function! fugitive#GrepCommand(line1, line2, range, bang, mods, arg) abort
                              return fugitive#Command(a:line1, a:line2, a:range, a:bang, a:mods,
                                    \ "grep -O " . (fugitive#GitVersion(2, 19) ? "--column " : "") . a:arg)
                            endfunction
                            
    1              0.000013 let s:log_diff_context = '{"filename": fugitive#Find(v:val . from, a:dir), "lnum": get(offsets, v:key), "module": strpart(v:val, 0, len(a:state.base_module)) . from}'
                            
    1              0.000006 function! s:LogFlushQueue(state, dir) abort
                              let queue = remove(a:state, 'queue')
                              if a:state.child_found && get(a:state, 'ignore_commit')
                                call remove(queue, 0)
                              elseif len(queue) && len(a:state.target) && len(get(a:state, 'parents', []))
                                let from = substitute(a:state.target, '^/', ':', '')
                                let offsets = []
                                let queue[0].context.diff = map(copy(a:state.parents), s:log_diff_context)
                              endif
                              if len(queue) && queue[-1] ==# {'text': ''}
                                call remove(queue, -1)
                              endif
                              return queue
                            endfunction
                            
    1              0.000005 function! s:LogParse(state, dir, line) abort
                              if a:state.mode ==# 'hunk' && a:line =~# '^[-+ ]'
                                return []
                              endif
                              let list = matchlist(a:line, '^\%(fugitive \(.\{-\}\)\t\|commit \|From \)\=\(\x\{40,\}\)\%( \(.*\)\)\=$')
                              if len(list)
                                let queue = s:LogFlushQueue(a:state, a:dir)
                                let a:state.mode = 'commit'
                                let a:state.base = 'fugitive://' . a:dir . '//' . list[2]
                                if len(list[1])
                                  let [a:state.base_module; a:state.parents] = split(list[1], ' ')
                                else
                                  let a:state.base_module = list[2]
                                  let a:state.parents = []
                                endif
                                let a:state.message = list[3]
                                let a:state.from = ''
                                let a:state.to = ''
                                let context = {}
                                let a:state.queue = [{
                                      \ 'valid': 1,
                                      \ 'context': context,
                                      \ 'filename': a:state.base . a:state.target,
                                      \ 'module': a:state.base_module . substitute(a:state.target, '^/', ':', ''),
                                      \ 'text': a:state.message}]
                                let a:state.child_found = 0
                                return queue
                              elseif type(a:line) == type(0)
                                return s:LogFlushQueue(a:state, a:dir)
                              elseif a:line =~# '^diff'
                                let a:state.mode = 'diffhead'
                                let a:state.from = ''
                                let a:state.to = ''
                              elseif a:state.mode ==# 'diffhead' && a:line =~# '^--- \w/'
                                let a:state.from = a:line[6:-1]
                                let a:state.to = a:state.from
                              elseif a:state.mode ==# 'diffhead' && a:line =~# '^+++ \w/'
                                let a:state.to = a:line[6:-1]
                                if empty(get(a:state, 'from', ''))
                                  let a:state.from = a:state.to
                                endif
                              elseif a:line =~# '^@@[^@]*+\d' && len(get(a:state, 'to', '')) && has_key(a:state, 'base')
                                let a:state.mode = 'hunk'
                                if empty(a:state.target) || a:state.target ==# '/' . a:state.to
                                  if !a:state.child_found && len(a:state.queue) && a:state.queue[-1] ==# {'text': ''}
                                    call remove(a:state.queue, -1)
                                  endif
                                  let a:state.child_found = 1
                                  let offsets = map(split(matchstr(a:line, '^@\+ \zs[-+0-9, ]\+\ze @'), ' '), '+matchstr(v:val, "\\d\\+")')
                                  let context = {}
                                  if len(a:state.parents)
                                    let from = ":" . a:state.from
                                    let context.diff = map(copy(a:state.parents), s:log_diff_context)
                                  endif
                                  call add(a:state.queue, {
                                        \ 'valid': 1,
                                        \ 'context': context,
                                        \ 'filename': FugitiveVimPath(a:state.base . '/' . a:state.to),
                                        \ 'module': a:state.base_module . ':' . a:state.to,
                                        \ 'lnum': offsets[-1],
                                        \ 'text': a:state.message . matchstr(a:line, ' @@\+ .\+')})
                                endif
                              elseif a:state.follow &&
                                    \ a:line =~# '^ \%(mode change \d\|\%(create\|delete\) mode \d\|\%(rename\|copy\|rewrite\) .* (\d\+%)$\)'
                                let rename = matchstr(a:line, '^ rename \zs.* => .*\ze (\d\+%)$')
                                if len(rename)
                                  let rename = rename =~# '{.* => .*}' ? rename : '{' . rename . '}'
                                  if a:state.target ==# simplify('/' . substitute(rename, '{.* => \(.*\)}', '\1', ''))
                                    let a:state.target = simplify('/' . substitute(rename, '{\(.*\) => .*}', '\1', ''))
                                  endif
                                endif
                                if !get(a:state, 'ignore_summary')
                                  call add(a:state.queue, {'text': a:line})
                                endif
                              elseif a:state.mode ==# 'commit' || a:state.mode ==# 'init'
                                call add(a:state.queue, {'text': a:line})
                              endif
                              return []
                            endfunction
                            
    1              0.000009 function! fugitive#LogCommand(line1, count, range, bang, mods, args, type) abort
                              let dir = s:Dir()
                              exe s:DirCheck(dir)
                              let listnr = a:type =~# '^l' ? 0 : -1
                              let [args, after] = s:SplitExpandChain(a:args, s:Tree(dir))
                              let split = index(args, '--')
                              if split > 0
                                let paths = args[split : -1]
                                let args = args[0 : split - 1]
                              elseif split == 0
                                let paths = args
                                let args = []
                              else
                                let paths = []
                              endif
                              if a:line1 == 0 && a:count
                                let path = fugitive#Path(bufname(a:count), '/', dir)
                                let titlepre = ':0,' . a:count
                              elseif a:count >= 0
                                let path = fugitive#Path(@%, '/', dir)
                                let titlepre = a:count == 0 ? ':0,' . bufnr('') : ':'
                              else
                                let titlepre = ':'
                                let path = ''
                              endif
                              let range = ''
                              let extra_args = []
                              let extra_paths = []
                              let state = {'mode': 'init', 'child_found': 0, 'queue': [], 'follow': 0}
                              if path =~# '^/\.git\%(/\|$\)\|^$'
                                let path = ''
                              elseif a:line1 == 0
                                let range = "0," . (a:count ? a:count : bufnr(''))
                                let extra_paths = ['.' . path]
                                if (empty(paths) || paths ==# ['--']) && !s:HasOpt(args, '--no-follow')
                                  let state.follow = 1
                                  if !s:HasOpt(args, '--follow')
                                    call insert(extra_args, '--follow')
                                  endif
                                  if !s:HasOpt(args, '--summary')
                                    call insert(extra_args, '--summary')
                                    let state.ignore_summary = 1
                                  endif
                                endif
                                let state.ignore_commit = 1
                              elseif a:count > 0
                                if !s:HasOpt(args, '--merges', '--no-merges')
                                  call insert(extra_args, '--no-merges')
                                endif
                                call add(args, '-L' . a:line1 . ',' . a:count . ':' . path[1:-1])
                                let state.ignore_commit = 1
                              endif
                              if len(path) && empty(filter(copy(args), 'v:val =~# "^[^-]"'))
                                let owner = s:Owner(@%, dir)
                                if len(owner)
                                  call add(args, owner)
                                endif
                              endif
                              if empty(extra_paths)
                                let path = ''
                              endif
                              if s:HasOpt(args, '-g', '--walk-reflogs')
                                let format = "%gd %P\t%H %gs"
                              else
                                let format = "%h %P\t%H " . g:fugitive_summary_format
                              endif
                              let cmd = ['--no-pager']
                              if fugitive#GitVersion(1, 9)
                                call extend(cmd, ['-c', 'diff.context=0', '-c', 'diff.noprefix=false', 'log'])
                              else
                                call extend(cmd, ['log', '-U0', '-s'])
                              endif
                              call extend(cmd,
                                    \ ['--no-color', '--no-ext-diff', '--pretty=format:fugitive ' . format] +
                                    \ args + extra_args + paths + extra_paths)
                              let state.target = path
                              let title = titlepre . (listnr < 0 ? 'Gclog ' : 'Gllog ') . s:fnameescape(args + paths)
                              if empty(paths + extra_paths) && empty(a:type) && a:count < 0 && len(s:Relative('/'))
                                let after = '|echohl WarningMsg|echo ' . string('Use :0Glog or :0Gclog for old behavior of targeting current file') . '|echohl NONE' . after
                              endif
                              return s:QuickfixStream(listnr, 'log', title, s:UserCommandList(dir) + cmd, !a:bang, s:function('s:LogParse'), state, dir) . after
                            endfunction
                            
                            " Section: :Gedit, :Gpedit, :Gsplit, :Gvsplit, :Gtabedit, :Gread
                            
    1              0.000006 function! s:UsableWin(nr) abort
                              return a:nr && !getwinvar(a:nr, '&previewwindow') && !getwinvar(a:nr, '&winfixwidth') &&
                                    \ (empty(getwinvar(a:nr, 'fugitive_status')) || getbufvar(winbufnr(a:nr), 'fugitive_type') !=# 'index') &&
                                    \ index(['gitrebase', 'gitcommit'], getbufvar(winbufnr(a:nr), '&filetype')) < 0 &&
                                    \ index(['nofile','help','quickfix'], getbufvar(winbufnr(a:nr), '&buftype')) < 0
                            endfunction
                            
    1              0.000005 function! s:OpenParse(args, wants_cmd) abort
                              let opts = []
                              let cmds = []
                              let args = copy(a:args)
                              while !empty(args)
                                if args[0] =~# '^++'
                                  call add(opts, ' ' . escape(remove(args, 0), ' |"'))
                                elseif a:wants_cmd && args[0] =~# '^+'
                                  call add(cmds, remove(args, 0)[1:-1])
                                else
                                  break
                                endif
                              endwhile
                              if len(args)
                                let file = join(args)
                              elseif empty(expand('%'))
                                let file = ''
                              elseif empty(s:DirCommitFile(@%)[1]) && s:Relative('./') !~# '^\./\.git\>'
                                let file = '>:0'
                              else
                                let file = '>'
                              endif
                              let dir = s:Dir()
                              let efile = s:Expand(file)
                              let url = fugitive#Find(efile, dir)
                            
                              if a:wants_cmd && file[0] ==# '>' && efile[0] !=# '>' && get(b:, 'fugitive_type', '') isnot# 'tree' && &filetype !=# 'netrw'
                                let line = line('.')
                                if expand('%:p') !=# url
                                  let diffcmd = 'diff'
                                  let from = s:DirRev(@%)[1]
                                  let to = s:DirRev(url)[1]
                                  if empty(from) && empty(to)
                                    let diffcmd = 'diff-files'
                                    let args = ['--', expand('%:p'), url]
                                  elseif empty(to)
                                    let args = [from, '--', url]
                                  elseif empty(from)
                                    let args = [to, '--', expand('%:p')]
                                    let reverse = 1
                                  else
                                    let args = [from, to]
                                  endif
                                  let [res, exec_error] = s:LinesError([dir, diffcmd, '-U0'] + args)
                                  if !exec_error
                                    call filter(res, 'v:val =~# "^@@ "')
                                    call map(res, 'substitute(v:val, ''[-+]\d\+\zs '', ",1 ", "g")')
                                    call map(res, 'matchlist(v:val, ''^@@ -\(\d\+\),\(\d\+\) +\(\d\+\),\(\d\+\) @@'')[1:4]')
                                    if exists('reverse')
                                      call map(res, 'v:val[2:3] + v:val[0:1]')
                                    endif
                                    call filter(res, 'v:val[0] < '.line('.'))
                                    let hunk = get(res, -1, [0,0,0,0])
                                    if hunk[0] + hunk[1] > line('.')
                                      let line = hunk[2] + max([1 - hunk[3], 0])
                                    else
                                      let line = hunk[2] + max([hunk[3], 1]) + line('.') - hunk[0] - max([hunk[1], 1])
                                    endif
                                  endif
                                endif
                                call insert(cmds, line)
                              endif
                            
                              let pre = join(opts, '')
                              if len(cmds) > 1
                                let pre .= ' +' . escape(join(map(cmds, '"exe ".string(v:val)'), '|'), ' |"')
                              elseif len(cmds)
                                let pre .= ' +' . escape(cmds[0], ' |"')
                              endif
                              return [url, pre]
                            endfunction
                            
    1              0.000004 function! fugitive#DiffClose() abort
                              let mywinnr = winnr()
                              for winnr in [winnr('#')] + range(winnr('$'),1,-1)
                                if winnr != mywinnr && getwinvar(winnr,'&diff')
                                  execute winnr.'wincmd w'
                                  close
                                  if winnr('$') > 1
                                    wincmd p
                                  endif
                                endif
                              endfor
                              diffoff!
                            endfunction
                            
    1              0.000005 function! s:BlurStatus() abort
                              if (&previewwindow || exists('w:fugitive_status')) && get(b:,'fugitive_type', '') ==# 'index'
                                let winnrs = filter([winnr('#')] + range(1, winnr('$')), 's:UsableWin(v:val)')
                                if len(winnrs)
                                  exe winnrs[0].'wincmd w'
                                else
                                  belowright new
                                endif
                                if &diff
                                  call fugitive#DiffClose()
                                endif
                              endif
                            endfunction
                            
    1              0.000006 function! s:OpenExec(cmd, mods, env, args, ...) abort
                              let options = a:0 ? a:1 : {'dir': s:Dir()}
                              let temp = tempname()
                              let columns = get(g:, 'fugitive_columns', 80)
                              let env = s:BuildEnvPrefix(extend({'COLUMNS': columns}, a:env))
                              silent! execute '!' . escape(env . s:UserCommand(options, ['--no-pager'] + a:args), '!#%') .
                                    \ (&shell =~# 'csh' ? ' >& ' . temp : ' > ' . temp . ' 2>&1')
                              redraw!
                              let temp = s:Resolve(temp)
                              let first = join(readfile(temp, '', 2), "\n")
                              if first =~# '\<\([[:upper:][:digit:]_-]\+(\d\+)\).*\1'
                                let filetype = 'man'
                              else
                                let filetype = 'git'
                              endif
                              let s:temp_files[s:cpath(temp)] = { 'dir': options.dir, 'filetype': filetype }
                              if a:cmd ==# 'edit'
                                call s:BlurStatus()
                              endif
                              silent execute s:Mods(a:mods) . a:cmd temp
                              call fugitive#ReloadStatus(options.dir, 1)
                              return 'echo ' . string(':!' . s:UserCommand(options, a:args))
                            endfunction
                            
    1              0.000007 function! fugitive#Open(cmd, bang, mods, arg, args) abort
                              if a:bang
                                return s:OpenExec(a:cmd, a:mods, {}, s:SplitExpand(a:arg, s:Tree()))
                              endif
                            
                              let mods = s:Mods(a:mods)
                              try
                                let [file, pre] = s:OpenParse(a:args, 1)
                              catch /^fugitive:/
                                return 'echoerr ' . string(v:exception)
                              endtry
                              if file !~# '^\a\a\+:'
                                let file = s:sub(file, '/$', '')
                              endif
                              if a:cmd ==# 'edit'
                                call s:BlurStatus()
                              endif
                              return mods . a:cmd . pre . ' ' . s:fnameescape(file)
                            endfunction
                            
    1              0.000007 function! s:ReadPrepare(line1, count, range, mods) abort
                              let mods = s:Mods(a:mods)
                              let after = a:count
                              if a:count < 0
                                let delete = 'silent 1,' . line('$') . 'delete_|'
                                let after = line('$')
                              elseif a:range == 2
                                let delete = 'silent ' . a:line1 . ',' . a:count . 'delete_|'
                              else
                                let delete = ''
                              endif
                              if foldlevel(after)
                                let pre = after . 'foldopen!|'
                              else
                                let pre = ''
                              endif
                              return [pre . mods . after . 'read', delete . 'diffupdate' . (a:count < 0 ? '|' . line('.') : '')]
                            endfunction
                            
    1              0.000008 function! s:ReadExec(line1, count, range, mods, env, args, options) abort
                              let [read, post] = s:ReadPrepare(a:line1, a:count, a:range, a:mods)
                              let env = s:BuildEnvPrefix(extend({'COLUMNS': &tw ? &tw : 80}, a:env))
                              silent execute read . '!' escape(env . s:UserCommand(a:options, ['--no-pager'] + a:args), '!#%')
                              execute post
                              call fugitive#ReloadStatus(a:options.dir, 1)
                              return 'redraw|echo '.string(':!'.s:UserCommand(a:options, a:args))
                            endfunction
                            
    1              0.000008 function! fugitive#ReadCommand(line1, count, range, bang, mods, arg, args) abort
                              if a:bang
                                let dir = s:Dir()
                                let args = s:SplitExpand(a:arg, s:Tree(dir))
                                return s:ReadExec(a:line1, a:count, a:range, a:mods, {}, args, {'dir': dir})
                              endif
                              let [read, post] = s:ReadPrepare(a:line1, a:count, a:range, a:mods)
                              try
                                let [file, pre] = s:OpenParse(a:args, 0)
                              catch /^fugitive:/
                                return 'echoerr ' . string(v:exception)
                              endtry
                              if file =~# '^fugitive:' && a:count is# 0
                                return 'exe ' .string(s:Mods(a:mods) . fugitive#FileReadCmd(file, 0, pre)) . '|diffupdate'
                              endif
                              return read . ' ' . pre . ' ' . s:fnameescape(file) . '|' . post
                            endfunction
                            
    1              0.000006 function! fugitive#EditComplete(A, L, P) abort
                              if a:A =~# '^>'
                                return map(s:FilterEscape(s:CompleteHeads(s:Dir()), a:A[1:-1]), "'>' . v:val")
                              else
                                return fugitive#CompleteObject(a:A, a:L, a:P)
                              endif
                            endfunction
                            
    1              0.000005 function! fugitive#ReadComplete(A, L, P) abort
                              if a:L =~# '^\w\+!'
                                return fugitive#Complete(a:A, a:L, a:P)
                              else
                                return fugitive#EditComplete(a:A, a:L, a:P)
                              endif
                            endfunction
                            
                            " Section: :Gwrite, :Gwq
                            
    1              0.000008 function! fugitive#WriteCommand(line1, line2, range, bang, mods, arg, args) abort
                              if s:cpath(expand('%:p'), fugitive#Find('.git/COMMIT_EDITMSG'))
                                return (empty($GIT_INDEX_FILE) ? 'write|bdelete' : 'wq') . (a:bang ? '!' : '')
                              elseif get(b:, 'fugitive_type', '') ==# 'index'
                                return 'Git commit'
                              elseif &buftype ==# 'nowrite' && getline(4) =~# '^[+-]\{3\} '
                                return 'echoerr ' . string('fugitive: :Gwrite from :Git diff has been removed in favor of :Git add --edit')
                              endif
                              let mytab = tabpagenr()
                              let mybufnr = bufnr('')
                              try
                                let file = len(a:args) ? s:Generate(s:Expand(join(a:args, ' '))) : fugitive#Real(@%)
                              catch /^fugitive:/
                                return 'echoerr ' . string(v:exception)
                              endtry
                              if empty(file)
                                return 'echoerr '.string('fugitive: cannot determine file path')
                              endif
                              if file =~# '^fugitive:'
                                return 'write' . (a:bang ? '! ' : ' ') . s:fnameescape(file)
                              endif
                              exe s:DirCheck()
                              let always_permitted = s:cpath(fugitive#Real(@%), file) && empty(s:DirCommitFile(@%)[1])
                              if !always_permitted && !a:bang && (len(s:TreeChomp('diff', '--name-status', 'HEAD', '--', file)) || len(s:TreeChomp('ls-files', '--others', '--', file)))
                                let v:errmsg = 'fugitive: file has uncommitted changes (use ! to override)'
                                return 'echoerr v:errmsg'
                              endif
                              let treebufnr = 0
                              for nr in range(1,bufnr('$'))
                                if fnamemodify(bufname(nr),':p') ==# file
                                  let treebufnr = nr
                                endif
                              endfor
                            
                              if treebufnr > 0 && treebufnr != bufnr('')
                                let temp = tempname()
                                silent execute 'keepalt %write '.temp
                                for tab in [mytab] + range(1,tabpagenr('$'))
                                  for winnr in range(1,tabpagewinnr(tab,'$'))
                                    if tabpagebuflist(tab)[winnr-1] == treebufnr
                                      execute 'tabnext '.tab
                                      if winnr != winnr()
                                        execute winnr.'wincmd w'
                                        let restorewinnr = 1
                                      endif
                                      try
                                        let lnum = line('.')
                                        let last = line('$')
                                        silent execute '$read '.temp
                                        silent execute '1,'.last.'delete_'
                                        silent write!
                                        silent execute lnum
                                        diffupdate
                                        let did = 1
                                      finally
                                        if exists('restorewinnr')
                                          wincmd p
                                        endif
                                        execute 'tabnext '.mytab
                                      endtry
                                      break
                                    endif
                                  endfor
                                endfor
                                if !exists('did')
                                  call writefile(readfile(temp,'b'),file,'b')
                                endif
                              else
                                execute 'write! '.s:fnameescape(file)
                              endif
                            
                              if a:bang
                                let [error, exec_error] = s:ChompError(['add', '--force', '--', file])
                              else
                                let [error, exec_error] = s:ChompError(['add', '--', file])
                              endif
                              if exec_error
                                let v:errmsg = 'fugitive: '.error
                                return 'echoerr v:errmsg'
                              endif
                              if s:cpath(fugitive#Real(@%), file) && s:DirCommitFile(@%)[1] =~# '^\d$'
                                setlocal nomodified
                              endif
                            
                              let one = s:Generate(':1:'.file)
                              let two = s:Generate(':2:'.file)
                              let three = s:Generate(':3:'.file)
                              for nr in range(1,bufnr('$'))
                                let name = fnamemodify(bufname(nr), ':p')
                                if bufloaded(nr) && !getbufvar(nr,'&modified') && (name ==# one || name ==# two || name ==# three)
                                  execute nr.'bdelete'
                                endif
                              endfor
                            
                              unlet! restorewinnr
                              let zero = s:Generate(':0:'.file)
                              silent exe s:DoAutocmd('BufWritePost ' . s:fnameescape(zero))
                              for tab in range(1,tabpagenr('$'))
                                for winnr in range(1,tabpagewinnr(tab,'$'))
                                  let bufnr = tabpagebuflist(tab)[winnr-1]
                                  let bufname = fnamemodify(bufname(bufnr), ':p')
                                  if bufname ==# zero && bufnr != mybufnr
                                    execute 'tabnext '.tab
                                    if winnr != winnr()
                                      execute winnr.'wincmd w'
                                      let restorewinnr = 1
                                    endif
                                    try
                                      let lnum = line('.')
                                      let last = line('$')
                                      silent execute '$read '.s:fnameescape(file)
                                      silent execute '1,'.last.'delete_'
                                      silent execute lnum
                                      setlocal nomodified
                                      diffupdate
                                    finally
                                      if exists('restorewinnr')
                                        wincmd p
                                      endif
                                      execute 'tabnext '.mytab
                                    endtry
                                    break
                                  endif
                                endfor
                              endfor
                              call fugitive#ReloadStatus(-1, 1)
                              return 'checktime'
                            endfunction
                            
    1              0.000005 function! fugitive#WqCommand(...) abort
                              let bang = a:4 ? '!' : ''
                              if s:cpath(expand('%:p'), fugitive#Find('.git/COMMIT_EDITMSG'))
                                return 'wq'.bang
                              endif
                              let result = call('fugitive#WriteCommand', a:000)
                              if result =~# '^\%(write\|wq\|echoerr\)'
                                return s:sub(result,'^write','wq')
                              else
                                return result.'|quit'.bang
                              endif
                            endfunction
                            
                            " Section: :Git push, :Git fetch
                            
    1              0.000006 function! fugitive#PushComplete(A, L, P, ...) abort
                              return s:CompleteSub('push', a:A, a:L, a:P, function('s:CompleteRemote'), a:000)
                            endfunction
                            
    1              0.000005 function! fugitive#FetchComplete(A, L, P, ...) abort
                              return s:CompleteSub('fetch', a:A, a:L, a:P, function('s:CompleteRemote'), a:000)
                            endfunction
                            
    1              0.000005 function! s:Dispatch(bang, options) abort
                              let dir = a:options.dir
                              exe s:DirCheck(dir)
                              let [mp, efm, cc] = [&l:mp, &l:efm, get(b:, 'current_compiler', '')]
                              try
                                let b:current_compiler = 'git'
                                let &l:errorformat = s:common_efm .
                                      \ ',%\&git_dir=' . escape(substitute(dir, '%', '%%', 'g'), '\,')
                                let &l:makeprg = s:UserCommand({'git': a:options.git, 'dir': dir}, s:AskPassArgs(dir) + a:options.flags + [a:options.command] + a:options.args)
                                if exists(':Make') == 2
                                  Make
                                  return ''
                                else
                                  if !has('patch-8.1.0334') && has('terminal') && &autowrite
                                    let autowrite_was_set = 1
                                    set noautowrite
                                    silent! wall
                                  endif
                                  silent noautocmd make!
                                  redraw!
                                  return 'call fugitive#Cwindow()|silent ' . s:DoAutocmd('ShellCmdPost')
                                endif
                              finally
                                let [&l:mp, &l:efm, b:current_compiler] = [mp, efm, cc]
                                if empty(cc) | unlet! b:current_compiler | endif
                                if exists('autowrite_was_set')
                                  set autowrite
                                endif
                              endtry
                            endfunction
                            
    1              0.000007 function! s:PushSubcommand(line1, line2, range, bang, mods, options) abort
                              return s:Dispatch(a:bang ? '!' : '', a:options)
                            endfunction
                            
    1              0.000007 function! s:FetchSubcommand(line1, line2, range, bang, mods, options) abort
                              return s:Dispatch(a:bang ? '!' : '', a:options)
                            endfunction
                            
                            " Section: :Gdiff
                            
    1              0.000010 augroup fugitive_diff
    1              0.000317   autocmd!
    1              0.000025   autocmd BufWinLeave * nested
                                    \ if s:can_diffoff(+expand('<abuf>')) && s:diff_window_count() == 2 |
                                    \   call s:diffoff_all(s:Dir(+expand('<abuf>'))) |
                                    \ endif
    1              0.000014   autocmd BufWinEnter * nested
                                    \ if s:can_diffoff(+expand('<abuf>')) && s:diff_window_count() == 1 |
                                    \   call s:diffoff() |
                                    \ endif
    1              0.000003 augroup END
                            
    1              0.000007 function! s:can_diffoff(buf) abort
                              return getwinvar(bufwinnr(a:buf), '&diff') &&
                                    \ !empty(getwinvar(bufwinnr(a:buf), 'fugitive_diff_restore'))
                            endfunction
                            
    1              0.000015 function! fugitive#CanDiffoff(buf) abort
                              return s:can_diffoff(bufnr(a:buf))
                            endfunction
                            
    1              0.000005 function! s:diff_modifier(count) abort
                              let fdc = matchstr(&diffopt, 'foldcolumn:\zs\d\+')
                              if &diffopt =~# 'horizontal' && &diffopt !~# 'vertical'
                                return ''
                              elseif &diffopt =~# 'vertical'
                                return 'vertical '
                              elseif winwidth(0) <= a:count * ((&tw ? &tw : 80) + (empty(fdc) ? 2 : fdc))
                                return ''
                              else
                                return 'vertical '
                              endif
                            endfunction
                            
    1              0.000004 function! s:diff_window_count() abort
                              let c = 0
                              for nr in range(1,winnr('$'))
                                let c += getwinvar(nr,'&diff')
                              endfor
                              return c
                            endfunction
                            
    1              0.000004 function! s:diff_restore() abort
                              let restore = 'setlocal nodiff noscrollbind'
                                    \ . ' scrollopt=' . &l:scrollopt
                                    \ . (&l:wrap ? ' wrap' : ' nowrap')
                                    \ . ' foldlevel=999'
                                    \ . ' foldmethod=' . &l:foldmethod
                                    \ . ' foldcolumn=' . &l:foldcolumn
                                    \ . ' foldlevel=' . &l:foldlevel
                                    \ . (&l:foldenable ? ' foldenable' : ' nofoldenable')
                              if has('cursorbind')
                                let restore .= (&l:cursorbind ? ' ' : ' no') . 'cursorbind'
                              endif
                              return restore
                            endfunction
                            
    1              0.000004 function! s:diffthis() abort
                              if !&diff
                                let w:fugitive_diff_restore = s:diff_restore()
                                diffthis
                              endif
                            endfunction
                            
    1              0.000004 function! s:diffoff() abort
                              if exists('w:fugitive_diff_restore')
                                execute w:fugitive_diff_restore
                                unlet w:fugitive_diff_restore
                              else
                                diffoff
                              endif
                            endfunction
                            
    1              0.000005 function! s:diffoff_all(dir) abort
                              let curwin = winnr()
                              for nr in range(1,winnr('$'))
                                if getwinvar(nr, '&diff') && !empty(getwinvar(nr, 'fugitive_diff_restore'))
                                  if nr != winnr()
                                    execute nr.'wincmd w'
                                  endif
                                  call s:diffoff()
                                endif
                              endfor
                              execute curwin.'wincmd w'
                            endfunction
                            
    1              0.000005 function! s:CompareAge(mine, theirs) abort
                              let scores = {':0': 1, ':1': 2, ':2': 3, ':': 4, ':3': 5}
                              let mine = substitute(a:mine, '^:', '', '')
                              let theirs = substitute(a:theirs, '^:', '', '')
                              let my_score    = get(scores, ':'.mine, 0)
                              let their_score = get(scores, ':'.theirs, 0)
                              if my_score || their_score
                                return my_score < their_score ? -1 : my_score != their_score
                              elseif mine ==# theirs
                                return 0
                              endif
                              let base = s:TreeChomp('merge-base', mine, theirs)
                              if base ==# mine
                                return -1
                              elseif base ==# theirs
                                return 1
                              endif
                              let my_time    = +s:TreeChomp('log', '--max-count=1', '--pretty=format:%at', a:mine, '--')
                              let their_time = +s:TreeChomp('log', '--max-count=1', '--pretty=format:%at', a:theirs, '--')
                              return my_time < their_time ? -1 : my_time != their_time
                            endfunction
                            
    1              0.000004 function! s:IsConflicted() abort
                              return len(@%) && !empty(s:ChompDefault('', 'ls-files', '--unmerged', '--', expand('%:p')))
                            endfunction
                            
    1              0.000007 function! fugitive#Diffsplit(autodir, keepfocus, mods, arg, args) abort
                              let args = copy(a:args)
                              let post = ''
                              if get(args, 0) =~# '^+'
                                let post = remove(args, 0)[1:-1]
                              endif
                              if exists(':DiffGitCached') && empty(args)
                                return s:Mods(a:mods) . 'DiffGitCached' . (len(post) ? '|' . post : '')
                              endif
                              let commit = s:DirCommitFile(@%)[1]
                              if a:mods =~# '\<tab\>'
                                let mods = substitute(a:mods, '\<tab\>', '', 'g')
                                let pre = 'tab split'
                              else
                                let mods = 'keepalt ' . a:mods
                                let pre = ''
                              endif
                              let back = exists('*win_getid') ? 'call win_gotoid(' . win_getid() . ')' : 'wincmd p'
                              if (empty(args) || args[0] ==# ':') && a:keepfocus
                                exe s:DirCheck()
                                if empty(commit) && s:IsConflicted()
                                  let parents = [s:Relative(':2:'), s:Relative(':3:')]
                                elseif empty(commit)
                                  let parents = [s:Relative(':0:')]
                                elseif commit =~# '^\d\=$'
                                  let parents = [s:Relative('HEAD:')]
                                elseif commit =~# '^\x\x\+$'
                                  let parents = s:LinesError(['rev-parse', commit . '^@'])[0]
                                  call map(parents, 's:Relative(v:val . ":")')
                                endif
                              endif
                              try
                                if exists('parents') && len(parents) > 1
                                  exe pre
                                  let mods = (a:autodir ? s:diff_modifier(len(parents) + 1) : '') . s:Mods(mods, 'leftabove')
                                  let nr = bufnr('')
                                  execute mods 'split' s:fnameescape(s:Generate(parents[0]))
                                  call s:Map('n', 'dp', ':diffput '.nr.'<Bar>diffupdate<CR>', '<silent>')
                                  let nr2 = bufnr('')
                                  call s:diffthis()
                                  exe back
                                  call s:Map('n', 'd2o', ':diffget '.nr2.'<Bar>diffupdate<CR>', '<silent>')
                                  let mods = substitute(mods, '\Cleftabove\|rightbelow\|aboveleft\|belowright', '\=submatch(0) =~# "f" ? "rightbelow" : "leftabove"', '')
                                  for i in range(len(parents)-1, 1, -1)
                                    execute mods 'split' s:fnameescape(s:Generate(parents[i]))
                                    call s:Map('n', 'dp', ':diffput '.nr.'<Bar>diffupdate<CR>', '<silent>')
                                    let nrx = bufnr('')
                                    call s:diffthis()
                                    exe back
                                    call s:Map('n', 'd' . (i + 2) . 'o', ':diffget '.nrx.'<Bar>diffupdate<CR>', '<silent>')
                                  endfor
                                  call s:diffthis()
                                  if len(parents) > 1
                                    wincmd =
                                  endif
                                  return post
                                elseif len(args)
                                  let arg = join(args, ' ')
                                  if arg ==# ''
                                    return post
                                  elseif arg ==# ':/'
                                    exe s:DirCheck()
                                    let file = s:Relative()
                                  elseif arg ==# ':'
                                    exe s:DirCheck()
                                    let file = s:Relative(':0:')
                                  elseif arg =~# '^:\d$'
                                    exe s:DirCheck()
                                    let file = s:Relative(arg . ':')
                                  elseif arg =~# '^[~^]\d*$'
                                    return 'echoerr ' . string('fugitive: change ' . arg . ' to !' . arg . ' to diff against ancestor')
                                  else
                                    try
                                      let file = arg =~# '^:/.' ? fugitive#RevParse(arg) . s:Relative(':') : s:Expand(arg)
                                    catch /^fugitive:/
                                      return 'echoerr ' . string(v:exception)
                                    endtry
                                  endif
                                elseif exists('parents') && len(parents)
                                  let file = parents[-1]
                                elseif len(commit)
                                  let file = s:Relative()
                                elseif s:IsConflicted()
                                  let file = s:Relative(':1:')
                                  let post = 'echohl WarningMsg|echo "Use :Gdiffsplit! for 3 way diff"|echohl NONE|' . post
                                else
                                  exe s:DirCheck()
                                  let file = s:Relative(':0:')
                                endif
                                let spec = s:Generate(file)
                                if spec =~# '^fugitive:' && empty(s:DirCommitFile(spec)[2])
                                  let spec = FugitiveVimPath(spec . s:Relative('/'))
                                endif
                                exe pre
                                let restore = s:diff_restore()
                                let w:fugitive_diff_restore = restore
                                if len(spec) && s:CompareAge(commit, s:DirCommitFile(spec)[1]) < 0
                                  let mods = s:Mods(mods, 'rightbelow')
                                else
                                  let mods = s:Mods(mods, 'leftabove')
                                endif
                                let mods = (a:autodir ? s:diff_modifier(2) : '') . mods
                                if &diffopt =~# 'vertical'
                                  let diffopt = &diffopt
                                  set diffopt-=vertical
                                endif
                                execute mods 'diffsplit' s:fnameescape(spec)
                                let &l:readonly = &l:readonly
                                redraw
                                let w:fugitive_diff_restore = restore
                                let winnr = winnr()
                                if getwinvar('#', '&diff')
                                  if a:keepfocus
                                    exe back
                                  endif
                                endif
                                return post
                              catch /^fugitive:/
                                return 'echoerr ' . string(v:exception)
                              finally
                                if exists('diffopt')
                                  let &diffopt = diffopt
                                endif
                              endtry
                            endfunction
                            
                            " Section: :Gmove, :Gremove
                            
    1              0.000006 function! s:Move(force, rename, destination) abort
                              let dir = s:Dir()
                              exe s:DirCheck(dir)
                              if s:DirCommitFile(@%)[1] !~# '^0\=$' || empty(@%)
                                return 'echoerr ' . string('fugitive: mv not supported for this buffer')
                              endif
                              if a:destination =~# '^\a\+:\|^/'
                                let destination = a:destination
                              elseif a:destination =~# '^:/:\='
                                let destination = s:Tree(dir) . substitute(a:destination, '^:/:\=', '', '')
                              elseif a:destination =~# '^:(\%(top\|top,literal\|literal,top\))'
                                let destination = s:Tree(dir) . matchstr(a:destination, ')\zs.*')
                              elseif a:destination =~# '^:(literal)'
                                let destination = simplify(getcwd() . '/' . matchstr(a:destination, ')\zs.*'))
                              elseif a:rename
                                let destination = simplify(expand('%:p:s?[\/]$??:h') . '/' . a:destination)
                              elseif a:destination =~# '^\.\.\=\%(/\|$\)'
                                let destination = simplify(getcwd() . '/' . a:destination)
                              else
                                let destination = s:Tree(dir) . '/' . a:destination
                              endif
                              let destination = s:Slash(destination)
                              if isdirectory(@%)
                                setlocal noswapfile
                              endif
                              let [message, exec_error] = s:ChompError(['mv'] + (a:force ? ['-f'] : []) + ['--', expand('%:p'), destination], dir)
                              if exec_error
                                let v:errmsg = 'fugitive: '.message
                                return 'echoerr v:errmsg'
                              endif
                              if isdirectory(destination)
                                let destination = fnamemodify(s:sub(destination,'/$','').'/'.expand('%:t'),':.')
                              endif
                              let reload = '|call fugitive#ReloadStatus(' . string(dir) . ', 1)'
                              if empty(s:DirCommitFile(@%)[1])
                                if isdirectory(destination)
                                  return 'keepalt edit '.s:fnameescape(destination) . reload
                                else
                                  return 'keepalt saveas! '.s:fnameescape(destination) . reload
                                endif
                              else
                                return 'file '.s:fnameescape(fugitive#Find(':0:'.destination, dir)) . reload
                              endif
                            endfunction
                            
    1              0.000006 function! fugitive#RenameComplete(A,L,P) abort
                              if a:A =~# '^[.:]\=/'
                                return fugitive#CompletePath(a:A)
                              else
                                let pre = s:Slash(fnamemodify(expand('%:p:s?[\/]$??'), ':h')) . '/'
                                return map(fugitive#CompletePath(pre.a:A), 'strpart(v:val, len(pre))')
                              endif
                            endfunction
                            
    1              0.000013 function! fugitive#MoveCommand(line1, line2, range, bang, mods, arg, args) abort
                              return s:Move(a:bang, 0, a:arg)
                            endfunction
                            
    1              0.000011 function! fugitive#RenameCommand(line1, line2, range, bang, mods, arg, args) abort
                              return s:Move(a:bang, 1, a:arg)
                            endfunction
                            
    1              0.000006 function! s:Remove(after, force) abort
                              let dir = s:Dir()
                              exe s:DirCheck(dir)
                              if len(@%) && s:DirCommitFile(@%)[1] ==# ''
                                let cmd = ['rm']
                              elseif s:DirCommitFile(@%)[1] ==# '0'
                                let cmd = ['rm','--cached']
                              else
                                return 'echoerr ' . string('fugitive: rm not supported for this buffer')
                              endif
                              if a:force
                                let cmd += ['--force']
                              endif
                              let [message, exec_error] = s:ChompError(cmd + ['--', expand('%:p')], dir)
                              if exec_error
                                let v:errmsg = 'fugitive: '.s:sub(message,'error:.*\zs\n\(.*-f.*',' (add ! to force)')
                                return 'echoerr '.string(v:errmsg)
                              else
                                return a:after . (a:force ? '!' : ''). '|call fugitive#ReloadStatus(' . string(dir) . ', 1)'
                              endif
                            endfunction
                            
    1              0.000014 function! fugitive#RemoveCommand(line1, line2, range, bang, mods, arg, args) abort
                              return s:Remove('edit', a:bang)
                            endfunction
                            
    1              0.000008 function! fugitive#DeleteCommand(line1, line2, range, bang, mods, arg, args) abort
                              return s:Remove('bdelete', a:bang)
                            endfunction
                            
                            " Section: :Git blame
                            
    1              0.000004 function! s:Keywordprg() abort
                              let args = ' --git-dir='.escape(s:Dir(),"\\\"' ")
                              if has('gui_running') && !has('win32')
                                return g:fugitive_git_executable . ' --no-pager' . args . ' log -1'
                              else
                                return g:fugitive_git_executable . args . ' show'
                              endif
                            endfunction
                            
    1              0.000004 function! s:linechars(pattern) abort
                              let chars = strlen(s:gsub(matchstr(getline('.'), a:pattern), '.', '.'))
                              if exists('*synconcealed') && &conceallevel > 1
                                for col in range(1, chars)
                                  let chars -= synconcealed(line('.'), col)[0]
                                endfor
                              endif
                              return chars
                            endfunction
                            
    1              0.000004 function! s:BlameBufnr(...) abort
                              let state = s:TempState(bufname(a:0 ? a:1 : ''))
                              if get(state, 'filetype', '') ==# 'fugitiveblame'
                                return get(state, 'bufnr', -1)
                              else
                                return -1
                              endif
                            endfunction
                            
    1              0.000005 function! s:BlameCommitFileLnum(...) abort
                              let line = a:0 ? a:1 : getline('.')
                              let state = a:0 ? a:2 : s:TempState()
                              let commit = matchstr(line, '^\^\=\zs\x\+')
                              if commit =~# '^0\+$'
                                let commit = ''
                              elseif has_key(state, 'blame_reverse_end')
                                let commit = get(s:LinesError(state.dir, 'rev-list', '--ancestry-path', '--reverse', commit . '..' . state.blame_reverse_end)[0], 0, '')
                              endif
                              let lnum = +matchstr(line, ' \zs\d\+\ze \%((\| *\d\+)\)')
                              let path = matchstr(line, '^\^\=[?*]*\x* \+\%(\d\+ \+\d\+ \+\)\=\zs.\{-\}\ze\s*\d\+ \%((\| *\d\+)\)')
                              if empty(path) && lnum
                                let path = get(state, 'blame_file', '')
                              endif
                              return [commit, path, lnum]
                            endfunction
                            
    1              0.000004 function! s:BlameLeave() abort
                              let bufwinnr = bufwinnr(s:BlameBufnr())
                              if bufwinnr > 0
                                let bufnr = bufnr('')
                                exe bufwinnr . 'wincmd w'
                                return bufnr . 'bdelete'
                              endif
                              return ''
                            endfunction
                            
    1              0.000004 function! s:BlameQuit() abort
                              let cmd = s:BlameLeave()
                              if empty(cmd)
                                return 'bdelete'
                              elseif len(s:DirCommitFile(@%)[1])
                                return cmd . '|Gedit'
                              else
                                return cmd
                              endif
                            endfunction
                            
    1              0.000006 function! fugitive#BlameComplete(A, L, P) abort
                              return s:CompleteSub('blame', a:A, a:L, a:P)
                            endfunction
                            
    1              0.000007 function! s:BlameSubcommand(line1, count, range, bang, mods, options) abort
                              let dir = s:Dir()
                              exe s:DirCheck(dir)
                              let flags = copy(a:options.args)
                              let i = 0
                              let raw = 0
                              let commits = []
                              let files = []
                              let ranges = []
                              if a:line1 > 0 && a:count > 0 && a:range != 1
                                call extend(ranges, ['-L', a:line1 . ',' . a:count])
                              endif
                              while i < len(flags)
                                let match = matchlist(flags[i], '^\(-[a-zABDFH-KN-RT-Z]\)\ze\(.*\)')
                                if len(match) && len(match[2])
                                  call insert(flags, match[1])
                                  let flags[i+1] = '-' . match[2]
                                  continue
                                endif
                                let arg = flags[i]
                                if arg =~# '^-p$\|^--\%(help\|porcelain\|line-porcelain\|incremental\)$'
                                  let raw = 1
                                elseif arg ==# '--contents' && i + 1 < len(flags)
                                  call extend(commits, remove(flags, i, i+1))
                                  continue
                                elseif arg ==# '-L' && i + 1 < len(flags)
                                  call extend(ranges, remove(flags, i, i+1))
                                  continue
                                elseif arg =~# '^--contents='
                                  call add(commits, remove(flags, i))
                                  continue
                                elseif arg =~# '^-L.'
                                  call add(ranges, remove(flags, i))
                                  continue
                                elseif arg =~# '^-[GLS]$\|^--\%(date\|encoding\|contents\|ignore-rev\|ignore-revs-file\)$'
                                  let i += 1
                                  if i == len(flags)
                                    echohl ErrorMsg
                                    echo s:ChompError(['blame', arg])[0]
                                    echohl NONE
                                    return ''
                                  endif
                                elseif arg ==# '--'
                                  if i + 1 < len(flags)
                                    call extend(files, remove(flags, i + 1, -1))
                                  endif
                                  call remove(flags, i)
                                  break
                                elseif arg !~# '^-' && (s:HasOpt(flags, '--not') || arg !~# '^\^')
                                  if index(flags, '--') >= 0
                                    call add(commits, remove(flags, i))
                                    continue
                                  endif
                                  if arg =~# '\.\.' && arg !~# '^\.\.\=\%(/\|$\)' && empty(commits)
                                    call add(commits, remove(flags, i))
                                    continue
                                  endif
                                  try
                                    let dcf = s:DirCommitFile(fugitive#Find(arg, dir))
                                    if len(dcf[1]) && empty(dcf[2])
                                      call add(commits, remove(flags, i))
                                      continue
                                    endif
                                  catch /^fugitive:/
                                  endtry
                                  call add(files, remove(flags, i))
                                  continue
                                endif
                                let i += 1
                              endwhile
                              let file = substitute(get(files, 0, get(s:TempState(), 'blame_file', s:Relative('./', dir))), '^\.\%(/\|$\)', '', '')
                              if empty(commits) && len(files) > 1
                                call add(commits, remove(files, 1))
                              endif
                              exe s:BlameLeave()
                              try
                                let cmd = a:options.flags + ['--no-pager', '-c', 'blame.coloring=none', '-c', 'blame.blankBoundary=false', a:options.command, '--show-number']
                                call extend(cmd, filter(copy(flags), 'v:val !~# "\\v^%(-b|--%(no-)=color-.*|--progress)$"'))
                                if a:count > 0 && empty(ranges)
                                  let cmd += ['-L', (a:line1 ? a:line1 : line('.')) . ',' . (a:line1 ? a:line1 : line('.'))]
                                endif
                                call extend(cmd, ranges)
                                if len(commits)
                                  let cmd += commits
                                elseif empty(files) && len(matchstr(s:DirCommitFile(@%)[1], '^\x\x\+$'))
                                  let cmd += [matchstr(s:DirCommitFile(@%)[1], '^\x\x\+$')]
                                elseif empty(files) && !s:HasOpt(flags, '--reverse')
                                  let cmd += ['--contents', '-']
                                endif
                                let basecmd = escape(s:UserCommand({'git': a:options.git, 'dir': dir}, cmd + ['--'] + (len(files) ? files : [file])), '!#%')
                                let tempname = tempname()
                                let error = tempname . '.err'
                                let temp = tempname . (raw ? '' : '.fugitiveblame')
                                if &shell =~# 'csh'
                                  silent! execute '%write !('.basecmd.' > '.temp.') >& '.error
                                else
                                  silent! execute '%write !'.basecmd.' > '.temp.' 2> '.error
                                endif
                                let l:shell_error = v:shell_error
                                redraw
                                try
                                  if l:shell_error
                                    let lines = readfile(error)
                                    if empty(lines)
                                      let lines = readfile(temp)
                                    endif
                                    for i in range(len(lines))
                                      if lines[i] =~# '^error: \|^fatal: '
                                        echohl ErrorMsg
                                        echon lines[i]
                                        echohl NONE
                                        break
                                      else
                                        echon lines[i]
                                      endif
                                      if i != len(lines) - 1
                                        echon "\n"
                                      endif
                                    endfor
                                    return ''
                                  endif
                                  let temp_state = {'dir': dir, 'filetype': (raw ? '' : 'fugitiveblame'), 'options': a:options, 'blame_flags': flags, 'blame_file': file}
                                  if s:HasOpt(flags, '--reverse')
                                    let temp_state.blame_reverse_end = matchstr(get(commits, 0, ''), '\.\.\zs.*')
                                  endif
                                  if (a:line1 == 0 || a:range == 1) && a:count > 0
                                    let edit = s:Mods(a:mods) . get(['edit', 'split', 'pedit', 'vsplit', 'tabedit'], a:count - (a:line1 ? a:line1 : 1), 'split')
                                    return s:BlameCommit(edit, get(readfile(temp), 0, ''), temp_state)
                                  else
                                    let temp = s:Resolve(temp)
                                    let s:temp_files[s:cpath(temp)] = temp_state
                                    if len(ranges + commits + files) || raw
                                      let mods = s:Mods(a:mods)
                                      if a:count != 0
                                        exe 'silent keepalt' mods 'split' s:fnameescape(temp)
                                      elseif !&modified || a:bang || &bufhidden ==# 'hide' || (empty(&bufhidden) && &hidden)
                                        exe 'silent' mods 'edit' . (a:bang ? '! ' : ' ') . s:fnameescape(temp)
                                      else
                                        return mods . 'edit ' . s:fnameescape(temp)
                                      endif
                                      return ''
                                    endif
                                    if a:mods =~# '\<tab\>'
                                      silent tabedit %
                                    endif
                                    let bufnr = bufnr('')
                                    let temp_state.bufnr = bufnr
                                    let restore = []
                                    let mods = substitute(a:mods, '\<tab\>', '', 'g')
                                    for winnr in range(winnr('$'),1,-1)
                                      if getwinvar(winnr, '&scrollbind')
                                        if !&l:scrollbind
                                          call setwinvar(winnr, '&scrollbind', 0)
                                        elseif winnr != winnr() && getwinvar(winnr, '&foldenable')
                                          call setwinvar(winnr, '&foldenable', 0)
                                          call add(restore, 'call setwinvar(bufwinnr('.winbufnr(winnr).'),"&foldenable",1)')
                                        endif
                                      endif
                                      if exists('+cursorbind') && !&l:cursorbind && getwinvar(winnr, '&cursorbind')
                                        call setwinvar(winnr, '&cursorbind', 0)
                                      endif
                                      if s:BlameBufnr(winbufnr(winnr)) > 0
                                        execute winbufnr(winnr).'bdelete'
                                      endif
                                    endfor
                                    let restore_winnr = 'bufwinnr(' . bufnr . ')'
                                    if !&l:scrollbind
                                      call add(restore, 'call setwinvar(' . restore_winnr . ',"&scrollbind",0)')
                                    endif
                                    if exists('+cursorbind') && !&l:cursorbind
                                      call add(restore, 'call setwinvar(' . restore_winnr . ',"&cursorbind",0)')
                                    endif
                                    if &l:wrap
                                      call add(restore, 'call setwinvar(' . restore_winnr . ',"&wrap",1)')
                                    endif
                                    if &l:foldenable
                                      call add(restore, 'call setwinvar(' . restore_winnr . ',"&foldenable",1)')
                                    endif
                                    setlocal scrollbind nowrap nofoldenable
                                    if exists('+cursorbind')
                                      setlocal cursorbind
                                    endif
                                    let top = line('w0') + &scrolloff
                                    let current = line('.')
                                    exe 'silent keepalt' (a:bang ? s:Mods(mods) . 'split' : s:Mods(mods, 'leftabove') . 'vsplit') s:fnameescape(temp)
                                    let w:fugitive_leave = join(restore, '|')
                                    execute top
                                    normal! zt
                                    execute current
                                    if exists('+cursorbind')
                                      setlocal cursorbind
                                    endif
                                    setlocal nonumber scrollbind nowrap foldcolumn=0 nofoldenable winfixwidth
                                    if exists('+relativenumber')
                                      setlocal norelativenumber
                                    endif
                                    if exists('+signcolumn')
                                      setlocal signcolumn=no
                                    endif
                                    execute "vertical resize ".(s:linechars('.\{-\}\ze\s\+\d\+)')+1)
                                    call s:Map('n', 'A', ":<C-u>exe 'vertical resize '.(<SID>linechars('.\\{-\\}\\ze [0-9:/+-][0-9:/+ -]* \\d\\+)')+1+v:count)<CR>", '<silent>')
                                    call s:Map('n', 'C', ":<C-u>exe 'vertical resize '.(<SID>linechars('^\\S\\+')+1+v:count)<CR>", '<silent>')
                                    call s:Map('n', 'D', ":<C-u>exe 'vertical resize '.(<SID>linechars('.\\{-\\}\\ze\\d\\ze\\s\\+\\d\\+)')+1-v:count)<CR>", '<silent>')
                                    redraw
                                    syncbind
                                  endif
                                endtry
                                return ''
                              catch /^fugitive:/
                                return 'echoerr ' . string(v:exception)
                              endtry
                            endfunction
                            
    1              0.000006 function! s:BlameCommit(cmd, ...) abort
                              let line = a:0 ? a:1 : getline('.')
                              let state = a:0 ? a:2 : s:TempState()
                              let sigil = has_key(state, 'blame_reverse_end') ? '-' : '+'
                              let mods = (s:BlameBufnr() < 0 ? '' : &splitbelow ? "botright " : "topleft ")
                              let [commit, path, lnum] = s:BlameCommitFileLnum(line, state)
                              if empty(commit) && len(path) && has_key(state, 'blame_reverse_end')
                                let path = (len(state.blame_reverse_end) ? state.blame_reverse_end . ':' : ':(top)') . path
                                return fugitive#Open(mods . a:cmd, 0, '', '+' . lnum . ' ' . s:fnameescape(path), ['+' . lnum, path])
                              endif
                              if commit =~# '^0*$'
                                return 'echoerr ' . string('fugitive: no commit')
                              endif
                              if line =~# '^\^' && !has_key(state, 'blame_reverse_end')
                                let path = commit . ':' . path
                                return fugitive#Open(mods . a:cmd, 0, '', '+' . lnum . ' ' . s:fnameescape(path), ['+' . lnum, path])
                              endif
                              let cmd = fugitive#Open(mods . a:cmd, 0, '', commit, [commit])
                              if cmd =~# '^echoerr'
                                return cmd
                              endif
                              execute cmd
                              if a:cmd ==# 'pedit' || empty(path)
                                return ''
                              endif
                              if search('^diff .* b/\M'.escape(path,'\').'$','W')
                                call search('^+++')
                                let head = line('.')
                                while search('^@@ \|^diff ') && getline('.') =~# '^@@ '
                                  let top = +matchstr(getline('.'),' ' . sigil .'\zs\d\+')
                                  let len = +matchstr(getline('.'),' ' . sigil . '\d\+,\zs\d\+')
                                  if lnum >= top && lnum <= top + len
                                    let offset = lnum - top
                                    if &scrolloff
                                      +
                                      normal! zt
                                    else
                                      normal! zt
                                      +
                                    endif
                                    while offset > 0 && line('.') < line('$')
                                      +
                                      if getline('.') =~# '^[ ' . sigil . ']'
                                        let offset -= 1
                                      endif
                                    endwhile
                                    return 'normal! zv'
                                  endif
                                endwhile
                                execute head
                                normal! zt
                              endif
                              return ''
                            endfunction
                            
    1              0.000004 function! s:BlameJump(suffix, ...) abort
                              let suffix = a:suffix
                              let [commit, path, lnum] = s:BlameCommitFileLnum()
                              if empty(path)
                                return 'echoerr ' . string('fugitive: could not determine filename for blame')
                              endif
                              if commit =~# '^0*$'
                                let commit = 'HEAD'
                                let suffix = ''
                              endif
                              let offset = line('.') - line('w0')
                              let state = s:TempState()
                              let flags = get(state, 'blame_flags', [])
                              if a:0 && a:1
                                if s:HasOpt(flags, '--reverse')
                                  call remove(flags, '--reverse')
                                else
                                  call add(flags, '--reverse')
                                endif
                              endif
                              let blame_bufnr = s:BlameBufnr()
                              if blame_bufnr > 0
                                let bufnr = bufnr('')
                                let winnr = bufwinnr(blame_bufnr)
                                if winnr > 0
                                  exe winnr.'wincmd w'
                                  exe bufnr.'bdelete'
                                endif
                                execute 'Gedit' s:fnameescape(commit . suffix . ':' . path)
                                execute lnum
                              endif
                              let my_bufnr = bufnr('')
                              if blame_bufnr < 0
                                let blame_args = flags + [commit . suffix, '--', path]
                                let result = s:BlameSubcommand(0, 0, 0, 0, '', extend({'args': blame_args}, state.options, 'keep'))
                              else
                                let blame_args = flags
                                let result = s:BlameSubcommand(-1, -1, 0, 0, '', extend({'args': blame_args}, state.options, 'keep'))
                              endif
                              if bufnr('') == my_bufnr
                                return result
                              endif
                              execute result
                              execute lnum
                              let delta = line('.') - line('w0') - offset
                              if delta > 0
                                execute 'normal! '.delta."\<C-E>"
                              elseif delta < 0
                                execute 'normal! '.(-delta)."\<C-Y>"
                              endif
                              keepjumps syncbind
                              redraw
                              echo ':Git blame' s:fnameescape(blame_args)
                              return ''
                            endfunction
                            
    1              0.000008 let s:hash_colors = {}
                            
    1              0.000004 function! fugitive#BlameSyntax() abort
                              let conceal = has('conceal') ? ' conceal' : ''
                              let flags = get(s:TempState(), 'blame_flags', [])
                              syn spell notoplevel
                              syn match FugitiveblameBlank                      "^\s\+\s\@=" nextgroup=FugitiveblameAnnotation,FugitiveblameScoreDebug,FugitiveblameOriginalFile,FugitiveblameOriginalLineNumber skipwhite
                              syn match FugitiveblameHash       "\%(^\^\=[?*]*\)\@<=\<\x\{7,\}\>" nextgroup=FugitiveblameAnnotation,FugitiveblameScoreDebug,FugitiveblameOriginalLineNumber,FugitiveblameOriginalFile skipwhite
                              syn match FugitiveblameUncommitted "\%(^\^\=\)\@<=\<0\{7,\}\>" nextgroup=FugitiveblameAnnotation,FugitiveblameScoreDebug,FugitiveblameOriginalLineNumber,FugitiveblameOriginalFile skipwhite
                              if s:HasOpt(flags, '-b') || FugitiveConfigGet('blame.blankBoundary') =~# '^1$\|^true$'
                                syn match FugitiveblameBoundaryIgnore "^\^[*?]*\x\{7,\}\>" nextgroup=FugitiveblameAnnotation,FugitiveblameScoreDebug,FugitiveblameOriginalLineNumber,FugitiveblameOriginalFile skipwhite
                              else
                                syn match FugitiveblameBoundary "^\^"
                              endif
                              syn match FugitiveblameScoreDebug        " *\d\+\s\+\d\+\s\@=" nextgroup=FugitiveblameAnnotation,FugitiveblameOriginalLineNumber,fugitiveblameOriginalFile contained skipwhite
                              syn region FugitiveblameAnnotation matchgroup=FugitiveblameDelimiter start="(" end="\%(\s\d\+\)\@<=)" contained keepend oneline
                              syn match FugitiveblameTime "\<[0-9:/+-][0-9:/+ -]*[0-9:/+-]\%(\s\+\d\+)\)\@=" contained containedin=FugitiveblameAnnotation
                              exec 'syn match FugitiveblameLineNumber         "\s*\d\+)\@=" contained containedin=FugitiveblameAnnotation' conceal
                              exec 'syn match FugitiveblameOriginalFile       "\s\%(\f\+\D\@<=\|\D\@=\f\+\)\%(\%(\s\+\d\+\)\=\s\%((\|\s*\d\+)\)\)\@=" contained nextgroup=FugitiveblameOriginalLineNumber,FugitiveblameAnnotation skipwhite' (s:HasOpt(flags, '--show-name', '-f') ? '' : conceal)
                              exec 'syn match FugitiveblameOriginalLineNumber "\s*\d\+\%(\s(\)\@=" contained nextgroup=FugitiveblameAnnotation skipwhite' (s:HasOpt(flags, '--show-number', '-n') ? '' : conceal)
                              exec 'syn match FugitiveblameOriginalLineNumber "\s*\d\+\%(\s\+\d\+)\)\@=" contained nextgroup=FugitiveblameShort skipwhite' (s:HasOpt(flags, '--show-number', '-n') ? '' : conceal)
                              syn match FugitiveblameShort              " \d\+)" contained contains=FugitiveblameLineNumber
                              syn match FugitiveblameNotCommittedYet "(\@<=Not Committed Yet\>" contained containedin=FugitiveblameAnnotation
                              hi def link FugitiveblameBoundary           Keyword
                              hi def link FugitiveblameHash               Identifier
                              hi def link FugitiveblameBoundaryIgnore     Ignore
                              hi def link FugitiveblameUncommitted        Ignore
                              hi def link FugitiveblameScoreDebug         Debug
                              hi def link FugitiveblameTime               PreProc
                              hi def link FugitiveblameLineNumber         Number
                              hi def link FugitiveblameOriginalFile       String
                              hi def link FugitiveblameOriginalLineNumber Float
                              hi def link FugitiveblameShort              FugitiveblameDelimiter
                              hi def link FugitiveblameDelimiter          Delimiter
                              hi def link FugitiveblameNotCommittedYet    Comment
                              if !get(g:, 'fugitive_dynamic_colors', 1) && !s:HasOpt(flags, '--color-lines') || s:HasOpt(flags, '--no-color-lines')
                                return
                              endif
                              let seen = {}
                              for lnum in range(1, line('$'))
                                let hash = matchstr(getline(lnum), '^\^\=\zs\x\{6\}')
                                if hash ==# '' || hash ==# '000000' || has_key(seen, hash)
                                  continue
                                endif
                                let seen[hash] = 1
                                if &t_Co > 16 && get(g:, 'CSApprox_loaded') && !empty(findfile('autoload/csapprox/per_component.vim', escape(&rtp, ' ')))
                                      \ && empty(get(s:hash_colors, hash))
                                  let [s, r, g, b; __] = map(matchlist(hash, '\(\x\x\)\(\x\x\)\(\x\x\)'), 'str2nr(v:val,16)')
                                  let color = csapprox#per_component#Approximate(r, g, b)
                                  if color == 16 && &background ==# 'dark'
                                    let color = 8
                                  endif
                                  let s:hash_colors[hash] = ' ctermfg='.color
                                else
                                  let s:hash_colors[hash] = ''
                                endif
                                exe 'syn match FugitiveblameHash'.hash.'       "\%(^\^\=\)\@<='.hash.'\x\{1,34\}\>" nextgroup=FugitiveblameAnnotation,FugitiveblameOriginalLineNumber,fugitiveblameOriginalFile skipwhite'
                              endfor
                              call s:BlameRehighlight()
                            endfunction
                            
    1              0.000004 function! s:BlameRehighlight() abort
                              for [hash, cterm] in items(s:hash_colors)
                                if !empty(cterm) || has('gui_running') || has('termguicolors') && &termguicolors
                                  exe 'hi FugitiveblameHash'.hash.' guifg=#'.hash.get(s:hash_colors, hash, '')
                                else
                                  exe 'hi link FugitiveblameHash'.hash.' Identifier'
                                endif
                              endfor
                            endfunction
                            
    1              0.000003 function! s:BlameFileType() abort
                              setlocal nomodeline
                              setlocal foldmethod=manual
                              if len(s:Dir())
                                let &l:keywordprg = s:Keywordprg()
                              endif
                              let b:undo_ftplugin = 'setl keywordprg= foldmethod<'
                              if exists('+concealcursor')
                                setlocal concealcursor=nc conceallevel=2
                                let b:undo_ftplugin .= ' concealcursor< conceallevel<'
                              endif
                              if &modifiable
                                return ''
                              endif
                              call s:Map('n', '<F1>', ':help :Git_blame<CR>', '<silent>')
                              call s:Map('n', 'g?',   ':help :Git_blame<CR>', '<silent>')
                              if mapcheck('q', 'n') =~# '^$\|bdelete'
                                call s:Map('n', 'q',  ':exe <SID>BlameQuit()<Bar>echohl WarningMsg<Bar>echo ":Git blame q is deprecated in favor of gq"<Bar>echohl NONE<CR>', '<silent>')
                              endif
                              call s:Map('n', 'gq',   ':exe <SID>BlameQuit()<CR>', '<silent>')
                              call s:Map('n', '<2-LeftMouse>', ':<C-U>exe <SID>BlameCommit("exe <SID>BlameLeave()<Bar>edit")<CR>', '<silent>')
                              call s:Map('n', '<CR>', ':<C-U>exe <SID>BlameCommit("exe <SID>BlameLeave()<Bar>edit")<CR>', '<silent>')
                              call s:Map('n', '-',    ':<C-U>exe <SID>BlameJump("")<CR>', '<silent>')
                              call s:Map('n', 'P',    ':<C-U>exe <SID>BlameJump("^".v:count1)<CR>', '<silent>')
                              call s:Map('n', '~',    ':<C-U>exe <SID>BlameJump("~".v:count1)<CR>', '<silent>')
                              call s:Map('n', 'i',    ':<C-U>exe <SID>BlameCommit("exe <SID>BlameLeave()<Bar>edit")<CR>', '<silent>')
                              call s:Map('n', 'o',    ':<C-U>exe <SID>BlameCommit("split")<CR>', '<silent>')
                              call s:Map('n', 'O',    ':<C-U>exe <SID>BlameCommit("tabedit")<CR>', '<silent>')
                              call s:Map('n', 'p',    ':<C-U>exe <SID>BlameCommit("pedit")<CR>', '<silent>')
                            endfunction
                            
    1              0.000005 augroup fugitive_blame
    1              0.000087   autocmd!
    1              0.000017   autocmd FileType fugitiveblame call s:BlameFileType()
    1              0.000021   autocmd ColorScheme,GUIEnter * call s:BlameRehighlight()
    1              0.000007   autocmd BufWinLeave * execute getwinvar(+bufwinnr(+expand('<abuf>')), 'fugitive_leave')
    1              0.000002 augroup END
                            
                            " Section: :Gbrowse
                            
    1              0.000006 let s:redirects = {}
                            
    1              0.000008 function! fugitive#BrowseCommand(line1, count, range, bang, mods, arg, args) abort
                              let dir = s:Dir()
                              exe s:DirCheck(dir)
                              try
                                let validremote = '\.\|\.\=/.*\|[[:alnum:]_-]\+\%(://.\{-\}\)\='
                                if a:args ==# ['-']
                                  if a:count >= 0
                                    return 'echoerr ' . string('fugitive: ''-'' no longer required to get persistent URL if range given')
                                  else
                                    return 'echoerr ' . string('fugitive: use :0Gbrowse instead of :Gbrowse -')
                                  endif
                                elseif len(a:args)
                                  let remote = matchstr(join(a:args, ' '),'@\zs\%('.validremote.'\)$')
                                  let rev = substitute(join(a:args, ' '),'@\%('.validremote.'\)$','','')
                                else
                                  let remote = ''
                                  let rev = ''
                                endif
                                if rev ==# ''
                                  let rev = s:DirRev(@%)[1]
                                endif
                                if rev =~# '^:\=$'
                                  let expanded = s:Relative()
                                else
                                  let expanded = s:Expand(rev)
                                endif
                                let cdir = FugitiveVimPath(fugitive#CommonDir(dir))
                                for subdir in ['tags/', 'heads/', 'remotes/']
                                  if expanded !~# '^[./]' && filereadable(cdir . '/refs/' . subdir . expanded)
                                    let expanded = '.git/refs/' . subdir . expanded
                                  endif
                                endfor
                                let full = fugitive#Find(expanded, dir)
                                let commit = ''
                                if full =~? '^fugitive:'
                                  let [pathdir, commit, path] = s:DirCommitFile(full)
                                  if commit =~# '^:\=\d$'
                                    let commit = ''
                                  endif
                                  if commit =~ '..'
                                    let type = s:TreeChomp('cat-file','-t',commit.s:sub(path,'^/',':'))
                                    let branch = matchstr(expanded, '^[^:]*')
                                  else
                                    let type = 'blob'
                                  endif
                                  let path = path[1:-1]
                                elseif full =~? '^\a\a\+:[\/][\/]'
                                  let path = s:Slash(full)
                                  let type = 'url'
                                elseif empty(s:Tree(dir))
                                  let path = '.git/' . full[strlen(dir)+1:-1]
                                  let type = ''
                                else
                                  let path = fugitive#Path(full, '/')[1:-1]
                                  if path =~# '^\.git/'
                                    let type = ''
                                  elseif isdirectory(full) || empty(path)
                                    let type = 'tree'
                                  else
                                    let type = 'blob'
                                  endif
                                endif
                                if type ==# 'tree' && !empty(path)
                                  let path = s:sub(path, '/\=$', '/')
                                endif
                                if path =~# '^\.git/.*HEAD$' && filereadable(dir . '/' . path[5:-1])
                                  let body = readfile(dir . '/' . path[5:-1])[0]
                                  if body =~# '^\x\{40,\}$'
                                    let commit = body
                                    let type = 'commit'
                                    let path = ''
                                  elseif body =~# '^ref: refs/'
                                    let path = '.git/' . matchstr(body,'ref: \zs.*')
                                  endif
                                endif
                            
                                let merge = ''
                                if path =~# '^\.git/refs/remotes/.'
                                  if empty(remote)
                                    let remote = matchstr(path, '^\.git/refs/remotes/\zs[^/]\+')
                                    let branch = matchstr(path, '^\.git/refs/remotes/[^/]\+/\zs.\+')
                                  else
                                    let merge = matchstr(path, '^\.git/refs/remotes/[^/]\+/\zs.\+')
                                    let path = '.git/refs/heads/'.merge
                                  endif
                                elseif path =~# '^\.git/refs/heads/.'
                                  let branch = path[16:-1]
                                elseif !exists('branch')
                                  let branch = FugitiveHead()
                                endif
                                if !empty(branch)
                                  let r = fugitive#Config('branch.'.branch.'.remote')
                                  let m = fugitive#Config('branch.'.branch.'.merge')[11:-1]
                                  if r ==# '.' && !empty(m)
                                    let r2 = fugitive#Config('branch.'.m.'.remote')
                                    if r2 !~# '^\.\=$'
                                      let r = r2
                                      let m = fugitive#Config('branch.'.m.'.merge')[11:-1]
                                    endif
                                  endif
                                  if empty(remote)
                                    let remote = r
                                  endif
                                  if r ==# '.' || r ==# remote
                                    let merge = m
                                    if path =~# '^\.git/refs/heads/.'
                                      let path = '.git/refs/heads/'.merge
                                    endif
                                  endif
                                endif
                            
                                let line1 = a:count > 0 ? a:line1 : 0
                                let line2 = a:count > 0 ? a:count : 0
                                if empty(commit) && path !~# '^\.git/'
                                  if a:count < 0 && !empty(merge)
                                    let commit = merge
                                  else
                                    let commit = ''
                                    if len(merge)
                                      let owner = s:Owner(@%)
                                      let [commit, exec_error] = s:ChompError(['merge-base', 'refs/remotes/' . remote . '/' . merge, empty(owner) ? 'HEAD' : owner, '--'])
                                      if exec_error
                                        let commit = ''
                                      endif
                                      if a:count > 0 && empty(a:args) && commit =~# '^\x\{40,\}$'
                                        let blame_list = tempname()
                                        call writefile([commit, ''], blame_list, 'b')
                                        let blame_in = tempname()
                                        silent exe '%write' blame_in
                                        let [blame, exec_error] = s:LinesError(['-c', 'blame.coloring=none', 'blame', '--contents', blame_in, '-L', a:line1.','.a:count, '-S', blame_list, '-s', '--show-number', './' . path])
                                        if !exec_error
                                          let blame_regex = '^\^\x\+\s\+\zs\d\+\ze\s'
                                          if get(blame, 0) =~# blame_regex && get(blame, -1) =~# blame_regex
                                            let line1 = +matchstr(blame[0], blame_regex)
                                            let line2 = +matchstr(blame[-1], blame_regex)
                                          else
                                            call s:throw("Can't browse to uncommitted change")
                                          endif
                                        endif
                                      endif
                                    endif
                                  endif
                                  if empty(commit)
                                    let commit = readfile(fugitive#Find('.git/HEAD', dir), '', 1)[0]
                                  endif
                                  let i = 0
                                  while commit =~# '^ref: ' && i < 10
                                    let ref_file = cdir . '/' . commit[5:-1]
                                    if getfsize(ref_file) > 0
                                      let commit = readfile(ref_file, '', 1)[0]
                                    else
                                      let commit = fugitive#RevParse(commit[5:-1], dir)
                                    endif
                                    let i -= 1
                                  endwhile
                                endif
                            
                                if empty(remote)
                                  let remote = '.'
                                endif
                                let raw = fugitive#RemoteUrl(remote)
                                if empty(raw)
                                  let raw = remote
                                endif
                            
                                if raw =~# '^https\=://' && s:executable('curl')
                                  if !has_key(s:redirects, raw)
                                    let s:redirects[raw] = matchstr(system('curl -I ' .
                                          \ s:shellesc(raw . '/info/refs?service=git-upload-pack')),
                                          \ 'Location: \zs\S\+\ze/info/refs?')
                                  endif
                                  if len(s:redirects[raw])
                                    let raw = s:redirects[raw]
                                  endif
                                endif
                            
                                let opts = {
                                      \ 'dir': dir,
                                      \ 'repo': fugitive#repo(dir),
                                      \ 'remote': raw,
                                      \ 'revision': 'No longer provided',
                                      \ 'commit': commit,
                                      \ 'path': path,
                                      \ 'type': type,
                                      \ 'line1': line1,
                                      \ 'line2': line2}
                            
                                if type ==# 'url'
                                  let url = path
                                else
                                  let url = ''
                                  for Handler in get(g:, 'fugitive_browse_handlers', [])
                                    let url = call(Handler, [copy(opts)])
                                    if !empty(url)
                                      break
                                    endif
                                  endfor
                                endif
                            
                                if empty(url)
                                  call s:throw("No Gbrowse handler installed for '".raw."'")
                                endif
                            
                                let url = s:gsub(url, '[ <>]', '\="%".printf("%02X",char2nr(submatch(0)))')
                                if a:bang
                                  if has('clipboard')
                                    let @+ = url
                                  endif
                                  return 'echomsg '.string(url)
                                elseif exists(':Browse') == 2
                                  return 'echomsg '.string(url).'|Browse '.url
                                else
                                  if !exists('g:loaded_netrw')
                                    runtime! autoload/netrw.vim
                                  endif
                                  if exists('*netrw#BrowseX')
                                    return 'echomsg '.string(url).'|call netrw#BrowseX('.string(url).', 0)'
                                  else
                                    return 'echomsg '.string(url).'|call netrw#NetrwBrowseX('.string(url).', 0)'
                                  endif
                                endif
                              catch /^fugitive:/
                                return 'echoerr ' . string(v:exception)
                              endtry
                            endfunction
                            
                            " Section: Go to file
                            
    1              0.000017 let s:ref_header = '\%(Merge\|Rebase\|Upstream\|Pull\|Push\)'
                            
    1              0.000088 nnoremap <SID>: :<C-U><C-R>=v:count ? v:count : ''<CR>
    1              0.000008 function! fugitive#MapCfile(...) abort
                              exe 'cnoremap <buffer> <expr> <Plug><cfile>' (a:0 ? a:1 : 'fugitive#Cfile()')
                              let b:undo_ftplugin = get(b:, 'undo_ftplugin', 'exe') . '|sil! exe "cunmap <buffer> <Plug><cfile>"'
                              if !exists('g:fugitive_no_maps')
                                call s:Map('n', 'gf',          '<SID>:find <Plug><cfile><CR>', '<silent><unique>', 1)
                                call s:Map('n', '<C-W>f',     '<SID>:sfind <Plug><cfile><CR>', '<silent><unique>', 1)
                                call s:Map('n', '<C-W><C-F>', '<SID>:sfind <Plug><cfile><CR>', '<silent><unique>', 1)
                                call s:Map('n', '<C-W>gf',  '<SID>:tabfind <Plug><cfile><CR>', '<silent><unique>', 1)
                                call s:Map('c', '<C-R><C-F>', '<Plug><cfile>', '<silent><unique>', 1)
                              endif
                            endfunction
                            
    1              0.000006 function! s:ContainingCommit() abort
                              let commit = s:Owner(@%)
                              return empty(commit) ? 'HEAD' : commit
                            endfunction
                            
    1              0.000004 function! s:SquashArgument(...) abort
                              if &filetype == 'fugitive'
                                let commit = matchstr(getline('.'), '^\%(\%(\x\x\x\)\@!\l\+\s\+\)\=\zs[0-9a-f]\{4,\}\ze \|^' . s:ref_header . ': \zs\S\+')
                              elseif has_key(s:temp_files, s:cpath(expand('%:p')))
                                let commit = matchstr(getline('.'), '\<\x\{4,\}\>')
                              else
                                let commit = s:Owner(@%)
                              endif
                              return len(commit) && a:0 ? printf(a:1, commit) : commit
                            endfunction
                            
    1              0.000003 function! s:RebaseArgument() abort
                              return s:SquashArgument(' %s^')
                            endfunction
                            
    1              0.000004 function! s:NavigateUp(count) abort
                              let rev = substitute(s:DirRev(@%)[1], '^$', ':', 'g')
                              let c = a:count
                              while c
                                if rev =~# ':.*/.'
                                  let rev = matchstr(rev, '.*\ze/.\+', '')
                                elseif rev =~# '.:.'
                                  let rev = matchstr(rev, '^.[^:]*:')
                                elseif rev =~# '^:'
                                  let rev = 'HEAD^{}'
                                elseif rev =~# ':$'
                                  let rev = rev[0:-2]
                                else
                                  return rev.'~'.c
                                endif
                                let c -= 1
                              endwhile
                              return rev
                            endfunction
                            
    1              0.000004 function! s:MapMotion(lhs, rhs) abort
                              call s:Map('n', a:lhs, ":<C-U>" . a:rhs . "<CR>", "<silent>")
                              call s:Map('o', a:lhs, ":<C-U>" . a:rhs . "<CR>", "<silent>")
                              call s:Map('x', a:lhs, ":<C-U>exe 'normal! gv'<Bar>" . a:rhs . "<CR>", "<silent>")
                            endfunction
                            
    1              0.000003 function! fugitive#MapJumps(...) abort
                              if !&modifiable
                                if get(b:, 'fugitive_type', '') ==# 'blob'
                                  let blame_map = 'Git blame<C-R>=v:count ? " --reverse" : ""<CR><CR>'
                                  call s:Map('n', '<2-LeftMouse>', ':<C-U>0,1' . blame_map, '<silent>')
                                  call s:Map('n', '<CR>', ':<C-U>0,1' . blame_map, '<silent>')
                                  call s:Map('n', 'o',    ':<C-U>0,2' . blame_map, '<silent>')
                                  call s:Map('n', 'p',    ':<C-U>0,3' . blame_map, '<silent>')
                                  call s:Map('n', 'gO',   ':<C-U>0,4' . blame_map, '<silent>')
                                  call s:Map('n', 'O',    ':<C-U>0,5' . blame_map, '<silent>')
                            
                                  call s:Map('n', 'D',  ":<C-U>call fugitive#DiffClose()<Bar>Gdiffsplit!<Bar>redraw<Bar>echohl WarningMsg<Bar> echo ':Gstatus D is deprecated in favor of dd'<Bar>echohl NONE<CR>", '<silent>')
                                  call s:Map('n', 'dd', ":<C-U>call fugitive#DiffClose()<Bar>Gdiffsplit!<CR>", '<silent>')
                                  call s:Map('n', 'dh', ":<C-U>call fugitive#DiffClose()<Bar>Ghdiffsplit!<CR>", '<silent>')
                                  call s:Map('n', 'ds', ":<C-U>call fugitive#DiffClose()<Bar>Ghdiffsplit!<CR>", '<silent>')
                                  call s:Map('n', 'dv', ":<C-U>call fugitive#DiffClose()<Bar>Gvdiffsplit!<CR>", '<silent>')
                                  call s:Map('n', 'd?', ":<C-U>help fugitive_d<CR>", '<silent>')
                            
                                else
                                  call s:Map('n', '<2-LeftMouse>', ':<C-U>exe <SID>GF("edit")<CR>', '<silent>')
                                  call s:Map('n', '<CR>', ':<C-U>exe <SID>GF("edit")<CR>', '<silent>')
                                  call s:Map('n', 'o',    ':<C-U>exe <SID>GF("split")<CR>', '<silent>')
                                  call s:Map('n', 'gO',   ':<C-U>exe <SID>GF("vsplit")<CR>', '<silent>')
                                  call s:Map('n', 'O',    ':<C-U>exe <SID>GF("tabedit")<CR>', '<silent>')
                                  call s:Map('n', 'p',    ':<C-U>exe <SID>GF("pedit")<CR>', '<silent>')
                            
                                  if !exists('g:fugitive_no_maps')
                                    if exists(':CtrlP') && get(g:, 'ctrl_p_map') =~? '^<c-p>$'
                                      nnoremap <buffer> <silent> <C-P> :<C-U>execute line('.') == 1 ? 'CtrlP ' . fnameescape(<SID>Tree()) : <SID>PreviousItem(v:count1)<CR>
                                    else
                                      nnoremap <buffer> <silent> <C-P> :<C-U>execute <SID>PreviousItem(v:count1)<CR>
                                    endif
                                    nnoremap <buffer> <silent> <C-N> :<C-U>execute <SID>NextItem(v:count1)<CR>
                                  endif
                                  call s:MapMotion('(', 'exe <SID>PreviousItem(v:count1)')
                                  call s:MapMotion(')', 'exe <SID>NextItem(v:count1)')
                                  call s:MapMotion('K', 'exe <SID>PreviousHunk(v:count1)')
                                  call s:MapMotion('J', 'exe <SID>NextHunk(v:count1)')
                                  call s:MapMotion('[c', 'exe <SID>PreviousHunk(v:count1)')
                                  call s:MapMotion(']c', 'exe <SID>NextHunk(v:count1)')
                                  call s:MapMotion('[/', 'exe <SID>PreviousFile(v:count1)')
                                  call s:MapMotion(']/', 'exe <SID>NextFile(v:count1)')
                                  call s:MapMotion('[m', 'exe <SID>PreviousFile(v:count1)')
                                  call s:MapMotion(']m', 'exe <SID>NextFile(v:count1)')
                                  call s:MapMotion('[[', 'exe <SID>PreviousSection(v:count1)')
                                  call s:MapMotion(']]', 'exe <SID>NextSection(v:count1)')
                                  call s:MapMotion('[]', 'exe <SID>PreviousSectionEnd(v:count1)')
                                  call s:MapMotion('][', 'exe <SID>NextSectionEnd(v:count1)')
                                  call s:Map('nxo', '*', '<SID>PatchSearchExpr(0)', '<expr>')
                                  call s:Map('nxo', '#', '<SID>PatchSearchExpr(1)', '<expr>')
                                endif
                                call s:Map('n', 'S',    ':<C-U>echoerr "Use gO"<CR>', '<silent>')
                                call s:Map('n', 'dq', ":<C-U>call fugitive#DiffClose()<CR>", '<silent>')
                                call s:Map('n', '-', ":<C-U>exe 'Gedit ' . <SID>fnameescape(<SID>NavigateUp(v:count1))<Bar> if getline(1) =~# '^tree \x\{40,\}$' && empty(getline(2))<Bar>call search('^'.escape(expand('#:t'),'.*[]~\').'/\=$','wc')<Bar>endif<CR>", '<silent>')
                                call s:Map('n', 'P',     ":<C-U>exe 'Gedit ' . <SID>fnameescape(<SID>ContainingCommit().'^'.v:count1.<SID>Relative(':'))<CR>", '<silent>')
                                call s:Map('n', '~',     ":<C-U>exe 'Gedit ' . <SID>fnameescape(<SID>ContainingCommit().'~'.v:count1.<SID>Relative(':'))<CR>", '<silent>')
                                call s:Map('n', 'C',     ":<C-U>exe 'Gedit ' . <SID>fnameescape(<SID>ContainingCommit())<CR>", '<silent>')
                                call s:Map('n', 'cp',    ":<C-U>echoerr 'Use gC'<CR>", '<silent>')
                                call s:Map('n', 'gC',    ":<C-U>exe 'Gpedit ' . <SID>fnameescape(<SID>ContainingCommit())<CR>", '<silent>')
                                call s:Map('n', 'gc',    ":<C-U>exe 'Gpedit ' . <SID>fnameescape(<SID>ContainingCommit())<CR>", '<silent>')
                                call s:Map('n', 'gi',    ":<C-U>exe 'Gsplit' (v:count ? '.gitignore' : '.git/info/exclude')<CR>", '<silent>')
                                call s:Map('x', 'gi',    ":<C-U>exe 'Gsplit' (v:count ? '.gitignore' : '.git/info/exclude')<CR>", '<silent>')
                            
                                call s:Map('n', 'c<Space>', ':Git commit<Space>')
                                call s:Map('n', 'c<CR>', ':Git commit<CR>')
                                call s:Map('n', 'cv<Space>', ':tab Git commit -v<Space>')
                                call s:Map('n', 'cv<CR>', ':tab Git commit -v<CR>')
                                call s:Map('n', 'ca', ':<C-U>Git commit --amend<CR>', '<silent>')
                                call s:Map('n', 'cc', ':<C-U>Git commit<CR>', '<silent>')
                                call s:Map('n', 'ce', ':<C-U>Git commit --amend --no-edit<CR>', '<silent>')
                                call s:Map('n', 'cw', ':<C-U>Git commit --amend --only<CR>', '<silent>')
                                call s:Map('n', 'cva', ':<C-U>tab Git commit -v --amend<CR>', '<silent>')
                                call s:Map('n', 'cvc', ':<C-U>tab Git commit -v<CR>', '<silent>')
                                call s:Map('n', 'cRa', ':<C-U>Git commit --reset-author --amend<CR>', '<silent>')
                                call s:Map('n', 'cRe', ':<C-U>Git commit --reset-author --amend --no-edit<CR>', '<silent>')
                                call s:Map('n', 'cRw', ':<C-U>Git commit --reset-author --amend --only<CR>', '<silent>')
                                call s:Map('n', 'cf', ':<C-U>Git commit --fixup=<C-R>=<SID>SquashArgument()<CR>')
                                call s:Map('n', 'cF', ':<C-U><Bar>Git -c sequence.editor=true rebase --interactive --autosquash<C-R>=<SID>RebaseArgument()<CR><Home>Git commit --fixup=<C-R>=<SID>SquashArgument()<CR>')
                                call s:Map('n', 'cs', ':<C-U>Git commit --no-edit --squash=<C-R>=<SID>SquashArgument()<CR>')
                                call s:Map('n', 'cS', ':<C-U><Bar>Git -c sequence.editor=true rebase --interactive --autosquash<C-R>=<SID>RebaseArgument()<CR><Home>Git commit --no-edit --squash=<C-R>=<SID>SquashArgument()<CR>')
                                call s:Map('n', 'cA', ':<C-U>Git commit --edit --squash=<C-R>=<SID>SquashArgument()<CR>')
                                call s:Map('n', 'c?', ':<C-U>help fugitive_c<CR>', '<silent>')
                            
                                call s:Map('n', 'cr<Space>', ':Git revert<Space>')
                                call s:Map('n', 'cr<CR>', ':Git revert<CR>')
                                call s:Map('n', 'crc', ':<C-U>Git revert <C-R>=<SID>SquashArgument()<CR><CR>', '<silent>')
                                call s:Map('n', 'crn', ':<C-U>Git revert --no-commit <C-R>=<SID>SquashArgument()<CR><CR>', '<silent>')
                                call s:Map('n', 'cr?', ':<C-U>help fugitive_cr<CR>', '<silent>')
                            
                                call s:Map('n', 'cm<Space>', ':Git merge<Space>')
                                call s:Map('n', 'cm<CR>', ':Git merge<CR>')
                                call s:Map('n', 'cmt', ':Git mergetool')
                                call s:Map('n', 'cm?', ':<C-U>help fugitive_cm<CR>', '<silent>')
                            
                                call s:Map('n', 'cz<Space>', ':Git stash<Space>')
                                call s:Map('n', 'cz<CR>', ':Git stash<CR>')
                                call s:Map('n', 'cza', ':<C-U>Git stash apply --quiet --index stash@{<C-R>=v:count<CR>}<CR>')
                                call s:Map('n', 'czA', ':<C-U>Git stash apply --quiet stash@{<C-R>=v:count<CR>}<CR>')
                                call s:Map('n', 'czp', ':<C-U>Git stash pop --quiet --index stash@{<C-R>=v:count<CR>}<CR>')
                                call s:Map('n', 'czP', ':<C-U>Git stash pop --quiet stash@{<C-R>=v:count<CR>}<CR>')
                                call s:Map('n', 'czv', ':<C-U>exe "Gedit" fugitive#RevParse("stash@{" . v:count . "}")<CR>', '<silent>')
                                call s:Map('n', 'czw', ':<C-U>Git stash --keep-index<C-R>=v:count > 1 ? " --all" : v:count ? " --include-untracked" : ""<CR><CR>')
                                call s:Map('n', 'czz', ':<C-U>Git stash <C-R>=v:count > 1 ? " --all" : v:count ? " --include-untracked" : ""<CR><CR>')
                                call s:Map('n', 'cz?', ':<C-U>help fugitive_cz<CR>', '<silent>')
                            
                                call s:Map('n', 'co<Space>', ':Git checkout<Space>')
                                call s:Map('n', 'co<CR>', ':Git checkout<CR>')
                                call s:Map('n', 'coo', ':<C-U>Git checkout <C-R>=<SID>SquashArgument()<CR> --<CR>')
                                call s:Map('n', 'co?', ':<C-U>help fugitive_co<CR>', '<silent>')
                            
                                call s:Map('n', 'cb<Space>', ':Git branch<Space>')
                                call s:Map('n', 'cb<CR>', ':Git branch<CR>')
                                call s:Map('n', 'cb?', ':<C-U>help fugitive_cb<CR>', '<silent>')
                            
                                call s:Map('n', 'r<Space>', ':Git rebase<Space>')
                                call s:Map('n', 'r<CR>', ':Git rebase<CR>')
                                call s:Map('n', 'ri', ':<C-U>Git rebase --interactive<C-R>=<SID>RebaseArgument()<CR><CR>', '<silent>')
                                call s:Map('n', 'rf', ':<C-U>Git -c sequence.editor=true rebase --interactive --autosquash<C-R>=<SID>RebaseArgument()<CR><CR>', '<silent>')
                                call s:Map('n', 'ru', ':<C-U>Git rebase --interactive @{upstream}<CR>', '<silent>')
                                call s:Map('n', 'rp', ':<C-U>Git rebase --interactive @{push}<CR>', '<silent>')
                                call s:Map('n', 'rw', ':<C-U>Git rebase --interactive<C-R>=<SID>RebaseArgument()<CR><Bar>s/^pick/reword/e<CR>', '<silent>')
                                call s:Map('n', 'rm', ':<C-U>Git rebase --interactive<C-R>=<SID>RebaseArgument()<CR><Bar>s/^pick/edit/e<CR>', '<silent>')
                                call s:Map('n', 'rd', ':<C-U>Git rebase --interactive<C-R>=<SID>RebaseArgument()<CR><Bar>s/^pick/drop/e<CR>', '<silent>')
                                call s:Map('n', 'rk', ':<C-U>Git rebase --interactive<C-R>=<SID>RebaseArgument()<CR><Bar>s/^pick/drop/e<CR>', '<silent>')
                                call s:Map('n', 'rx', ':<C-U>Git rebase --interactive<C-R>=<SID>RebaseArgument()<CR><Bar>s/^pick/drop/e<CR>', '<silent>')
                                call s:Map('n', 'rr', ':<C-U>Git rebase --continue<CR>', '<silent>')
                                call s:Map('n', 'rs', ':<C-U>Git rebase --skip<CR>', '<silent>')
                                call s:Map('n', 're', ':<C-U>Git rebase --edit-todo<CR>', '<silent>')
                                call s:Map('n', 'ra', ':<C-U>Git rebase --abort<CR>', '<silent>')
                                call s:Map('n', 'r?', ':<C-U>help fugitive_r<CR>', '<silent>')
                            
                                call s:Map('n', '.',     ":<C-U> <C-R>=<SID>fnameescape(fugitive#Real(@%))<CR><Home>")
                                call s:Map('x', '.',     ":<C-U> <C-R>=<SID>fnameescape(fugitive#Real(@%))<CR><Home>")
                                call s:Map('n', 'g?',    ":<C-U>help fugitive-map<CR>", '<silent>')
                                call s:Map('n', '<F1>',  ":<C-U>help fugitive-map<CR>", '<silent>')
                              endif
                            endfunction
                            
    1              0.000004 function! s:StatusCfile(...) abort
                              let tree = s:Tree()
                              let lead = s:cpath(tree, getcwd()) ? './' : tree . '/'
                              let info = s:StageInfo()
                              let line = getline('.')
                              if len(info.sigil) && len(info.section) && len(info.paths)
                                if info.section ==# 'Unstaged' && info.sigil !=# '-'
                                  return [lead . info.relative[0], info.offset, 'normal!zv']
                                elseif info.section ==# 'Staged' && info.sigil ==# '-'
                                  return ['@:' . info.relative[0], info.offset, 'normal!zv']
                                else
                                  return [':0:' . info.relative[0], info.offset, 'normal!zv']
                                endif
                              elseif len(info.paths)
                                return [lead . info.relative[0]]
                              elseif len(info.commit)
                                return [info.commit]
                              elseif line =~# '^' . s:ref_header . ': \|^Head: '
                                return [matchstr(line, ' \zs.*')]
                              else
                                return ['']
                              endif
                            endfunction
                            
    1              0.000003 function! fugitive#StatusCfile() abort
                              let file = s:Generate(s:StatusCfile()[0])
                              return empty(file) ? fugitive#Cfile() : s:fnameescape(file)
                            endfunction
                            
    1              0.000003 function! s:MessageCfile(...) abort
                              let tree = s:Tree()
                              let lead = s:cpath(tree, getcwd()) ? './' : tree . '/'
                              if getline('.') =~# '^.\=\trenamed:.* -> '
                                return lead . matchstr(getline('.'),' -> \zs.*')
                              elseif getline('.') =~# '^.\=\t\(\k\| \)\+\p\?: *.'
                                return lead . matchstr(getline('.'),': *\zs.\{-\}\ze\%( ([^()[:digit:]]\+)\)\=$')
                              elseif getline('.') =~# '^.\=\t.'
                                return lead . matchstr(getline('.'),'\t\zs.*')
                              elseif getline('.') =~# ': needs merge$'
                                return lead . matchstr(getline('.'),'.*\ze: needs merge$')
                              elseif getline('.') =~# '^\%(. \)\=Not currently on any branch.$'
                                return 'HEAD'
                              elseif getline('.') =~# '^\%(. \)\=On branch '
                                return 'refs/heads/'.getline('.')[12:]
                              elseif getline('.') =~# "^\\%(. \\)\=Your branch .*'"
                                return matchstr(getline('.'),"'\\zs\\S\\+\\ze'")
                              else
                                return ''
                              endif
                            endfunction
                            
    1              0.000003 function! fugitive#MessageCfile() abort
                              let file = s:Generate(s:MessageCfile())
                              return empty(file) ? fugitive#Cfile() : s:fnameescape(file)
                            endfunction
                            
    1              0.000003 function! s:cfile() abort
                              try
                                let myhash = s:DirRev(@%)[1]
                                if len(myhash)
                                  try
                                    let myhash = fugitive#RevParse(myhash)
                                  catch /^fugitive:/
                                    let myhash = ''
                                  endtry
                                endif
                                if empty(myhash) && getline(1) =~# '^\%(commit\|tag\) \w'
                                  let myhash = matchstr(getline(1),'^\w\+ \zs\S\+')
                                endif
                            
                                let showtree = (getline(1) =~# '^tree ' && getline(2) == "")
                            
                                let treebase = substitute(s:DirCommitFile(@%)[1], '^\d$', ':&', '') . ':' .
                                      \ s:Relative('') . (s:Relative('') =~# '^$\|/$' ? '' : '/')
                            
                                if getline('.') =~# '^\d\{6\} \l\{3,8\} \x\{40,\}\t'
                                  return [treebase . s:sub(matchstr(getline('.'),'\t\zs.*'),'/$','')]
                                elseif showtree
                                  return [treebase . s:sub(getline('.'),'/$','')]
                            
                                else
                            
                                  let dcmds = []
                            
                                  " Index
                                  if getline('.') =~# '^\d\{6\} \x\{40,\} \d\t'
                                    let ref = matchstr(getline('.'),'\x\{40,\}')
                                    let file = ':'.s:sub(matchstr(getline('.'),'\d\t.*'),'\t',':')
                                    return [file]
                                  endif
                            
                                  if getline('.') =~# '^ref: '
                                    let ref = strpart(getline('.'),5)
                            
                                  elseif getline('.') =~# '^commit \x\{40,\}\>'
                                    let ref = matchstr(getline('.'),'\x\{40,\}')
                                    return [ref]
                            
                                  elseif getline('.') =~# '^parent \x\{40,\}\>'
                                    let ref = matchstr(getline('.'),'\x\{40,\}')
                                    let line = line('.')
                                    let parent = 0
                                    while getline(line) =~# '^parent '
                                      let parent += 1
                                      let line -= 1
                                    endwhile
                                    return [ref]
                            
                                  elseif getline('.') =~# '^tree \x\{40,\}$'
                                    let ref = matchstr(getline('.'),'\x\{40,\}')
                                    if len(myhash) && fugitive#RevParse(myhash.':') ==# ref
                                      let ref = myhash.':'
                                    endif
                                    return [ref]
                            
                                  elseif getline('.') =~# '^object \x\{40,\}$' && getline(line('.')+1) =~ '^type \%(commit\|tree\|blob\)$'
                                    let ref = matchstr(getline('.'),'\x\{40,\}')
                                    let type = matchstr(getline(line('.')+1),'type \zs.*')
                            
                                  elseif getline('.') =~# '^\l\{3,8\} '.myhash.'$'
                                    let ref = s:DirRev(@%)[1]
                            
                                  elseif getline('.') =~# '^\l\{3,8\} \x\{40,\}\>'
                                    let ref = matchstr(getline('.'),'\x\{40,\}')
                                    echoerr "warning: unknown context ".matchstr(getline('.'),'^\l*')
                            
                                  elseif getline('.') =~# '^[+-]\{3\} [abciow12]\=/'
                                    let ref = getline('.')[4:]
                            
                                  elseif getline('.') =~# '^[+-]' && search('^@@ -\d\+\%(,\d\+\)\= +\d\+','bnW')
                                    let type = getline('.')[0]
                                    let lnum = line('.') - 1
                                    let offset = 0
                                    while getline(lnum) !~# '^@@ -\d\+\%(,\d\+\)\= +\d\+'
                                      if getline(lnum) =~# '^[ '.type.']'
                                        let offset += 1
                                      endif
                                      let lnum -= 1
                                    endwhile
                                    let offset += matchstr(getline(lnum), type.'\zs\d\+')
                                    let ref = getline(search('^'.type.'\{3\} [abciow12]/','bnW'))[4:-1]
                                    let dcmds = [offset, 'normal!zv']
                            
                                  elseif getline('.') =~# '^rename from '
                                    let ref = 'a/'.getline('.')[12:]
                                  elseif getline('.') =~# '^rename to '
                                    let ref = 'b/'.getline('.')[10:]
                            
                                  elseif getline('.') =~# '^@@ -\d\+\%(,\d\+\)\= +\d\+'
                                    let diff = getline(search('^diff --git \%([abciow12]/.*\|/dev/null\) \%([abciow12]/.*\|/dev/null\)', 'bcnW'))
                                    let offset = matchstr(getline('.'), '+\zs\d\+')
                            
                                    let dref = matchstr(diff, '\Cdiff --git \zs\%([abciow12]/.*\|/dev/null\)\ze \%([abciow12]/.*\|/dev/null\)')
                                    let ref = matchstr(diff, '\Cdiff --git \%([abciow12]/.*\|/dev/null\) \zs\%([abciow12]/.*\|/dev/null\)')
                                    let dcmd = 'Gdiffsplit! +'.offset
                            
                                  elseif getline('.') =~# '^diff --git \%([abciow12]/.*\|/dev/null\) \%([abciow12]/.*\|/dev/null\)'
                                    let dref = matchstr(getline('.'),'\Cdiff --git \zs\%([abciow12]/.*\|/dev/null\)\ze \%([abciow12]/.*\|/dev/null\)')
                                    let ref = matchstr(getline('.'),'\Cdiff --git \%([abciow12]/.*\|/dev/null\) \zs\%([abciow12]/.*\|/dev/null\)')
                                    let dcmd = 'Gdiffsplit!'
                            
                                  elseif getline('.') =~# '^index ' && getline(line('.')-1) =~# '^diff --git \%([abciow12]/.*\|/dev/null\) \%([abciow12]/.*\|/dev/null\)'
                                    let line = getline(line('.')-1)
                                    let dref = matchstr(line,'\Cdiff --git \zs\%([abciow12]/.*\|/dev/null\)\ze \%([abciow12]/.*\|/dev/null\)')
                                    let ref = matchstr(line,'\Cdiff --git \%([abciow12]/.*\|/dev/null\) \zs\%([abciow12]/.*\|/dev/null\)')
                                    let dcmd = 'Gdiffsplit!'
                            
                                  elseif line('$') == 1 && getline('.') =~ '^\x\{40,\}$'
                                    let ref = getline('.')
                            
                                  elseif expand('<cword>') =~# '^\x\{7,\}\>'
                                    return [expand('<cword>')]
                            
                                  else
                                    let ref = ''
                                  endif
                            
                                  let prefixes = {
                                        \ '1': '',
                                        \ '2': '',
                                        \ 'b': ':0:',
                                        \ 'i': ':0:',
                                        \ 'o': '',
                                        \ 'w': ''}
                            
                                  if len(myhash)
                                    let prefixes.a = myhash.'^:'
                                    let prefixes.b = myhash.':'
                                  endif
                                  let ref = substitute(ref, '^\(\w\)/', '\=get(prefixes, submatch(1), "HEAD:")', '')
                                  if exists('dref')
                                    let dref = substitute(dref, '^\(\w\)/', '\=get(prefixes, submatch(1), "HEAD:")', '')
                                  endif
                            
                                  if ref ==# '/dev/null'
                                    " Empty blob
                                    let ref = 'e69de29bb2d1d6434b8b29ae775ad8c2e48c5391'
                                  endif
                            
                                  if exists('dref')
                                    return [ref, dcmd . ' ' . s:fnameescape(dref)] + dcmds
                                  elseif ref != ""
                                    return [ref] + dcmds
                                  endif
                            
                                endif
                                return []
                              endtry
                            endfunction
                            
    1              0.000004 function! s:GF(mode) abort
                              try
                                let results = &filetype ==# 'fugitive' ? s:StatusCfile() : &filetype ==# 'gitcommit' ? [s:MessageCfile()] : s:cfile()
                              catch /^fugitive:/
                                return 'echoerr ' . string(v:exception)
                              endtry
                              if len(results) > 1
                                return 'G' . a:mode .
                                      \ ' +' . escape(results[1], ' ') . ' ' .
                                      \ s:fnameescape(results[0]) . join(map(results[2:-1], '"|" . v:val'), '')
                              elseif len(results) && len(results[0])
                                return 'G' . a:mode . ' ' . s:fnameescape(results[0])
                              else
                                return ''
                              endif
                            endfunction
                            
    1              0.000003 function! fugitive#Cfile() abort
                              let pre = ''
                              let results = s:cfile()
                              if empty(results)
                                let cfile = expand('<cfile>')
                                if &includeexpr =~# '\<v:fname\>'
                                  sandbox let cfile = eval(substitute(&includeexpr, '\C\<v:fname\>', '\=string(cfile)', 'g'))
                                endif
                                return cfile
                              elseif len(results) > 1
                                let pre = '+' . join(map(results[1:-1], 'escape(v:val, " ")'), '\|') . ' '
                              endif
                              return pre . s:fnameescape(s:Generate(results[0]))
                            endfunction
                            
                            " Section: Statusline
                            
    1              0.000003 function! fugitive#Statusline(...) abort
                              let dir = s:Dir(bufnr(''))
                              if empty(dir)
                                return ''
                              endif
                              let status = ''
                              let commit = s:DirCommitFile(@%)[1]
                              if len(commit)
                                let status .= ':' . commit[0:6]
                              endif
                              let status .= '('.FugitiveHead(7, dir).')'
                              return '[Git'.status.']'
                            endfunction
                            
    1              0.000003 function! fugitive#statusline(...) abort
                              return fugitive#Statusline()
                            endfunction
                            
    1              0.000003 function! fugitive#head(...) abort
                              if empty(s:Dir())
                                return ''
                              endif
                            
                              return fugitive#Head(a:0 ? a:1 : 0)
                            endfunction
                            
                            " Section: Folding
                            
    1              0.000003 function! fugitive#Foldtext() abort
                              if &foldmethod !=# 'syntax'
                                return foldtext()
                              endif
                            
                              let line_foldstart = getline(v:foldstart)
                              if line_foldstart =~# '^diff '
                                let [add, remove] = [-1, -1]
                                let filename = ''
                                for lnum in range(v:foldstart, v:foldend)
                                  let line = getline(lnum)
                                  if filename ==# '' && line =~# '^[+-]\{3\} [abciow12]/'
                                    let filename = line[6:-1]
                                  endif
                                  if line =~# '^+'
                                    let add += 1
                                  elseif line =~# '^-'
                                    let remove += 1
                                  elseif line =~# '^Binary '
                                    let binary = 1
                                  endif
                                endfor
                                if filename ==# ''
                                  let filename = matchstr(line_foldstart, '^diff .\{-\} [abciow12]/\zs.*\ze [abciow12]/')
                                endif
                                if filename ==# ''
                                  let filename = line_foldstart[5:-1]
                                endif
                                if exists('binary')
                                  return 'Binary: '.filename
                                else
                                  return (add<10&&remove<100?' ':'') . add . '+ ' . (remove<10&&add<100?' ':'') . remove . '- ' . filename
                                endif
                              elseif line_foldstart =~# '^# .*:$'
                                let lines = getline(v:foldstart, v:foldend)
                                call filter(lines, 'v:val =~# "^#\t"')
                                cal map(lines, "s:sub(v:val, '^#\t%(modified: +|renamed: +)=', '')")
                                cal map(lines, "s:sub(v:val, '^([[:alpha:] ]+): +(.*)', '\\2 (\\1)')")
                                return line_foldstart.' '.join(lines, ', ')
                              endif
                              return foldtext()
                            endfunction
                            
    1              0.000003 function! fugitive#foldtext() abort
                              return fugitive#Foldtext()
                            endfunction
                            
                            " Section: Initialization
                            
    1              0.000003 function! fugitive#Init() abort
                              throw 'Third party code is using fugitive#Init() which has been removed. Contact the author if you have a reason to still use it'
                            endfunction
                            
    1              0.000004 function! fugitive#is_git_dir(path) abort
                              throw 'Third party code is using fugitive#is_git_dir() which has been removed. Change it to FugitiveIsGitDir()'
                            endfunction
                            
    1              0.000004 function! fugitive#extract_git_dir(path) abort
                              throw 'Third party code is using fugitive#extract_git_dir() which has been removed. Change it to FugitiveExtractGitDir()'
                            endfunction
                            
    1              0.000004 function! fugitive#detect(path) abort
                              throw 'Third party code is using fugitive#detect() which has been removed. Contact the author if you have a reason to still use it'
                            endfunction
                            
                            " Section: End

SCRIPT  /Users/robertyang/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/autoload/airline/async.vim
Sourced 1 time
Total time:   0.000755
 Self time:   0.000755

count  total (s)   self (s)
                            " MIT License. Copyright (c) 2013-2020 Christian Brabandt et al.
                            " vim: et ts=2 sts=2 sw=2
                            
    1              0.000012 scriptencoding utf-8
                            
    1              0.000028 let s:untracked_jobs = {}
    1              0.000006 let s:mq_jobs        = {}
    1              0.000004 let s:po_jobs        = {}
    1              0.000004 let s:clean_jobs     = {}
                            
                            " Generic functions handling on exit event of the various async functions
    1              0.000011 function! s:untracked_output(dict, buf)
                              if a:buf =~? ('^'. a:dict.cfg['untracked_mark'])
                                let a:dict.cfg.untracked[a:dict.file] = get(g:, 'airline#extensions#branch#notexists', g:airline_symbols.notexists)
                              else
                                let a:dict.cfg.untracked[a:dict.file] = ''
                              endif
                            endfunction
                            
                            " also called from branch extension (for non-async vims)
    1              0.000006 function! airline#async#mq_output(buf, file)
                              let buf=a:buf
                              if !empty(a:buf)
                                if a:buf =~# 'no patches applied' ||
                                  \ a:buf =~# "unknown command 'qtop'" ||
                                  \ a:buf =~# "abort"
                                  let buf = ''
                                elseif exists("b:mq") && b:mq isnot# buf
                                  " make sure, statusline is updated
                                  unlet! b:airline_head
                                endif
                                let b:mq = buf
                              endif
                              if has_key(s:mq_jobs, a:file)
                                call remove(s:mq_jobs, a:file)
                              endif
                            endfunction
                            
    1              0.000005 function! s:po_output(buf, file)
                              if !empty(a:buf)
                                let b:airline_po_stats = printf("%s", a:buf)
                              else
                                let b:airline_po_stats = ''
                              endif
                              if has_key(s:po_jobs, a:file)
                                call remove(s:po_jobs, a:file)
                              endif
                            endfunction
                            
    1              0.000004 function! s:valid_dir(dir)
                              if empty(a:dir) || !isdirectory(a:dir)
                                return getcwd()
                              endif
                              return a:dir
                            endfunction
                            
    1              0.000006 function! airline#async#vcs_untracked(config, file, vcs)
                              if g:airline#init#vim_async
                                " Vim 8 with async support
                                noa call airline#async#vim_vcs_untracked(a:config, a:file)
                              else
                                " nvim async or vim without job-feature
                                noa call airline#async#nvim_vcs_untracked(a:config, a:file, a:vcs)
                              endif
                            endfunction
                            
    1              0.000005 function! s:set_clean_variables(file, vcs, val)
                              let var=getbufvar(fnameescape(a:file), 'buffer_vcs_config', {})
                              if has_key(var, a:vcs) && has_key(var[a:vcs], 'dirty') &&
                                    \ type(getbufvar(fnameescape(a:file), 'buffer_vcs_config')) == type({})
                                let var[a:vcs].dirty=a:val
                                try
                                  call setbufvar(fnameescape(a:file), 'buffer_vcs_config', var)
                                  unlet! b:airline_head
                                catch
                                endtry
                              endif
                            endfunction
                            
    1              0.000005 function! s:set_clean_jobs_variable(vcs, file, id)
                              if !has_key(s:clean_jobs, a:vcs)
                                let s:clean_jobs[a:vcs] = {}
                              endif
                              let s:clean_jobs[a:vcs][a:file]=a:id
                            endfunction
                            
    1              0.000004 function! s:on_exit_clean(...) dict abort
                              let buf=self.buf
                              call s:set_clean_variables(self.file, self.vcs, !empty(buf))
                              if has_key(get(s:clean_jobs, self.vcs, {}), self.file)
                                call remove(s:clean_jobs[self.vcs], self.file)
                              endif
                            endfunction
                            
    1              0.000005 function! airline#async#vcs_clean(cmd, file, vcs)
                              if g:airline#init#vim_async
                                " Vim 8 with async support
                                noa call airline#async#vim_vcs_clean(a:cmd, a:file, a:vcs)
                              elseif has("nvim")
                                " nvim async
                                noa call airline#async#nvim_vcs_clean(a:cmd, a:file, a:vcs)
                              else
                                " Vim pre 8 using system()
                                call airline#async#vim7_vcs_clean(a:cmd, a:file, a:vcs)
                              endif
                            endfunction
                            
    1              0.000018 if v:version >= 800 && has("job")
                              " Vim 8.0 with Job feature
                              " TODO: Check if we need the cwd option for the job_start() functions
                              "       (only works starting with Vim 8.0.0902)
                            
                              function! s:on_stdout(channel, msg) dict abort
                                let self.buf .= a:msg
                              endfunction
                            
                              function! s:on_exit_mq(channel) dict abort
                                call airline#async#mq_output(self.buf, self.file)
                              endfunction
                            
                              function! s:on_exit_untracked(channel) dict abort
                                call s:untracked_output(self, self.buf)
                                if has_key(s:untracked_jobs, self.file)
                                  call remove(s:untracked_jobs, self.file)
                                endif
                              endfunction
                            
                              function! s:on_exit_po(channel) dict abort
                                call s:po_output(self.buf, self.file)
                                call airline#extensions#po#shorten()
                              endfunction
                            
                              function! airline#async#get_mq_async(cmd, file)
                                if g:airline#init#is_windows && &shell =~ 'cmd\|powershell'
                                  let cmd = a:cmd
                                else
                                  let cmd = [&shell, &shellcmdflag, a:cmd]
                                endif
                            
                                let options = {'cmd': a:cmd, 'buf': '', 'file': a:file}
                                if has_key(s:mq_jobs, a:file)
                                  if job_status(get(s:mq_jobs, a:file)) == 'run'
                                    return
                                  elseif has_key(s:mq_jobs, a:file)
                                    call remove(s:mq_jobs, a:file)
                                  endif
                                endif
                                let id = job_start(cmd, {
                                      \ 'err_io':   'out',
                                      \ 'out_cb':   function('s:on_stdout', options),
                                      \ 'close_cb': function('s:on_exit_mq', options)})
                                let s:mq_jobs[a:file] = id
                              endfunction
                            
                              function! airline#async#get_msgfmt_stat(cmd, file)
                                if !executable('msgfmt')
                                  " no msgfmt
                                  return
                                endif
                                if g:airline#init#is_windows
                                  let cmd = 'cmd /C ' . a:cmd. shellescape(a:file)
                                else
                                  let cmd = ['sh', '-c', a:cmd. shellescape(a:file)]
                                endif
                            
                                let options = {'buf': '', 'file': a:file}
                                if has_key(s:po_jobs, a:file)
                                  if job_status(get(s:po_jobs, a:file)) == 'run'
                                    return
                                  elseif has_key(s:po_jobs, a:file)
                                    call remove(s:po_jobs, a:file)
                                  endif
                                endif
                                let id = job_start(cmd, {
                                      \ 'err_io':   'out',
                                      \ 'out_cb':   function('s:on_stdout', options),
                                      \ 'close_cb': function('s:on_exit_po', options)})
                                let s:po_jobs[a:file] = id
                              endfunction
                            
                              function! airline#async#vim_vcs_clean(cmd, file, vcs)
                                if g:airline#init#is_windows && &shell =~ 'cmd\|powershell'
                                  let cmd = a:cmd
                                else
                                  let cmd = [&shell, &shellcmdflag, a:cmd]
                                endif
                            
                                let options = {'buf': '', 'vcs': a:vcs, 'file': a:file}
                                let jobs = get(s:clean_jobs, a:vcs, {})
                                if has_key(jobs, a:file)
                                  if job_status(get(jobs, a:file)) == 'run'
                                    return
                                  elseif has_key(jobs, a:file)
                                    " still running
                                    return
                                    " jobs dict should be cleaned on exit, so not needed here
                                    " call remove(jobs, a:file)
                                  endif
                                endif
                                let id = job_start(cmd, {
                                      \ 'err_io':   'null',
                                      \ 'out_cb':   function('s:on_stdout', options),
                                      \ 'close_cb': function('s:on_exit_clean', options)})
                                call s:set_clean_jobs_variable(a:vcs, a:file, id)
                              endfunction
                            
                              function! airline#async#vim_vcs_untracked(config, file)
                                if g:airline#init#is_windows && &shell =~ 'cmd\|powershell'
                                  let cmd = a:config['cmd'] . shellescape(a:file)
                                else
                                  let cmd = [&shell, &shellcmdflag, a:config['cmd'] . shellescape(a:file)]
                                endif
                            
                                let options = {'cfg': a:config, 'buf': '', 'file': a:file}
                                if has_key(s:untracked_jobs, a:file)
                                  if job_status(get(s:untracked_jobs, a:file)) == 'run'
                                    return
                                  elseif has_key(s:untracked_jobs, a:file)
                                    call remove(s:untracked_jobs, a:file)
                                  endif
                                endif
                                let id = job_start(cmd, {
                                      \ 'err_io':   'out',
                                      \ 'out_cb':   function('s:on_stdout', options),
                                      \ 'close_cb': function('s:on_exit_untracked', options)})
                                let s:untracked_jobs[a:file] = id
                              endfunction
                            
    1              0.000008 elseif has("nvim")
                              " NVim specific functions
                            
    1              0.000006   function! s:nvim_output_handler(job_id, data, event) dict
                                if a:event == 'stdout' || a:event == 'stderr'
                                  let self.buf .=  join(a:data)
                                endif
                              endfunction
                            
    1              0.000005   function! s:nvim_untracked_job_handler(job_id, data, event) dict
                                if a:event == 'exit'
                                  call s:untracked_output(self, self.buf)
                                  if has_key(s:untracked_jobs, self.file)
                                    call remove(s:untracked_jobs, self.file)
                                  endif
                                endif
                              endfunction
                            
    1              0.000004   function! s:nvim_mq_job_handler(job_id, data, event) dict
                                if a:event == 'exit'
                                  call airline#async#mq_output(self.buf, self.file)
                                endif
                              endfunction
                            
    1              0.000004   function! s:nvim_po_job_handler(job_id, data, event) dict
                                if a:event == 'exit'
                                  call s:po_output(self.buf, self.file)
                                  call airline#extensions#po#shorten()
                                endif
                              endfunction
                            
    1              0.000005   function! airline#async#nvim_get_mq_async(cmd, file)
                                let config = {
                                \ 'buf': '',
                                \ 'file': a:file,
                                \ 'cwd': s:valid_dir(fnamemodify(a:file, ':p:h')),
                                \ 'on_stdout': function('s:nvim_output_handler'),
                                \ 'on_stderr': function('s:nvim_output_handler'),
                                \ 'on_exit': function('s:nvim_mq_job_handler')
                                \ }
                                if g:airline#init#is_windows && &shell =~ 'cmd\|powershell'
                                  let cmd = a:cmd
                                else
                                  let cmd = [&shell, &shellcmdflag, a:cmd]
                                endif
                            
                                if has_key(s:mq_jobs, a:file)
                                  call remove(s:mq_jobs, a:file)
                                endif
                                let id = jobstart(cmd, config)
                                let s:mq_jobs[a:file] = id
                              endfunction
                            
    1              0.000005   function! airline#async#nvim_get_msgfmt_stat(cmd, file)
                                let config = {
                                \ 'buf': '',
                                \ 'file': a:file,
                                \ 'cwd': s:valid_dir(fnamemodify(a:file, ':p:h')),
                                \ 'on_stdout': function('s:nvim_output_handler'),
                                \ 'on_stderr': function('s:nvim_output_handler'),
                                \ 'on_exit': function('s:nvim_po_job_handler')
                                \ }
                                if g:airline#init#is_windows && &shell =~ 'cmd\|powershell'
                                  " no msgfmt on windows?
                                  return
                                else
                                  let cmd = [&shell, &shellcmdflag, a:cmd. shellescape(a:file)]
                                endif
                            
                                if has_key(s:po_jobs, a:file)
                                  call remove(s:po_jobs, a:file)
                                endif
                                let id = jobstart(cmd, config)
                                let s:po_jobs[a:file] = id
                              endfunction
                            
    1              0.000005   function! airline#async#nvim_vcs_clean(cmd, file, vcs)
                                let config = {
                                \ 'buf': '',
                                \ 'vcs': a:vcs,
                                \ 'file': a:file,
                                \ 'cwd': s:valid_dir(fnamemodify(a:file, ':p:h')),
                                \ 'on_stdout': function('s:nvim_output_handler'),
                                \ 'on_stderr': function('s:nvim_output_handler'),
                                \ 'on_exit': function('s:on_exit_clean')}
                                if g:airline#init#is_windows && &shell =~ 'cmd\|powershell'
                                  let cmd = a:cmd
                                else
                                  let cmd = [&shell, &shellcmdflag, a:cmd]
                                endif
                            
                                if !has_key(s:clean_jobs, a:vcs)
                                  let s:clean_jobs[a:vcs] = {}
                                endif
                                if has_key(s:clean_jobs[a:vcs], a:file)
                                  " still running
                                  return
                                  " jobs dict should be cleaned on exit, so not needed here
                                  " call remove(s:clean_jobs[a:vcs], a:file)
                                endif
                                let id = jobstart(cmd, config)
                                call s:set_clean_jobs_variable(a:vcs, a:file, id)
                              endfunction
                            
    1              0.000002 endif
                            
                            " Should work in either Vim pre 8 or Nvim
    1              0.000005 function! airline#async#nvim_vcs_untracked(cfg, file, vcs)
                              let cmd = a:cfg.cmd . shellescape(a:file)
                              let id = -1
                              let config = {
                              \ 'buf': '',
                              \ 'vcs': a:vcs,
                              \ 'cfg': a:cfg,
                              \ 'file': a:file,
                              \ 'cwd': s:valid_dir(fnamemodify(a:file, ':p:h'))
                              \ }
                              if has("nvim")
                                call extend(config, {
                                \ 'on_stdout': function('s:nvim_output_handler'),
                                \ 'on_exit': function('s:nvim_untracked_job_handler')})
                                if has_key(s:untracked_jobs, config.file)
                                  " still running
                                  return
                                endif
                                try
                                let id = jobstart(cmd, config)
                                catch
                                  " catch-all, jobstart() failed, fall back to system()
                                  let id=-1
                                endtry
                                let s:untracked_jobs[a:file] = id
                              endif
                              " vim without job feature or nvim jobstart failed
                              if id < 1
                                let output=system(cmd)
                                call s:untracked_output(config, output)
                                call airline#extensions#branch#update_untracked_config(a:file, a:vcs)
                              endif
                            endfunction
                            
    1              0.000005 function! airline#async#vim7_vcs_clean(cmd, file, vcs)
                              " Vim pre 8, fallback using system()
                              " don't want to to see error messages
                              if g:airline#init#is_windows && &shell =~ 'cmd'
                                let cmd = a:cmd .' 2>nul'
                              elseif g:airline#init#is_windows && &shell =~ 'powerline'
                                let cmd = a:cmd .' 2> $null'
                              else
                                let cmd = a:cmd .' 2>/dev/null'
                              endif
                              let output=system(cmd)
                              call s:set_clean_variables(a:file, a:vcs, !empty(output))
                            endfunction

SCRIPT  /Users/robertyang/Repos/Configs/Neovim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/hunk.vim
Sourced 1 time
Total time:   0.000579
 Self time:   0.000579

count  total (s)   self (s)
    1              0.000016 let s:winid = 0
    1              0.000003 let s:preview_bufnr = 0
    1              0.000010 let s:nomodeline = (v:version > 703 || (v:version == 703 && has('patch442'))) ? '<nomodeline>' : ''
                            
    1              0.000005 function! gitgutter#hunk#set_hunks(bufnr, hunks) abort
                              call gitgutter#utility#setbufvar(a:bufnr, 'hunks', a:hunks)
                              call s:reset_summary(a:bufnr)
                            endfunction
                            
    1              0.000002 function! gitgutter#hunk#hunks(bufnr) abort
                              return gitgutter#utility#getbufvar(a:bufnr, 'hunks', [])
                            endfunction
                            
    1              0.000002 function! gitgutter#hunk#reset(bufnr) abort
                              call gitgutter#utility#setbufvar(a:bufnr, 'hunks', [])
                              call s:reset_summary(a:bufnr)
                            endfunction
                            
                            
    1              0.000002 function! gitgutter#hunk#summary(bufnr) abort
                              return gitgutter#utility#getbufvar(a:bufnr, 'summary', [0,0,0])
                            endfunction
                            
    1              0.000003 function! s:reset_summary(bufnr) abort
                              call gitgutter#utility#setbufvar(a:bufnr, 'summary', [0,0,0])
                            endfunction
                            
    1              0.000003 function! gitgutter#hunk#increment_lines_added(bufnr, count) abort
                              let summary = gitgutter#hunk#summary(a:bufnr)
                              let summary[0] += a:count
                              call gitgutter#utility#setbufvar(a:bufnr, 'summary', summary)
                            endfunction
                            
    1              0.000003 function! gitgutter#hunk#increment_lines_modified(bufnr, count) abort
                              let summary = gitgutter#hunk#summary(a:bufnr)
                              let summary[1] += a:count
                              call gitgutter#utility#setbufvar(a:bufnr, 'summary', summary)
                            endfunction
                            
    1              0.000003 function! gitgutter#hunk#increment_lines_removed(bufnr, count) abort
                              let summary = gitgutter#hunk#summary(a:bufnr)
                              let summary[2] += a:count
                              call gitgutter#utility#setbufvar(a:bufnr, 'summary', summary)
                            endfunction
                            
                            
    1              0.000002 function! gitgutter#hunk#next_hunk(count) abort
                              let bufnr = bufnr('')
                              if !gitgutter#utility#is_active(bufnr) | return | endif
                            
                              let hunks = gitgutter#hunk#hunks(bufnr)
                              if empty(hunks)
                                call gitgutter#utility#warn('No hunks in file')
                                return
                              endif
                            
                              let current_line = line('.')
                              let hunk_count = 0
                              for hunk in hunks
                                if hunk[2] > current_line
                                  let hunk_count += 1
                                  if hunk_count == a:count
                                    execute 'normal!' hunk[2] . 'Gzv'
                                    if g:gitgutter_show_msg_on_hunk_jumping
                                      redraw | echo printf('Hunk %d of %d', index(hunks, hunk) + 1, len(hunks))
                                    endif
                                    return
                                  endif
                                endif
                              endfor
                              call gitgutter#utility#warn('No more hunks')
                            endfunction
                            
    1              0.000002 function! gitgutter#hunk#prev_hunk(count) abort
                              let bufnr = bufnr('')
                              if !gitgutter#utility#is_active(bufnr) | return | endif
                            
                              let hunks = gitgutter#hunk#hunks(bufnr)
                              if empty(hunks)
                                call gitgutter#utility#warn('No hunks in file')
                                return
                              endif
                            
                              let current_line = line('.')
                              let hunk_count = 0
                              for hunk in reverse(copy(hunks))
                                if hunk[2] < current_line
                                  let hunk_count += 1
                                  if hunk_count == a:count
                                    let target = hunk[2] == 0 ? 1 : hunk[2]
                                    execute 'normal!' target . 'Gzv'
                                    if g:gitgutter_show_msg_on_hunk_jumping
                                      redraw | echo printf('Hunk %d of %d', index(hunks, hunk) + 1, len(hunks))
                                    endif
                                    return
                                  endif
                                endif
                              endfor
                              call gitgutter#utility#warn('No previous hunks')
                            endfunction
                            
                            " Returns the hunk the cursor is currently in or an empty list if the cursor
                            " isn't in a hunk.
    1              0.000002 function! s:current_hunk() abort
                              let bufnr = bufnr('')
                              let current_hunk = []
                            
                              for hunk in gitgutter#hunk#hunks(bufnr)
                                if gitgutter#hunk#cursor_in_hunk(hunk)
                                  let current_hunk = hunk
                                  break
                                endif
                              endfor
                            
                              return current_hunk
                            endfunction
                            
                            " Returns truthy if the cursor is in two hunks (which can only happen if the
                            " cursor is on the first line and lines above have been deleted and lines
                            " immediately below have been deleted) or falsey otherwise.
    1              0.000002 function! s:cursor_in_two_hunks()
                              let hunks = gitgutter#hunk#hunks(bufnr(''))
                            
                              if line('.') == 1 && len(hunks) > 1 && hunks[0][2:3] == [0, 0] && hunks[1][2:3] == [1, 0]
                                return 1
                              endif
                            
                              return 0
                            endfunction
                            
                            " A line can be in 0 or 1 hunks, with the following exception: when the first
                            " line(s) of a file has been deleted, and the new second line (and
                            " optionally below) has been deleted, the new first line is in two hunks.
    1              0.000002 function! gitgutter#hunk#cursor_in_hunk(hunk) abort
                              let current_line = line('.')
                            
                              if current_line == 1 && a:hunk[2] == 0
                                return 1
                              endif
                            
                              if current_line >= a:hunk[2] && current_line < a:hunk[2] + (a:hunk[3] == 0 ? 1 : a:hunk[3])
                                return 1
                              endif
                            
                              return 0
                            endfunction
                            
                            
    1              0.000002 function! gitgutter#hunk#in_hunk(lnum)
                              " Hunks are sorted in the order they appear in the buffer.
                              for hunk in gitgutter#hunk#hunks(bufnr(''))
                                " if in a hunk on first line of buffer
                                if a:lnum == 1 && hunk[2] == 0
                                  return 1
                                endif
                            
                                " if in a hunk generally
                                if a:lnum >= hunk[2] && a:lnum < hunk[2] + (hunk[3] == 0 ? 1 : hunk[3])
                                  return 1
                                endif
                            
                                " if hunk starts after the given line
                                if a:lnum < hunk[2]
                                  return 0
                                endif
                              endfor
                            
                              return 0
                            endfunction
                            
                            
    1              0.000002 function! gitgutter#hunk#text_object(inner) abort
                              let hunk = s:current_hunk()
                            
                              if empty(hunk)
                                return
                              endif
                            
                              let [first_line, last_line] = [hunk[2], hunk[2] + hunk[3] - 1]
                            
                              if ! a:inner
                                let lnum = last_line
                                let eof = line('$')
                                while lnum < eof && empty(getline(lnum + 1))
                                  let lnum +=1
                                endwhile
                                let last_line = lnum
                              endif
                            
                              execute 'normal! 'first_line.'GV'.last_line.'G'
                            endfunction
                            
                            
    1              0.000002 function! gitgutter#hunk#stage(...) abort
                              if !s:in_hunk_preview_window() && !gitgutter#utility#has_repo_path(bufnr('')) | return | endif
                            
                              if a:0 && (a:1 != 1 || a:2 != line('$'))
                                call s:hunk_op(function('s:stage'), a:1, a:2)
                              else
                                call s:hunk_op(function('s:stage'))
                              endif
                              silent! call repeat#set("\<Plug>(GitGutterStageHunk)", -1)
                            endfunction
                            
    1              0.000002 function! gitgutter#hunk#undo() abort
                              if !gitgutter#utility#has_repo_path(bufnr('')) | return | endif
                            
                              call s:hunk_op(function('s:undo'))
                              silent! call repeat#set("\<Plug>(GitGutterUndoHunk)", -1)
                            endfunction
                            
    1              0.000002 function! gitgutter#hunk#preview() abort
                              if !gitgutter#utility#has_repo_path(bufnr('')) | return | endif
                            
                              call s:hunk_op(function('s:preview'))
                              silent! call repeat#set("\<Plug>(GitGutterPreviewHunk)", -1)
                            endfunction
                            
                            
    1              0.000002 function! s:hunk_op(op, ...)
                              let bufnr = bufnr('')
                            
                              if s:in_hunk_preview_window()
                                if string(a:op) =~ '_stage'
                                  " combine hunk-body in preview window with updated hunk-header
                                  let hunk_body = getline(1, '$')
                            
                                  let [removed, added] = [0, 0]
                                  for line in hunk_body
                                    if line[0] == '-'
                                      let removed += 1
                                    elseif line[0] == '+'
                                      let added += 1
                                    endif
                                  endfor
                            
                                  let hunk_header = b:hunk_header
                                  " from count
                                  let hunk_header[4] = substitute(hunk_header[4], '\(-\d\+\)\(,\d\+\)\?', '\=submatch(1).",".removed', '')
                                  " to count
                                  let hunk_header[4] = substitute(hunk_header[4], '\(+\d\+\)\(,\d\+\)\?', '\=submatch(1).",".added', '')
                            
                                  let hunk_diff = join(hunk_header + hunk_body, "\n")."\n"
                            
                                  call s:goto_original_window()
                                  call s:close_hunk_preview_window()
                                  call s:stage(hunk_diff)
                                endif
                            
                                return
                              endif
                            
                              if gitgutter#utility#is_active(bufnr)
                                " Get a (synchronous) diff.
                                let [async, g:gitgutter_async] = [g:gitgutter_async, 0]
                                let diff = gitgutter#diff#run_diff(bufnr, g:gitgutter_diff_relative_to, 1)
                                let g:gitgutter_async = async
                            
                                call gitgutter#hunk#set_hunks(bufnr, gitgutter#diff#parse_diff(diff))
                            
                                if empty(s:current_hunk())
                                  call gitgutter#utility#warn('cursor is not in a hunk')
                                elseif s:cursor_in_two_hunks()
                                  let choice = input('Choose hunk: upper or lower (u/l)? ')
                                  " Clear input
                                  normal! :<ESC>
                                  if choice =~ 'u'
                                    call a:op(gitgutter#diff#hunk_diff(bufnr, diff, 0))
                                  elseif choice =~ 'l'
                                    call a:op(gitgutter#diff#hunk_diff(bufnr, diff, 1))
                                  else
                                    call gitgutter#utility#warn('did not recognise your choice')
                                  endif
                                else
                                  let hunk_diff = gitgutter#diff#hunk_diff(bufnr, diff)
                            
                                  if a:0
                                    let hunk_first_line = s:current_hunk()[2]
                                    let hunk_diff = s:part_of_diff(hunk_diff, a:1-hunk_first_line, a:2-hunk_first_line)
                                  endif
                            
                                  call a:op(hunk_diff)
                                endif
                              endif
                            endfunction
                            
                            
    1              0.000002 function! s:stage(hunk_diff)
                              let bufnr = bufnr('')
                              let diff = s:adjust_header(bufnr, a:hunk_diff)
                              " Apply patch to index.
                              call gitgutter#utility#system(
                                    \ gitgutter#utility#cd_cmd(bufnr, g:gitgutter_git_executable.' '.g:gitgutter_git_args.' apply --cached --unidiff-zero - '),
                                    \ diff)
                              if v:shell_error
                                call gitgutter#utility#warn('patch does not apply')
                              else
                                if exists('#User#GitGutterStage')
                                  execute 'doautocmd' s:nomodeline 'User GitGutterStage'
                                endif
                              endif
                            
                              " Refresh gitgutter's view of buffer.
                              call gitgutter#process_buffer(bufnr, 1)
                            endfunction
                            
                            
    1              0.000002 function! s:undo(hunk_diff)
                              " Apply reverse patch to buffer.
                              let hunk  = gitgutter#diff#parse_hunk(split(a:hunk_diff, '\n')[4])
                              let lines = map(split(a:hunk_diff, '\r\?\n')[5:], 'v:val[1:]')
                              let lnum  = hunk[2]
                              let added_only   = hunk[1] == 0 && hunk[3]  > 0
                              let removed_only = hunk[1]  > 0 && hunk[3] == 0
                            
                              if removed_only
                                call append(lnum, lines)
                              elseif added_only
                                execute lnum .','. (lnum+len(lines)-1) .'d _'
                              else
                                call append(lnum-1, lines[0:hunk[1]])
                                execute (lnum+hunk[1]) .','. (lnum+hunk[1]+hunk[3]) .'d _'
                              endif
                            endfunction
                            
                            
    1              0.000002 function! s:preview(hunk_diff)
                              let lines = split(a:hunk_diff, '\r\?\n')
                              let header = lines[0:4]
                              let body = lines[5:]
                            
                              call s:open_hunk_preview_window()
                              call s:populate_hunk_preview_window(header, body)
                              call s:enable_staging_from_hunk_preview_window()
                              if &previewwindow
                                call s:goto_original_window()
                              endif
                            endfunction
                            
                            
                            " Returns a new hunk diff using the specified lines from the given one.
                            " Assumes all lines are additions.
                            " a:first, a:last - 0-based indexes into the body of the hunk.
    1              0.000003 function! s:part_of_diff(hunk_diff, first, last)
                              let diff_lines = split(a:hunk_diff, '\n', 1)
                            
                              " adjust 'to' line count in header
                              let diff_lines[4] = substitute(diff_lines[4], '\(+\d\+\)\(,\d\+\)\?', '\=submatch(1).",".(a:last-a:first+1)', '')
                            
                              return join(diff_lines[0:4] + diff_lines[5+a:first:5+a:last], "\n")."\n"
                            endfunction
                            
                            
    1              0.000002 function! s:adjust_header(bufnr, hunk_diff)
                              let filepath = gitgutter#utility#repo_path(a:bufnr, 0)
                              return s:adjust_hunk_summary(s:fix_file_references(filepath, a:hunk_diff))
                            endfunction
                            
                            
                            " Replaces references to temp files with the actual file.
    1              0.000002 function! s:fix_file_references(filepath, hunk_diff)
                              let lines = split(a:hunk_diff, '\n')
                            
                              let left_prefix  = matchstr(lines[2], '[abciow12]').'/'
                              let right_prefix = matchstr(lines[3], '[abciow12]').'/'
                              let quote        = lines[0][11] == '"' ? '"' : ''
                            
                              let left_file  = quote.left_prefix.a:filepath.quote
                              let right_file = quote.right_prefix.a:filepath.quote
                            
                              let lines[0] = 'diff --git '.left_file.' '.right_file
                              let lines[2] = '--- '.left_file
                              let lines[3] = '+++ '.right_file
                            
                              return join(lines, "\n")."\n"
                            endfunction
                            
    1              0.000012 if $VIM_GITGUTTER_TEST
                              function! gitgutter#hunk#fix_file_references(filepath, hunk_diff)
                                return s:fix_file_references(a:filepath, a:hunk_diff)
                              endfunction
    1              0.000001 endif
                            
                            
    1              0.000002 function! s:adjust_hunk_summary(hunk_diff) abort
                              let line_adjustment = s:line_adjustment_for_current_hunk()
                              let diff = split(a:hunk_diff, '\n', 1)
                              let diff[4] = substitute(diff[4], '+\zs\(\d\+\)', '\=submatch(1)+line_adjustment', '')
                              return join(diff, "\n")
                            endfunction
                            
                            
                            " Returns the number of lines the current hunk is offset from where it would
                            " be if any changes above it in the file didn't exist.
    1              0.000002 function! s:line_adjustment_for_current_hunk() abort
                              let bufnr = bufnr('')
                              let adj = 0
                              for hunk in gitgutter#hunk#hunks(bufnr)
                                if gitgutter#hunk#cursor_in_hunk(hunk)
                                  break
                                else
                                  let adj += hunk[1] - hunk[3]
                                endif
                              endfor
                              return adj
                            endfunction
                            
                            
    1              0.000002 function! s:in_hunk_preview_window()
                              if g:gitgutter_preview_win_floating
                                return win_id2win(s:winid) == winnr()
                              else
                                return &previewwindow
                              endif
                            endfunction
                            
                            
                            " Floating window: does not move cursor to floating window.
                            " Preview window: moves cursor to preview window.
    1              0.000002 function! s:open_hunk_preview_window()
                              if g:gitgutter_preview_win_floating
                                if exists('*nvim_open_win')
                                  call s:close_hunk_preview_window()
                            
                                  let buf = nvim_create_buf(v:false, v:false)
                                  " Set default width and height for now.
                                  let s:winid = nvim_open_win(buf, v:false, {
                                        \ 'relative': 'cursor',
                                        \ 'row': 1,
                                        \ 'col': 0,
                                        \ 'width': 42,
                                        \ 'height': &previewheight,
                                        \ 'style': 'minimal'
                                        \ })
                                  call nvim_buf_set_option(buf, 'filetype',  'diff')
                                  call nvim_buf_set_option(buf, 'buftype',   'acwrite')
                                  call nvim_buf_set_option(buf, 'bufhidden', 'delete')
                                  call nvim_buf_set_option(buf, 'swapfile',  v:false)
                                  call nvim_buf_set_name(buf, 'gitgutter://hunk-preview')
                            
                                  " Assumes cursor is in original window.
                                  autocmd CursorMoved <buffer> ++once call s:close_hunk_preview_window()
                            
                                  return
                                endif
                            
                                if exists('*popup_create')
                                  let s:winid = popup_create('', {
                                        \ 'line': 'cursor+1',
                                        \ 'col': 'cursor',
                                        \ 'moved': 'any',
                                        \ })
                            
                                  call setbufvar(winbufnr(s:winid), '&filetype', 'diff')
                            
                                  return
                                endif
                              endif
                            
                              silent! wincmd P
                              if &previewwindow
                                file gitgutter://hunk-preview
                              else
                                noautocmd execute g:gitgutter_preview_win_location &previewheight 'new gitgutter://hunk-preview'
                                doautocmd WinEnter
                                set previewwindow
                              endif
                              if exists('*win_getid')
                                let s:winid = win_getid()
                              else
                                let s:preview_bufnr = bufnr('')
                              endif
                              setlocal filetype=diff buftype=acwrite bufhidden=delete
                              " Reset some defaults in case someone else has changed them.
                              setlocal noreadonly modifiable noswapfile
                              if g:gitgutter_close_preview_on_escape
                                nnoremap <buffer> <silent> <Esc> :pclose<CR>
                              endif
                            endfunction
                            
                            
                            " Floating window: does not care where cursor is.
                            " Preview window: assumes cursor is in preview window.
    1              0.000003 function! s:populate_hunk_preview_window(header, body)
                              let body_length = len(a:body)
                            
                              if g:gitgutter_preview_win_floating
                                if exists('*nvim_open_win')
                                  let height = min([body_length, &previewheight])
                            
                                  " Assumes cursor is not in previewing window.
                                  call nvim_buf_set_var(winbufnr(s:winid), 'hunk_header', a:header)
                            
                                  let [_scrolloff, &scrolloff] = [&scrolloff, 0]
                            
                                  let width = max(map(copy(a:body), 'strdisplaywidth(v:val)'))
                                  call nvim_win_set_width(s:winid, width)
                                  call nvim_win_set_height(s:winid, height)
                            
                                  let &scrolloff=_scrolloff
                            
                                  call nvim_buf_set_lines(winbufnr(s:winid), 0, -1, v:false, [])
                                  call nvim_buf_set_lines(winbufnr(s:winid), 0, -1, v:false, a:body)
                                  call nvim_buf_set_option(winbufnr(s:winid), 'modified', v:false)
                            
                                  let ns_id = nvim_create_namespace('GitGutter')
                                  call nvim_buf_clear_namespace(winbufnr(s:winid), ns_id, 0, -1)
                                  for region in gitgutter#diff_highlight#process(a:body)
                                    let group = region[1] == '+' ? 'GitGutterAddIntraLine' : 'GitGutterDeleteIntraLine'
                                    call nvim_buf_add_highlight(winbufnr(s:winid), ns_id, group, region[0]-1, region[2]-1, region[3])
                                  endfor
                            
                                  call nvim_win_set_cursor(s:winid, [1,0])
                                endif
                            
                                if exists('*popup_create')
                                  call popup_settext(s:winid, a:body)
                            
                                  for region in gitgutter#diff_highlight#process(a:body)
                                    let group = region[1] == '+' ? 'GitGutterAddIntraLine' : 'GitGutterDeleteIntraLine'
                                    call win_execute(s:winid, "call matchaddpos('".group."', [[".region[0].", ".region[2].", ".(region[3]-region[2]+1)."]])")
                                  endfor
                                endif
                            
                              else
                                let b:hunk_header = a:header
                            
                                %delete _
                                call setline(1, a:body)
                                setlocal nomodified
                            
                                normal! G$
                                let height = min([winline(), &previewheight])
                                execute 'resize' height
                                1
                            
                                call clearmatches()
                                for region in gitgutter#diff_highlight#process(a:body)
                                  let group = region[1] == '+' ? 'GitGutterAddIntraLine' : 'GitGutterDeleteIntraLine'
                                  call matchaddpos(group, [[region[0], region[2], region[3]-region[2]+1]])
                                endfor
                            
                                1
                              endif
                            endfunction
                            
                            
    1              0.000002 function! s:enable_staging_from_hunk_preview_window()
                              augroup gitgutter_hunk_preview
                                autocmd!
                                let bufnr = s:winid != 0 ? winbufnr(s:winid) : s:preview_bufnr
                                execute 'autocmd BufWriteCmd <buffer='.bufnr.'> GitGutterStageHunk'
                              augroup END
                            endfunction
                            
                            
    1              0.000003 function! s:goto_original_window()
                              noautocmd wincmd p
                              doautocmd WinEnter
                            endfunction
                            
                            
    1              0.000002 function! s:close_hunk_preview_window()
                              let bufnr = s:winid != 0 ? winbufnr(s:winid) : s:preview_bufnr
                              call setbufvar(bufnr, '&modified', 0)
                            
                              if g:gitgutter_preview_win_floating
                                if win_id2win(s:winid) > 0
                                  execute win_id2win(s:winid).'wincmd c'
                                endif
                              else
                                pclose
                              endif
                            
                              let s:winid = 0
                              let s:preview_bufnr = 0
                            endfunction

SCRIPT  /Users/robertyang/Repos/Configs/Neovim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim
Sourced 1 time
Total time:   0.045568
 Self time:   0.000454

count  total (s)   self (s)
    1              0.000012 scriptencoding utf8
                            
    1              0.000017 let s:nomodeline = (v:version > 703 || (v:version == 703 && has('patch442'))) ? '<nomodeline>' : ''
                            
    1              0.000003 let s:hunk_re = '^@@ -\(\d\+\),\?\(\d*\) +\(\d\+\),\?\(\d*\) @@'
                            
                            " True for git v1.7.2+.
    1              0.000006 function! s:git_supports_command_line_config_override() abort
                              call gitgutter#utility#system(g:gitgutter_git_executable.' '.g:gitgutter_git_args.' -c foo.bar=baz --version')
                              return !v:shell_error
                            endfunction
                            
    1   0.045138   0.000024 let s:c_flag = s:git_supports_command_line_config_override()
                            
    1              0.000003 let s:counter = 0
                            
                            " Returns a diff of the buffer against the index or the working tree.
                            "
                            " After running the diff we pass it through grep where available to reduce
                            " subsequent processing by the plugin.  If grep is not available the plugin
                            " does the filtering instead.
                            "
                            " When diffing against the index:
                            "
                            " The buffer contents is not the same as the file on disk so we need to pass
                            " two instances of the file to git-diff:
                            "
                            "     git diff myfileA myfileB
                            "
                            " where myfileA comes from
                            "
                            "     git show :myfile > myfileA
                            "
                            " and myfileB is the buffer contents.
                            "
                            " Regarding line endings:
                            "
                            " git-show does not convert line endings.
                            " git-diff FILE FILE does convert line endings for the given files.
                            "
                            " If a file has CRLF line endings and git's core.autocrlf is true,
                            " the file in git's object store will have LF line endings.  Writing
                            " it out via git-show will produce a file with LF line endings.
                            "
                            " If this last file is one of the files passed to git-diff, git-diff will
                            " convert its line endings to CRLF before diffing -- which is what we want --
                            " but also by default output a warning on stderr.
                            "
                            "   warning: LF will be replace by CRLF in <temp file>.
                            "   The file will have its original line endings in your working directory.
                            "
                            " When running the diff asynchronously, the warning message triggers the stderr
                            " callbacks which assume the overall command has failed and reset all the
                            " signs.  As this is not what we want, and we can safely ignore the warning,
                            " we turn it off by passing the '-c "core.safecrlf=false"' argument to
                            " git-diff.
                            "
                            " When writing the temporary files we preserve the original file's extension
                            " so that repos using .gitattributes to control EOL conversion continue to
                            " convert correctly.
                            "
                            " Arguments:
                            "
                            " bufnr              - the number of the buffer to be diffed
                            " from               - 'index' or 'working_tree'; what the buffer is diffed against
                            " preserve_full_diff - truthy to return the full diff or falsey to return only
                            "                      the hunk headers (@@ -x,y +m,n @@); only possible if
                            "                      grep is available.
    1              0.000005 function! gitgutter#diff#run_diff(bufnr, from, preserve_full_diff) abort
                              if gitgutter#utility#repo_path(a:bufnr, 0) == -1
                                throw 'gitgutter author fail'
                              endif
                            
                              if gitgutter#utility#repo_path(a:bufnr, 0) == -2
                                throw 'gitgutter not tracked'
                              endif
                            
                              let temp_from = tempname()
                              let temp_buffer = tempname()
                            
                              " Wrap compound commands in parentheses to make Windows happy.
                              " bash doesn't mind the parentheses.
                              let cmd = '('
                            
                              " Append buffer number to temp filenames to avoid race conditions between
                              " writing and reading the files when asynchronously processing multiple
                              " buffers.
                            
                              " Without the buffer number, buff_file would have a race between the
                              " second gitgutter#process_buffer() writing the file (synchronously, below)
                              " and the first gitgutter#process_buffer()'s async job reading it (with
                              " git-diff).
                              let buff_file = temp_buffer.'.'.a:bufnr
                            
                              " Add a counter to avoid a similar race with two quick writes of the same buffer.
                              " Use a modulus greater than a maximum reasonable number of visible buffers.
                              let s:counter = (s:counter + 1) % 20
                              let buff_file .= '.'.s:counter
                            
                              let extension = gitgutter#utility#extension(a:bufnr)
                              if !empty(extension)
                                let buff_file .= '.'.extension
                              endif
                            
                              " Write buffer to temporary file.
                              " Note: this is synchronous.
                              call s:write_buffer(a:bufnr, buff_file)
                            
                              if a:from ==# 'index'
                                " Without the buffer number, from_file would have a race in the shell
                                " between the second process writing it (with git-show) and the first
                                " reading it (with git-diff).
                                let from_file = temp_from.'.'.a:bufnr
                            
                                " Add a counter to avoid a similar race with two quick writes of the same buffer.
                                let from_file .= '.'.s:counter
                            
                                if !empty(extension)
                                  let from_file .= '.'.extension
                                endif
                            
                                " Write file from index to temporary file.
                                let index_name = gitgutter#utility#get_diff_base(a:bufnr).':'.gitgutter#utility#repo_path(a:bufnr, 1)
                                let cmd .= g:gitgutter_git_executable.' '.g:gitgutter_git_args.' --no-pager show '.index_name.' > '.from_file.' && '
                            
                              elseif a:from ==# 'working_tree'
                                let from_file = gitgutter#utility#repo_path(a:bufnr, 1)
                              endif
                            
                              " Call git-diff.
                              let cmd .= g:gitgutter_git_executable.' '.g:gitgutter_git_args.' --no-pager'
                              if s:c_flag
                                let cmd .= ' -c "diff.autorefreshindex=0"'
                                let cmd .= ' -c "diff.noprefix=false"'
                                let cmd .= ' -c "core.safecrlf=false"'
                              endif
                              let cmd .= ' diff --no-ext-diff --no-color -U0 '.g:gitgutter_diff_args.' -- '.from_file.' '.buff_file
                            
                              " Pipe git-diff output into grep.
                              if !a:preserve_full_diff && !empty(g:gitgutter_grep)
                                let cmd .= ' | '.g:gitgutter_grep.' '.gitgutter#utility#shellescape('^@@ ')
                              endif
                            
                              " grep exits with 1 when no matches are found; git-diff exits with 1 when
                              " differences are found.  However we want to treat non-matches and
                              " differences as non-erroneous behaviour; so we OR the command with one
                              " which always exits with success (0).
                              let cmd .= ' || exit 0'
                            
                              let cmd .= ')'
                            
                              let cmd = gitgutter#utility#cd_cmd(a:bufnr, cmd)
                            
                              if g:gitgutter_async && gitgutter#async#available()
                                call gitgutter#async#execute(cmd, a:bufnr, {
                                      \   'out': function('gitgutter#diff#handler'),
                                      \   'err': function('gitgutter#hunk#reset'),
                                      \ })
                                return 'async'
                            
                              else
                                let diff = gitgutter#utility#system(cmd)
                            
                                if v:shell_error
                                  call gitgutter#debug#log(diff)
                                  throw 'gitgutter diff failed'
                                endif
                            
                                return diff
                              endif
                            endfunction
                            
                            
    1              0.000003 function! gitgutter#diff#handler(bufnr, diff) abort
                              call gitgutter#debug#log(a:diff)
                            
                              if !bufexists(a:bufnr)
                                return
                              endif
                            
                              call gitgutter#hunk#set_hunks(a:bufnr, gitgutter#diff#parse_diff(a:diff))
                              let modified_lines = gitgutter#diff#process_hunks(a:bufnr, gitgutter#hunk#hunks(a:bufnr))
                            
                              let signs_count = len(modified_lines)
                              if g:gitgutter_max_signs != -1 && signs_count > g:gitgutter_max_signs
                                call gitgutter#utility#warn_once(a:bufnr, printf(
                                      \ 'exceeded maximum number of signs (%d > %d, configured by g:gitgutter_max_signs).',
                                      \ signs_count, g:gitgutter_max_signs), 'max_signs')
                                call gitgutter#sign#clear_signs(a:bufnr)
                            
                              else
                                if g:gitgutter_signs || g:gitgutter_highlight_lines || g:gitgutter_highlight_linenrs
                                  call gitgutter#sign#update_signs(a:bufnr, modified_lines)
                                endif
                              endif
                            
                              call s:save_last_seen_change(a:bufnr)
                              if exists('#User#GitGutter')
                                let g:gitgutter_hook_context = {'bufnr': a:bufnr}
                                execute 'doautocmd' s:nomodeline 'User GitGutter'
                                unlet g:gitgutter_hook_context
                              endif
                            endfunction
                            
                            
    1              0.000002 function! gitgutter#diff#parse_diff(diff) abort
                              let hunks = []
                              for line in split(a:diff, '\n')
                                let hunk_info = gitgutter#diff#parse_hunk(line)
                                if len(hunk_info) == 4
                                  call add(hunks, hunk_info)
                                endif
                              endfor
                              return hunks
                            endfunction
                            
    1              0.000002 function! gitgutter#diff#parse_hunk(line) abort
                              let matches = matchlist(a:line, s:hunk_re)
                              if len(matches) > 0
                                let from_line  = str2nr(matches[1])
                                let from_count = (matches[2] == '') ? 1 : str2nr(matches[2])
                                let to_line    = str2nr(matches[3])
                                let to_count   = (matches[4] == '') ? 1 : str2nr(matches[4])
                                return [from_line, from_count, to_line, to_count]
                              else
                                return []
                              end
                            endfunction
                            
                            " This function is public so it may be used by other plugins
                            " e.g. vim-signature.
    1              0.000003 function! gitgutter#diff#process_hunks(bufnr, hunks) abort
                              let modified_lines = []
                              for hunk in a:hunks
                                call extend(modified_lines, s:process_hunk(a:bufnr, hunk))
                              endfor
                              return modified_lines
                            endfunction
                            
                            " Returns [ [<line_number (number)>, <name (string)>], ...]
    1              0.000003 function! s:process_hunk(bufnr, hunk) abort
                              let modifications = []
                              let from_line  = a:hunk[0]
                              let from_count = a:hunk[1]
                              let to_line    = a:hunk[2]
                              let to_count   = a:hunk[3]
                            
                              if s:is_added(from_count, to_count)
                                call s:process_added(modifications, from_count, to_count, to_line)
                                call gitgutter#hunk#increment_lines_added(a:bufnr, to_count)
                            
                              elseif s:is_removed(from_count, to_count)
                                call s:process_removed(modifications, from_count, to_count, to_line)
                                call gitgutter#hunk#increment_lines_removed(a:bufnr, from_count)
                            
                              elseif s:is_modified(from_count, to_count)
                                call s:process_modified(modifications, from_count, to_count, to_line)
                                call gitgutter#hunk#increment_lines_modified(a:bufnr, to_count)
                            
                              elseif s:is_modified_and_added(from_count, to_count)
                                call s:process_modified_and_added(modifications, from_count, to_count, to_line)
                                call gitgutter#hunk#increment_lines_added(a:bufnr, to_count - from_count)
                                call gitgutter#hunk#increment_lines_modified(a:bufnr, from_count)
                            
                              elseif s:is_modified_and_removed(from_count, to_count)
                                call s:process_modified_and_removed(modifications, from_count, to_count, to_line)
                                call gitgutter#hunk#increment_lines_modified(a:bufnr, to_count)
                                call gitgutter#hunk#increment_lines_removed(a:bufnr, from_count - to_count)
                            
                              endif
                              return modifications
                            endfunction
                            
    1              0.000002 function! s:is_added(from_count, to_count) abort
                              return a:from_count == 0 && a:to_count > 0
                            endfunction
                            
    1              0.000002 function! s:is_removed(from_count, to_count) abort
                              return a:from_count > 0 && a:to_count == 0
                            endfunction
                            
    1              0.000002 function! s:is_modified(from_count, to_count) abort
                              return a:from_count > 0 && a:to_count > 0 && a:from_count == a:to_count
                            endfunction
                            
    1              0.000002 function! s:is_modified_and_added(from_count, to_count) abort
                              return a:from_count > 0 && a:to_count > 0 && a:from_count < a:to_count
                            endfunction
                            
    1              0.000002 function! s:is_modified_and_removed(from_count, to_count) abort
                              return a:from_count > 0 && a:to_count > 0 && a:from_count > a:to_count
                            endfunction
                            
    1              0.000003 function! s:process_added(modifications, from_count, to_count, to_line) abort
                              let offset = 0
                              while offset < a:to_count
                                let line_number = a:to_line + offset
                                call add(a:modifications, [line_number, 'added'])
                                let offset += 1
                              endwhile
                            endfunction
                            
    1              0.000003 function! s:process_removed(modifications, from_count, to_count, to_line) abort
                              if a:to_line == 0
                                call add(a:modifications, [1, 'removed_first_line'])
                              else
                                call add(a:modifications, [a:to_line, 'removed'])
                              endif
                            endfunction
                            
    1              0.000003 function! s:process_modified(modifications, from_count, to_count, to_line) abort
                              let offset = 0
                              while offset < a:to_count
                                let line_number = a:to_line + offset
                                call add(a:modifications, [line_number, 'modified'])
                                let offset += 1
                              endwhile
                            endfunction
                            
    1              0.000003 function! s:process_modified_and_added(modifications, from_count, to_count, to_line) abort
                              let offset = 0
                              while offset < a:from_count
                                let line_number = a:to_line + offset
                                call add(a:modifications, [line_number, 'modified'])
                                let offset += 1
                              endwhile
                              while offset < a:to_count
                                let line_number = a:to_line + offset
                                call add(a:modifications, [line_number, 'added'])
                                let offset += 1
                              endwhile
                            endfunction
                            
    1              0.000003 function! s:process_modified_and_removed(modifications, from_count, to_count, to_line) abort
                              let offset = 0
                              while offset < a:to_count
                                let line_number = a:to_line + offset
                                call add(a:modifications, [line_number, 'modified'])
                                let offset += 1
                              endwhile
                              let a:modifications[-1] = [a:to_line + offset - 1, 'modified_removed']
                            endfunction
                            
                            
                            " Returns a diff for the current hunk.
                            " Assumes there is only 1 current hunk unless the optional argument is given,
                            " in which case the cursor is in two hunks and the argument specifies the one
                            " to choose.
                            "
                            " Optional argument: 0 (to use the first hunk) or 1 (to use the second).
    1              0.000002 function! gitgutter#diff#hunk_diff(bufnr, full_diff, ...)
                              let modified_diff = []
                              let hunk_index = 0
                              let keep_line = 1
                              " Don't keepempty when splitting because the diff we want may not be the
                              " final one.  Instead add trailing NL at end of function.
                              for line in split(a:full_diff, '\n')
                                let hunk_info = gitgutter#diff#parse_hunk(line)
                                if len(hunk_info) == 4  " start of new hunk
                                  let keep_line = gitgutter#hunk#cursor_in_hunk(hunk_info)
                            
                                  if a:0 && hunk_index != a:1
                                    let keep_line = 0
                                  endif
                            
                                  let hunk_index += 1
                                endif
                                if keep_line
                                  call add(modified_diff, line)
                                endif
                              endfor
                              return join(modified_diff, "\n")."\n"
                            endfunction
                            
                            
    1              0.000002 function! s:write_buffer(bufnr, file)
                              let bufcontents = getbufline(a:bufnr, 1, '$')
                            
                              if bufcontents == [''] && line2byte(1) == -1
                                " Special case: completely empty buffer.
                                " A nearly empty buffer of only a newline has line2byte(1) == 1.
                                call writefile([], a:file)
                                return
                              endif
                            
                              if getbufvar(a:bufnr, '&fileformat') ==# 'dos'
                                call map(bufcontents, 'v:val."\r"')
                              endif
                            
                              if getbufvar(a:bufnr, '&endofline')
                                call add(bufcontents, '')
                              endif
                            
                              let fenc = getbufvar(a:bufnr, '&fileencoding')
                              if fenc !=# &encoding
                                call map(bufcontents, 'iconv(v:val, &encoding, "'.fenc.'")')
                              endif
                            
                              if getbufvar(a:bufnr, '&bomb')
                                let bufcontents[0]=''.bufcontents[0]
                              endif
                            
                              call writefile(bufcontents, a:file, 'b')
                            endfunction
                            
                            
    1              0.000002 function! s:save_last_seen_change(bufnr) abort
                              call gitgutter#utility#setbufvar(a:bufnr, 'tick', getbufvar(a:bufnr, 'changedtick'))
                            endfunction

SCRIPT  /Users/robertyang/Repos/Configs/Neovim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/sign.vim
Sourced 1 time
Total time:   0.000552
 Self time:   0.000552

count  total (s)   self (s)
                            " For older Vims without sign_place() the plugin has to manaage the sign ids.
    1              0.000023 let s:first_sign_id = 3000
    1              0.000010 let s:next_sign_id  = s:first_sign_id
                            " Remove-all-signs optimisation requires Vim 7.3.596+.
    1              0.000015 let s:supports_star = v:version > 703 || (v:version == 703 && has("patch596"))
                            
                            
    1              0.000008 function! gitgutter#sign#enable() abort
                              let old_signs = g:gitgutter_signs
                            
                              let g:gitgutter_signs = 1
                              call gitgutter#highlight#define_sign_text_highlights()
                            
                              if !old_signs && !g:gitgutter_highlight_lines && !g:gitgutter_highlight_linenrs
                                call gitgutter#all(1)
                              endif
                            endfunction
                            
    1              0.000004 function! gitgutter#sign#disable() abort
                              let g:gitgutter_signs = 0
                              call gitgutter#highlight#define_sign_text_highlights()
                            
                              if !g:gitgutter_highlight_lines && !g:gitgutter_highlight_linenrs
                                call gitgutter#sign#clear_signs(bufnr(''))
                              endif
                            endfunction
                            
    1              0.000004 function! gitgutter#sign#toggle() abort
                              if g:gitgutter_signs
                                call gitgutter#sign#disable()
                              else
                                call gitgutter#sign#enable()
                              endif
                            endfunction
                            
                            
                            " Removes gitgutter's signs from the buffer being processed.
    1              0.000004 function! gitgutter#sign#clear_signs(bufnr) abort
                              if exists('*sign_unplace')
                                call sign_unplace('gitgutter', {'buffer': a:bufnr})
                                return
                              endif
                            
                            
                              call s:find_current_signs(a:bufnr)
                            
                              let sign_ids = map(values(gitgutter#utility#getbufvar(a:bufnr, 'gitgutter_signs')), 'v:val.id')
                              call s:remove_signs(a:bufnr, sign_ids, 1)
                              call gitgutter#utility#setbufvar(a:bufnr, 'gitgutter_signs', {})
                            endfunction
                            
                            
                            " Updates gitgutter's signs in the buffer being processed.
                            "
                            " modified_lines: list of [<line_number (number)>, <name (string)>]
                            " where name = 'added|removed|modified|modified_removed'
    1              0.000004 function! gitgutter#sign#update_signs(bufnr, modified_lines) abort
                              if exists('*sign_unplace')
                                " Vim is (hopefully) now quick enough to remove all signs then place new ones.
                                call sign_unplace('gitgutter', {'buffer': a:bufnr})
                            
                                let modified_lines = s:handle_double_hunk(a:modified_lines)
                                let signs = map(copy(modified_lines), '{'.
                                      \ '"buffer":   a:bufnr,'.
                                      \ '"group":    "gitgutter",'.
                                      \ '"name":     s:highlight_name_for_change(v:val[1]),'.
                                      \ '"lnum":     v:val[0],'.
                                      \ '"priority": g:gitgutter_sign_priority'.
                                      \ '}')
                            
                                if exists('*sign_placelist')
                                  call sign_placelist(signs)
                                  return
                                endif
                            
                                for sign in signs
                                  call sign_place(0, sign.group, sign.name, sign.buffer, {'lnum': sign.lnum, 'priority': sign.priority})
                                endfor
                                return
                              endif
                            
                            
                              " Derive a delta between the current signs and the ones we want.
                              " Remove signs from lines that no longer need a sign.
                              " Upsert the remaining signs.
                            
                              call s:find_current_signs(a:bufnr)
                            
                              let new_gitgutter_signs_line_numbers = map(copy(a:modified_lines), 'v:val[0]')
                              let obsolete_signs = s:obsolete_gitgutter_signs_to_remove(a:bufnr, new_gitgutter_signs_line_numbers)
                            
                              call s:remove_signs(a:bufnr, obsolete_signs, s:remove_all_old_signs)
                              call s:upsert_new_gitgutter_signs(a:bufnr, a:modified_lines)
                            endfunction
                            
                            
                            "
                            " Internal functions
                            "
                            
                            
    1              0.000009 function! s:find_current_signs(bufnr) abort
                              let gitgutter_signs = {}  " <line_number (string)>: {'id': <id (number)>, 'name': <name (string)>}
                              if !g:gitgutter_sign_allow_clobber
                                let other_signs = []      " [<line_number (number),...]
                              endif
                            
                              if exists('*getbufinfo')
                                let bufinfo = getbufinfo(a:bufnr)[0]
                                let signs = has_key(bufinfo, 'signs') ? bufinfo.signs : []
                              else
                                let signs = []
                            
                                redir => signlines
                                  silent execute "sign place buffer=" . a:bufnr
                                redir END
                            
                                for signline in filter(split(signlines, '\n')[2:], 'v:val =~# "="')
                                  " Typical sign line before v8.1.0614:  line=88 id=1234 name=GitGutterLineAdded
                                  " We assume splitting is faster than a regexp.
                                  let components = split(signline)
                                  call add(signs, {
                                        \ 'lnum': str2nr(split(components[0], '=')[1]),
                                        \ 'id':   str2nr(split(components[1], '=')[1]),
                                        \ 'name':        split(components[2], '=')[1]
                                        \ })
                                endfor
                              endif
                            
                              for sign in signs
                                if sign.name =~# 'GitGutter'
                                  " Remove orphaned signs (signs placed on lines which have been deleted).
                                  " (When a line is deleted its sign lingers.  Subsequent lines' signs'
                                  " line numbers are decremented appropriately.)
                                  if has_key(gitgutter_signs, sign.lnum)
                                    execute "sign unplace" gitgutter_signs[sign.lnum].id
                                  endif
                                  let gitgutter_signs[sign.lnum] = {'id': sign.id, 'name': sign.name}
                                else
                                  if !g:gitgutter_sign_allow_clobber
                                    call add(other_signs, sign.lnum)
                                  endif
                                endif
                              endfor
                            
                              call gitgutter#utility#setbufvar(a:bufnr, 'gitgutter_signs', gitgutter_signs)
                              if !g:gitgutter_sign_allow_clobber
                                call gitgutter#utility#setbufvar(a:bufnr, 'other_signs', other_signs)
                              endif
                            endfunction
                            
                            
                            " Returns a list of [<id (number)>, ...]
                            " Sets `s:remove_all_old_signs` as a side-effect.
    1              0.000007 function! s:obsolete_gitgutter_signs_to_remove(bufnr, new_gitgutter_signs_line_numbers) abort
                              let signs_to_remove = []  " list of [<id (number)>, ...]
                              let remove_all_signs = 1
                              let old_gitgutter_signs = gitgutter#utility#getbufvar(a:bufnr, 'gitgutter_signs')
                              for line_number in keys(old_gitgutter_signs)
                                if index(a:new_gitgutter_signs_line_numbers, str2nr(line_number)) == -1
                                  call add(signs_to_remove, old_gitgutter_signs[line_number].id)
                                else
                                  let remove_all_signs = 0
                                endif
                              endfor
                              let s:remove_all_old_signs = remove_all_signs
                              return signs_to_remove
                            endfunction
                            
                            
    1              0.000005 function! s:remove_signs(bufnr, sign_ids, all_signs) abort
                              if a:all_signs && s:supports_star && (g:gitgutter_sign_allow_clobber || empty(gitgutter#utility#getbufvar(a:bufnr, 'other_signs')))
                                execute "sign unplace * buffer=" . a:bufnr
                              else
                                for id in a:sign_ids
                                  execute "sign unplace" id
                                endfor
                              endif
                            endfunction
                            
                            
    1              0.000005 function! s:upsert_new_gitgutter_signs(bufnr, modified_lines) abort
                              if !g:gitgutter_sign_allow_clobber
                                let other_signs = gitgutter#utility#getbufvar(a:bufnr, 'other_signs')
                              endif
                              let old_gitgutter_signs = gitgutter#utility#getbufvar(a:bufnr, 'gitgutter_signs')
                            
                              let modified_lines = s:handle_double_hunk(a:modified_lines)
                            
                              for line in modified_lines
                                let line_number = line[0]  " <number>
                                if g:gitgutter_sign_allow_clobber || index(other_signs, line_number) == -1  " don't clobber others' signs
                                  let name = s:highlight_name_for_change(line[1])
                                  if !has_key(old_gitgutter_signs, line_number)  " insert
                                    let id = s:next_sign_id()
                                    execute "sign place" id "line=" . line_number "name=" . name "buffer=" . a:bufnr
                                  else  " update if sign has changed
                                    let old_sign = old_gitgutter_signs[line_number]
                                    if old_sign.name !=# name
                                      execute "sign place" old_sign.id "name=" . name "buffer=" . a:bufnr
                                    end
                                  endif
                                endif
                              endfor
                              " At this point b:gitgutter_gitgutter_signs is out of date.
                            endfunction
                            
                            
                            " Handle special case where the first line is the site of two hunks:
                            " lines deleted above at the start of the file, and lines deleted
                            " immediately below.
    1              0.000005 function! s:handle_double_hunk(modified_lines)
                              if a:modified_lines[0:1] == [[1, 'removed_first_line'], [1, 'removed']]
                                return [[1, 'removed_above_and_below']] + a:modified_lines[2:]
                              endif
                            
                              return a:modified_lines
                            endfunction
                            
                            
    1              0.000004 function! s:next_sign_id() abort
                              let next_id = s:next_sign_id
                              let s:next_sign_id += 1
                              return next_id
                            endfunction
                            
                            
                            " Only for testing.
    1              0.000003 function! gitgutter#sign#reset()
                              let s:next_sign_id  = s:first_sign_id
                            endfunction
                            
                            
    1              0.000004 function! s:highlight_name_for_change(text) abort
                              if a:text ==# 'added'
                                return 'GitGutterLineAdded'
                              elseif a:text ==# 'removed'
                                return 'GitGutterLineRemoved'
                              elseif a:text ==# 'removed_first_line'
                                return 'GitGutterLineRemovedFirstLine'
                              elseif a:text ==# 'modified'
                                return 'GitGutterLineModified'
                              elseif a:text ==# 'modified_removed'
                                return 'GitGutterLineModifiedRemoved'
                              elseif a:text ==# 'removed_above_and_below'
                                return 'GitGutterLineRemovedAboveAndBelow'
                              endif
                            endfunction
                            
                            

SCRIPT  /Users/robertyang/Repos/Configs/Neovim/.config/coc/extensions/node_modules/coc-fzf-preview/autoload/fzf_preview/remote/handler_to_process.vim
Sourced 1 time
Total time:   0.000119
 Self time:   0.000119

count  total (s)   self (s)
    1              0.000021 function! fzf_preview#remote#handler_to_process#call_funcref_or_fallback_default_process(env, default_process_function_name, expect_key, lines, process_name) abort
                              if a:env ==# 'remote'
                                call s:call_remote_plugin(a:default_process_function_name, a:expect_key, a:lines, a:process_name)
                              elseif a:env ==# 'coc'
                                call s:call_coc(a:default_process_function_name, a:expect_key, a:lines, a:process_name)
                              endif
                            endfunction
                            
    1              0.000010 function! s:call_remote_plugin(default_process_function_name, expect_key, lines, process_name) abort
                              if (a:process_name == v:null)
                                call call(a:default_process_function_name, [a:lines])
                              else
                                let processes = eval('g:' . a:process_name)
                                let Process = processes[a:expect_key]
                            
                                if type(Process) == v:t_string
                                  call call(Process, [a:lines])
                                elseif type(Process) == v:t_func
                                  call Process(a:lines)
                                endif
                              endif
                            endfunction
                            
    1              0.000006 function! s:call_coc(default_process_function_name, expect_key, lines, process_name) abort
                              if (a:process_name == v:null)
                                let process_name = substitute(a:default_process_function_name, '^FzfPreview', '', '')
                                call CocAction('runCommand', 'fzf-preview-callback.' . process_name, [a:lines])
                              else
                                let processes = eval('g:' . a:process_name)
                                let Process = processes[a:expect_key]
                            
                                if type(Process) == v:t_string
                                  if exists('*' . Process)
                                    call call(Process, [a:lines])
                                  else
                                    call CocAction('runCommand', 'fzf-preview-callback.' . Process, [a:lines])
                                  endif
                                elseif type(Process) == v:t_func
                                  call Process(a:lines)
                                endif
                              endif
                            endfunction

SCRIPT  /Users/robertyang/Repos/Configs/Neovim/.config/nvim/plugged/vim-smoothie/autoload/smoothie.vim
Sourced 1 time
Total time:   0.000574
 Self time:   0.000574

count  total (s)   self (s)
    1              0.000035 if !exists('g:smoothie_update_interval')
                              ""
                              " Time (in milliseconds) between subseqent screen/cursor postion updates.
                              " Lower value produces smoother animation.  Might be useful to increase it
                              " when running Vim over low-bandwidth/high-latency connections.
    1              0.000024   let g:smoothie_update_interval = 20
    1              0.000004 endif
                            
    1              0.000010 if !exists('g:smoothie_base_speed')
                              ""
                              " Base scrolling speed (in lines per second), to be taken into account by
                              " the velocity calculation algorithm.  Can be decreased to achieve slower
                              " (and easier to follow) animation.
    1              0.000009   let g:smoothie_base_speed = 10
    1              0.000002 endif
                            
    1              0.000009 if !exists('g:smoothie_break_on_reverse')
                              ""
                              " Stop immediately if we're moving and the user requested moving in opposite
                              " direction.  It's mostly useful at very low scrolling speeds, hence
                              " disabled by default.
    1              0.000009   let g:smoothie_break_on_reverse = 0
    1              0.000002 endif
                            
                            ""
                            " Execute {command}, but saving 'scroll' value before, and restoring it
                            " afterwards.  Useful for some commands (such as ^D or ^U), which overwrite
                            " 'scroll' permanently if used with a [count].
    1              0.000013 function s:execute_preserving_scroll(command)
                              let l:saved_scroll = &scroll
                              execute a:command
                              let &scroll = l:saved_scroll
                            endfunction
                            
                            ""
                            " Scroll the window up by one line, or move the cursor up if the window is
                            " already at the top.  Return 1 if cannot move any higher.
    1              0.000005 function s:step_up()
                              if line('.') > 1
                                call s:execute_preserving_scroll("normal! 1\<C-U>")
                                return 0
                              else
                                return 1
                              endif
                            endfunction
                            
                            ""
                            " Scroll the window down by one line, or move the cursor down if the window is
                            " already at the bottom.  Return 1 if cannot move any lower.
    1              0.000004 function s:step_down()
                              if line('.') < line('$')
                                call s:execute_preserving_scroll("normal! 1\<C-D>")
                                return 0
                              else
                                return 1
                              endif
                            endfunction
                            
                            ""
                            " Perform as many steps up or down to move {lines} lines from the starting
                            " position (negative {lines} value means to go up).  Return 1 if hit either
                            " top or bottom, and cannot move further.
    1              0.000005 function s:step_many(lines)
                              let l:remaining_lines = a:lines
                              while 1
                                if l:remaining_lines < 0
                                  if s:step_up()
                                    return 1
                                  endif
                                  let l:remaining_lines += 1
                                elseif l:remaining_lines > 0
                                  if s:step_down()
                                    return 1
                                  endif
                                  let l:remaining_lines -= 1
                                else
                                  return 0
                                endif
                              endwhile
                            endfunction
                            
                            ""
                            " A Number indicating how many lines do we need yet to move down (or up, if
                            " it's negative), to achieve what the user wants.
    1              0.000007 let s:target_displacement = 0
                            
                            ""
                            " A Float between -1.0 and 1.0 keeping our position between integral lines,
                            " used to make the animation smoother.
    1              0.000008 let s:subline_position = 0.0
                            
                            ""
                            " Start the animation timer if not already running.  Should be called when
                            " updating the target, when there's a chance we're not already moving.
    1              0.000004 function s:start_moving()
                              if !exists('s:timer_id')
                                let s:timer_id = timer_start(g:smoothie_update_interval, function("s:movement_tick"), {'repeat': -1})
                              endif
                            endfunction
                            
                            ""
                            " Stop any movement immediately, and disable the animation timer to conserve
                            " power.
    1              0.000004 function s:stop_moving()
                              let s:target_displacement = 0
                              let s:subline_position = 0.0
                              if exists('s:timer_id')
                                call timer_stop(s:timer_id)
                                unlet s:timer_id
                              endif
                            endfunction
                            
                            ""
                            " Calculate optimal movement velocity (in lines per second, negative value
                            " means to move upwards) for the next animation frame.
                            "
                            " TODO: current algorithm is rather crude, would be good to research better
                            " alternatives.
    1              0.000004 function s:compute_velocity()
                              return g:smoothie_base_speed * (s:target_displacement + s:subline_position)
                            endfunction
                            
                            ""
                            " Execute single animation frame.  Called periodically by a timer.  Accepts a
                            " throwaway parameter: the timer ID.
    1              0.000005 function s:movement_tick(_)
                              if s:target_displacement == 0
                                call s:stop_moving()
                                return
                              endif
                            
                              let l:subline_step_size = s:subline_position + (g:smoothie_update_interval/1000.0 * s:compute_velocity())
                              let l:step_size = float2nr(trunc(l:subline_step_size))
                            
                              if abs(l:step_size) > abs(s:target_displacement)
                                " clamp step size to prevent overshooting the target
                                let l:step_size = s:target_displacement
                              end
                            
                              if s:step_many(l:step_size)
                                " we've collided with either buffer end
                                call s:stop_moving()
                              else
                                let s:target_displacement -= l:step_size
                                let s:subline_position = l:subline_step_size - l:step_size
                              endif
                            
                              if l:step_size
                                " Usually Vim handles redraws well on its own, but without explicit redraw
                                " I've encountered some sporadic display artifacts.  TODO: debug further.
                                redraw
                              endif
                            endfunction
                            
                            ""
                            " Set a new target where we should move to (in lines, relative to our current
                            " position).  If we're already moving, try to do the smart thing, taking into
                            " account our progress in reaching the target set previously.
    1              0.000005 function s:update_target(lines)
                              if g:smoothie_break_on_reverse && s:target_displacement * a:lines < 0
                                call s:stop_moving()
                              else
                                let s:target_displacement += a:lines
                                call s:start_moving()
                              endif
                            endfunction
                            
                            ""
                            " Helper function to set 'scroll' to [count], similarly to what native ^U and
                            " ^D commands do.
    1              0.000004 function s:count_to_scroll()
                              if v:count
                                let &scroll=v:count
                              end
                            endfunction
                            
                            ""
                            " Smooth equivalent to ^D.
    1              0.000005 function smoothie#downwards()
                              call s:count_to_scroll()
                              call s:update_target(&scroll)
                            endfunction
                            
                            ""
                            " Smooth equivalent to ^U.
    1              0.000004 function smoothie#upwards()
                              call s:count_to_scroll()
                              call s:update_target(-&scroll)
                            endfunction
                            
                            ""
                            " Smooth equivalent to ^F.
    1              0.000004 function smoothie#forwards()
                              call s:update_target(winheight(0) * v:count1)
                            endfunction
                            
                            ""
                            " Smooth equivalent to ^B.
    1              0.000004 function smoothie#backwards()
                              call s:update_target(-winheight(0) * v:count1)
                            endfunction

SCRIPT  /usr/local/Cellar/neovim/HEAD-40a7427/share/nvim/runtime/scripts.vim
Sourced 1 time
Total time:   0.001835
 Self time:   0.001835

count  total (s)   self (s)
                            " Vim support file to detect file types in scripts
                            "
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last change:	2020 Jun 07
                            
                            " This file is called by an autocommand for every file that has just been
                            " loaded into a buffer.  It checks if the type of file can be recognized by
                            " the file contents.  The autocommand is in $VIMRUNTIME/filetype.vim.
                            "
                            " Note that the pattern matches are done with =~# to avoid the value of the
                            " 'ignorecase' option making a difference.  Where case is to be ignored use
                            " =~? instead.  Do not use =~ anywhere.
                            
                            
                            " Only do the rest when the FileType autocommand has not been triggered yet.
    1              0.000026 if did_filetype()
                              finish
    1              0.000003 endif
                            
                            " Load the user defined scripts file first
                            " Only do this when the FileType autocommand has not been triggered yet
    1              0.000017 if exists("myscriptsfile") && filereadable(expand(myscriptsfile))
                              execute "source " . myscriptsfile
                              if did_filetype()
                                finish
                              endif
    1              0.000002 endif
                            
                            " Line continuation is used here, remove 'C' from 'cpoptions'
    1              0.000021 let s:cpo_save = &cpo
    1              0.000037 set cpo&vim
                            
    1              0.000015 let s:line1 = getline(1)
                            
    1              0.000017 if s:line1 =~# "^#!"
                              " A script that starts with "#!".
                            
                              " Check for a line like "#!/usr/bin/env {options} bash".  Turn it into
                              " "#!/usr/bin/bash" to make matching easier.
                              " Recognize only a few {options} that are commonly used.
                              if s:line1 =~# '^#!\s*\S*\<env\s'
                                let s:line1 = substitute(s:line1, '\S\+=\S\+', '', 'g')
                                let s:line1 = substitute(s:line1, '\(-[iS]\|--ignore-environment\|--split-string\)', '', '')
                                let s:line1 = substitute(s:line1, '\<env\s\+', '', '')
                              endif
                            
                              " Get the program name.
                              " Only accept spaces in PC style paths: "#!c:/program files/perl [args]".
                              " If the word env is used, use the first word after the space:
                              " "#!/usr/bin/env perl [path/args]"
                              " If there is no path use the first word: "#!perl [path/args]".
                              " Otherwise get the last word after a slash: "#!/usr/bin/perl [path/args]".
                              if s:line1 =~# '^#!\s*\a:[/\\]'
                                let s:name = substitute(s:line1, '^#!.*[/\\]\(\i\+\).*', '\1', '')
                              elseif s:line1 =~# '^#!.*\<env\>'
                                let s:name = substitute(s:line1, '^#!.*\<env\>\s\+\(\i\+\).*', '\1', '')
                              elseif s:line1 =~# '^#!\s*[^/\\ ]*\>\([^/\\]\|$\)'
                                let s:name = substitute(s:line1, '^#!\s*\([^/\\ ]*\>\).*', '\1', '')
                              else
                                let s:name = substitute(s:line1, '^#!\s*\S*[/\\]\(\i\+\).*', '\1', '')
                              endif
                            
                              " tcl scripts may have #!/bin/sh in the first line and "exec wish" in the
                              " third line.  Suggested by Steven Atkinson.
                              if getline(3) =~# '^exec wish'
                                let s:name = 'wish'
                              endif
                            
                              " Bourne-like shell scripts: bash bash2 ksh ksh93 sh
                              if s:name =~# '^\(bash\d*\|\|ksh\d*\|sh\)\>'
                                call dist#ft#SetFileTypeSH(s:line1)	" defined in filetype.vim
                            
                                " csh scripts
                              elseif s:name =~# '^csh\>'
                                if exists("g:filetype_csh")
                                  call dist#ft#SetFileTypeShell(g:filetype_csh)
                                else
                                  call dist#ft#SetFileTypeShell("csh")
                                endif
                            
                                " tcsh scripts
                              elseif s:name =~# '^tcsh\>'
                                call dist#ft#SetFileTypeShell("tcsh")
                            
                                " Z shell scripts
                              elseif s:name =~# '^zsh\>'
                                set ft=zsh
                            
                                " TCL scripts
                              elseif s:name =~# '^\(tclsh\|wish\|expectk\|itclsh\|itkwish\)\>'
                                set ft=tcl
                            
                                " Expect scripts
                              elseif s:name =~# '^expect\>'
                                set ft=expect
                            
                                " Gnuplot scripts
                              elseif s:name =~# '^gnuplot\>'
                                set ft=gnuplot
                            
                                " Makefiles
                              elseif s:name =~# 'make\>'
                                set ft=make
                            
                                " Pike
                              elseif s:name =~# '^pike\%(\>\|[0-9]\)'
                                set ft=pike
                            
                                " Lua
                              elseif s:name =~# 'lua'
                                set ft=lua
                            
                                " Perl 6
                              elseif s:name =~# 'perl6'
                                set ft=perl6
                            
                                " Perl
                              elseif s:name =~# 'perl'
                                set ft=perl
                            
                                " PHP
                              elseif s:name =~# 'php'
                                set ft=php
                            
                                " Python
                              elseif s:name =~# 'python'
                                set ft=python
                            
                                " Groovy
                              elseif s:name =~# '^groovy\>'
                                set ft=groovy
                            
                                " Ruby
                              elseif s:name =~# 'ruby'
                                set ft=ruby
                            
                                " JavaScript
                              elseif s:name =~# 'node\(js\)\=\>\|js\>' || s:name =~# 'rhino\>'
                                set ft=javascript
                            
                                " BC calculator
                              elseif s:name =~# '^bc\>'
                                set ft=bc
                            
                                " sed
                              elseif s:name =~# 'sed\>'
                                set ft=sed
                            
                                " OCaml-scripts
                              elseif s:name =~# 'ocaml'
                                set ft=ocaml
                            
                                " Awk scripts
                              elseif s:name =~# 'awk\>'
                                set ft=awk
                            
                                " Website MetaLanguage
                              elseif s:name =~# 'wml'
                                set ft=wml
                            
                                " Scheme scripts
                              elseif s:name =~# 'scheme'
                                set ft=scheme
                            
                                " CFEngine scripts
                              elseif s:name =~# 'cfengine'
                                set ft=cfengine
                            
                                " Erlang scripts
                              elseif s:name =~# 'escript'
                                set ft=erlang
                            
                                " Haskell
                              elseif s:name =~# 'haskell'
                                set ft=haskell
                            
                                " Scala
                              elseif s:name =~# 'scala\>'
                                set ft=scala
                            
                                " Clojure
                              elseif s:name =~# 'clojure'
                                set ft=clojure
                            
                              endif
                              unlet s:name
                            
    1              0.000002 else
                              " File does not start with "#!".
                            
    1              0.000009   let s:line2 = getline(2)
    1              0.000006   let s:line3 = getline(3)
    1              0.000006   let s:line4 = getline(4)
    1              0.000006   let s:line5 = getline(5)
                            
                              " Bourne-like shell scripts: sh ksh bash bash2
    1              0.000010   if s:line1 =~# '^:$'
                                call dist#ft#SetFileTypeSH(s:line1)	" defined in filetype.vim
                            
                              " Z shell scripts
    1              0.000060   elseif s:line1 =~# '^#compdef\>' || s:line1 =~# '^#autoload\>' ||
                                    \ "\n".s:line1."\n".s:line2."\n".s:line3."\n".s:line4."\n".s:line5 =~# '\n\s*emulate\s\+\%(-[LR]\s\+\)\=[ckz]\=sh\>'
                                set ft=zsh
                            
                              " ELM Mail files
    1              0.000035   elseif s:line1 =~# '^From \([a-zA-Z][a-zA-Z_0-9\.=-]*\(@[^ ]*\)\=\|-\) .* \(19\|20\)\d\d$'
                                set ft=mail
                            
                              " Mason
    1              0.000010   elseif s:line1 =~# '^<[%&].*>'
                                set ft=mason
                            
                              " Vim scripts (must have '" vim' as the first line to trigger this)
    1              0.000010   elseif s:line1 =~# '^" *[vV]im$'
                                set ft=vim
                            
                              " libcxx and libstdc++ standard library headers like "iostream" do not have
                              " an extension, recognize the Emacs file mode.
    1              0.000012   elseif s:line1 =~? '-\*-.*C++.*-\*-'
                                set ft=cpp
                            
                              " MOO
    1              0.000026   elseif s:line1 =~# '^\*\* LambdaMOO Database, Format Version \%([1-3]\>\)\@!\d\+ \*\*$'
                                set ft=moo
                            
                                " Diff file:
                                " - "diff" in first line (context diff)
                                " - "Only in " in first line
                                " - "--- " in first line and "+++ " in second line (unified diff).
                                " - "*** " in first line and "--- " in second line (context diff).
                                " - "# It was generated by makepatch " in the second line (makepatch diff).
                                " - "Index: <filename>" in the first line (CVS file)
                                " - "=== ", line of "=", "---", "+++ " (SVK diff)
                                " - "=== ", "--- ", "+++ " (bzr diff, common case)
                                " - "=== (removed|added|renamed|modified)" (bzr diff, alternative)
                                " - "# HG changeset patch" in first line (Mercurial export format)
    1              0.000125   elseif s:line1 =~# '^\(diff\>\|Only in \|\d\+\(,\d\+\)\=[cda]\d\+\>\|# It was generated by makepatch \|Index:\s\+\f\+\r\=$\|===== \f\+ \d\+\.\d\+ vs edited\|==== //\f\+#\d\+\|# HG changeset patch\)'
                            	\ || (s:line1 =~# '^--- ' && s:line2 =~# '^+++ ')
                            	\ || (s:line1 =~# '^\* looking for ' && s:line2 =~# '^\* comparing to ')
                            	\ || (s:line1 =~# '^\*\*\* ' && s:line2 =~# '^--- ')
                            	\ || (s:line1 =~# '^=== ' && ((s:line2 =~# '^=\{66\}' && s:line3 =~# '^--- ' && s:line4 =~# '^+++') || (s:line2 =~# '^--- ' && s:line3 =~# '^+++ ')))
                            	\ || (s:line1 =~# '^=== \(removed\|added\|renamed\|modified\)')
                                set ft=diff
                            
                                " PostScript Files (must have %!PS as the first line, like a2ps output)
    1              0.000010   elseif s:line1 =~# '^%![ \t]*PS'
                                set ft=postscr
                            
                                " M4 scripts: Guess there is a line that starts with "dnl".
    1              0.000034   elseif s:line1 =~# '^\s*dnl\>'
                            	\ || s:line2 =~# '^\s*dnl\>'
                            	\ || s:line3 =~# '^\s*dnl\>'
                            	\ || s:line4 =~# '^\s*dnl\>'
                            	\ || s:line5 =~# '^\s*dnl\>'
                                set ft=m4
                            
                                " AmigaDos scripts
    1              0.000012   elseif $TERM == "amiga"
                            	\ && (s:line1 =~# "^;" || s:line1 =~? '^\.bra')
                                set ft=amiga
                            
                                " SiCAD scripts (must have procn or procd as the first line to trigger this)
    1              0.000012   elseif s:line1 =~? '^ *proc[nd] *$'
                                set ft=sicad
                            
                                " Purify log files start with "****  Purify"
    1              0.000010   elseif s:line1 =~# '^\*\*\*\*  Purify'
                                set ft=purifylog
                            
                                " XML
    1              0.000011   elseif s:line1 =~# '<?\s*xml.*?>'
                                set ft=xml
                            
                                " XHTML (e.g.: PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN")
    1              0.000011   elseif s:line1 =~# '\<DTD\s\+XHTML\s'
                                set ft=xhtml
                            
                                " HTML (e.g.: <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN")
                                " Avoid "doctype html", used by slim.
    1              0.000011   elseif s:line1 =~? '<!DOCTYPE\s\+html\>'
                                set ft=html
                            
                                " PDF
    1              0.000008   elseif s:line1 =~# '^%PDF-'
                                set ft=pdf
                            
                                " XXD output
    1              0.000022   elseif s:line1 =~# '^\x\{7}: \x\{2} \=\x\{2} \=\x\{2} \=\x\{2} '
                                set ft=xxd
                            
                                " RCS/CVS log output
    1              0.000015   elseif s:line1 =~# '^RCS file:' || s:line2 =~# '^RCS file:'
                                set ft=rcslog
                            
                                " CVS commit
    1              0.000016   elseif s:line2 =~# '^CVS:' || getline("$") =~# '^CVS: '
                                set ft=cvs
                            
                                " Prescribe
    1              0.000007   elseif s:line1 =~# '^!R!'
                                set ft=prescribe
                            
                                " Send-pr
    1              0.000008   elseif s:line1 =~# '^SEND-PR:'
                                set ft=sendpr
                            
                                " SNNS files
    1              0.000013   elseif s:line1 =~# '^SNNS network definition file'
                                set ft=snnsnet
    1              0.000013   elseif s:line1 =~# '^SNNS pattern definition file'
                                set ft=snnspat
    1              0.000010   elseif s:line1 =~# '^SNNS result file'
                                set ft=snnsres
                            
                                " Virata
    1              0.000043   elseif s:line1 =~# '^%.\{-}[Vv]irata'
                            	\ || s:line2 =~# '^%.\{-}[Vv]irata'
                            	\ || s:line3 =~# '^%.\{-}[Vv]irata'
                            	\ || s:line4 =~# '^%.\{-}[Vv]irata'
                            	\ || s:line5 =~# '^%.\{-}[Vv]irata'
                                set ft=virata
                            
                                " Strace
    1              0.000020   elseif s:line1 =~# '[0-9:.]* *execve(' || s:line1 =~# '^__libc_start_main'
                                set ft=strace
                            
                                " VSE JCL
    1              0.000016   elseif s:line1 =~# '^\* $$ JOB\>' || s:line1 =~# '^// *JOB\>'
                                set ft=vsejcl
                            
                                " TAK and SINDA
    1              0.000016   elseif s:line4 =~# 'K & K  Associates' || s:line2 =~# 'TAK 2000'
                                set ft=takout
    1              0.000014   elseif s:line3 =~# 'S Y S T E M S   I M P R O V E D '
                                set ft=sindaout
    1              0.000011   elseif getline(6) =~# 'Run Date: '
                                set ft=takcmp
    1              0.000011   elseif getline(9) =~# 'Node    File  1'
                                set ft=sindacmp
                            
                                " DNS zone files
    1              0.000030   elseif s:line1.s:line2.s:line3.s:line4 =~# '^; <<>> DiG [0-9.]\+.* <<>>\|$ORIGIN\|$TTL\|IN\s\+SOA'
                                set ft=bindzone
                            
                                " BAAN
    1              0.000018   elseif s:line1 =~# '|\*\{1,80}' && s:line2 =~# 'VRC '
                            	\ || s:line2 =~# '|\*\{1,80}' && s:line3 =~# 'VRC '
                                set ft=baan
                            
                              " Valgrind
    1              0.000020   elseif s:line1 =~# '^==\d\+== valgrind' || s:line3 =~# '^==\d\+== Using valgrind'
                                set ft=valgrind
                            
                              " Go docs
    1              0.000012   elseif s:line1 =~# '^PACKAGE DOCUMENTATION$'
                                set ft=godoc
                            
                              " Renderman Interface Bytestream
    1              0.000009   elseif s:line1 =~# '^##RenderMan'
                                set ft=rib
                            
                              " Scheme scripts
    1              0.000017   elseif s:line1 =~# 'exec\s\+\S*scheme' || s:line2 =~# 'exec\s\+\S*scheme'
                                set ft=scheme
                            
                              " Git output
    1              0.000024   elseif s:line1 =~# '^\(commit\|tree\|object\) \x\{40\}\>\|^tag \S\+$'
                                set ft=git
                            
                               " Gprof (gnu profiler)
    1              0.000010    elseif s:line1 == 'Flat profile:'
                                 \ && s:line2 == ''
                                 \ && s:line3 =~# '^Each sample counts as .* seconds.$'
                                 set ft=gprof
                            
                              " Erlang terms
                              " (See also: http://www.gnu.org/software/emacs/manual/html_node/emacs/Choosing-Modes.html#Choosing-Modes)
    1              0.000012   elseif s:line1 =~? '-\*-.*erlang.*-\*-'
                                set ft=erlang
                            
                              " YAML
    1              0.000007   elseif s:line1 =~# '^%YAML'
                                set ft=yaml
                            
                              " CVS diff
    1              0.000002   else
    1              0.000006     let s:lnum = 1
    1              0.000015     while getline(s:lnum) =~# "^? " && s:lnum < line("$")
                                  let s:lnum += 1
    1              0.000005     endwhile
    1              0.000014     if getline(s:lnum) =~# '^Index:\s\+\f\+$'
                                  set ft=diff
                            
                                  " locale input files: Formal Definitions of Cultural Conventions
                                  " filename must be like en_US, fr_FR@euro or en_US.UTF-8
    1              0.000042     elseif expand("%") =~# '\a\a_\a\a\($\|[.@]\)\|i18n$\|POSIX$\|translit_'
                                  let s:lnum = 1
                                  while s:lnum < 100 && s:lnum < line("$")
                            	if getline(s:lnum) =~# '^LC_\(IDENTIFICATION\|CTYPE\|COLLATE\|MONETARY\|NUMERIC\|TIME\|MESSAGES\|PAPER\|TELEPHONE\|MEASUREMENT\|NAME\|ADDRESS\)$'
                            	  setf fdcc
                            	  break
                            	endif
                            	let s:lnum += 1
                                  endwhile
    1              0.000002     endif
    1              0.000005     unlet s:lnum
                            
    1              0.000002   endif
                            
    1              0.000006   unlet s:line2 s:line3 s:line4 s:line5
                            
    1              0.000002 endif
                            
                            " Restore 'cpoptions'
    1              0.000021 let &cpo = s:cpo_save
                            
    1              0.000011 unlet s:cpo_save s:line1

FUNCTION  FugitiveExtractGitDir()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-fugitive/plugin/fugitive.vim:215
Called 7 times
Total time:   0.007683
 Self time:   0.005045

count  total (s)   self (s)
    7   0.000186   0.000082   let path = s:Slash(a:path)
    7              0.000057   if path =~# '^fugitive:'
                                return matchstr(path, '\C^fugitive:\%(//\)\=\zs.\{-\}\ze\%(//\|::\|$\)')
    7              0.000026   elseif empty(path)
                                return ''
    7              0.000088   elseif isdirectory(path)
                                let path = fnamemodify(path, ':p:s?/$??')
    7              0.000008   else
    7              0.000153     let path = fnamemodify(path, ':p:h:s?/$??')
    7              0.000010   endif
    7              0.000113   let pre = substitute(matchstr(path, '^\a\a\+\ze:'), '^.', '\u&', '')
    7              0.000043   if len(pre) && exists('*' . pre . 'Real')
                                let path = s:Slash({pre}Real(path))
    7              0.000007   endif
    7              0.000324   let root = resolve(path)
    7              0.000030   if root !=# path
                                silent! exe (haslocaldir() ? 'lcd' : exists(':tcd') && haslocaldir(-1) ? 'tcd' : 'cd') '.'
    7              0.000007   endif
    7              0.000019   let previous = ""
    7              0.000127   let env_git_dir = len($GIT_DIR) ? s:Slash(simplify(fnamemodify(FugitiveVimPath($GIT_DIR), ':p:s?[\/]$??'))) : ''
    7   0.000282   0.000130   call s:Tree(env_git_dir)
   28              0.000098   while root !=# previous
   28              0.000234     if root =~# '\v^//%([^/]+/?)?$'
                                  break
   28              0.000021     endif
   28   0.001603   0.000367     if index(s:CeilingDirectories(), root) >= 0
                                  break
   28              0.000021     endif
   28              0.000220     if root ==# $GIT_WORK_TREE && FugitiveIsGitDir(env_git_dir)
                                  return env_git_dir
   28              0.000147     elseif has_key(s:dir_for_worktree, root)
                                  return s:dir_for_worktree[root]
   28              0.000023     endif
   28              0.000377     let dir = substitute(root, '[\/]$', '', '') . '/.git'
   28              0.000333     let type = getftype(dir)
   28   0.000645   0.000172     if type ==# 'dir' && FugitiveIsGitDir(dir)
    7              0.000018       return dir
   21              0.000073     elseif type ==# 'link' && FugitiveIsGitDir(dir)
                                  return resolve(dir)
   21              0.000078     elseif type !=# '' && filereadable(dir)
                                  let line = get(readfile(dir, '', 1), 0, '')
                                  let file_dir = s:Slash(FugitiveVimPath(matchstr(line, '^gitdir: \zs.*')))
                                  if file_dir !~# '^/\|^\a:' && FugitiveIsGitDir(root . '/' . file_dir)
                                    return simplify(root . '/' . file_dir)
                                  elseif len(file_dir) && FugitiveIsGitDir(file_dir)
                                    return file_dir
                                  endif
   21   0.000901   0.000228     elseif FugitiveIsGitDir(root)
                                  return root
   21              0.000018     endif
   21              0.000075     let previous = root
   21              0.000134     let root = fnamemodify(root, ':h')
   21              0.000031   endwhile
                              return ''

FUNCTION  <SNR>133_ModifierFlags()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/autoload/airline/extensions/fugitiveline.vim:11
Called 1275 times
Total time:   0.012466
 Self time:   0.012466

count  total (s)   self (s)
 1275              0.011036   return (exists("+autochdir") && &autochdir) ? ':p' : ':.'

FUNCTION  lens#get_target_width()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/lens.vim/plugin/lens.vim:110
Called 13 times
Total time:   0.003893
 Self time:   0.000338

count  total (s)   self (s)
   13   0.003878   0.000323   return lens#get_cols() + (wincol() - virtcol('.'))

FUNCTION  airline#extensions#quickfix#inactive_qf_window()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/autoload/airline/extensions/quickfix.vim:28
Called 21 times
Total time:   0.000526
 Self time:   0.000526

count  total (s)   self (s)
   21              0.000386   if getbufvar(a:2.bufnr, '&filetype') is# 'qf' && !empty(airline#util#getwinvar(a:2.winnr, 'quickfix_title', ''))
                                call setwinvar(a:2.winnr, 'airline_section_c', '[%{get(w:, "quickfix_title", "")}] %f %m')
   21              0.000022   endif

FUNCTION  animate#window_delta()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/animate.vim/plugin/animate.vim:49
Called 13 times
Total time:   0.005241
 Self time:   0.001729

count  total (s)   self (s)
   13              0.000062   let target_window = winnr()
                            
                              " If the window is already animating then we are receiving another animation
                              " request, stop the original timer first
   13   0.000205   0.000094   if animate#window_is_animating(target_window)
                                call timer_stop(get(g:animate#timer_ids, target_window, 0))
                                let g:animate#timer_ids[target_window] = 0
   13              0.000012   endif
                            
                              " Store state so that we can access it in the step function
   13   0.000421   0.000248   let animation = { 'width_initial': winwidth(0), 'height_initial': winheight(0), 'width_delta': a:width_delta, 'height_delta': a:height_delta, 'start_time': animate#time(), 'target_window': target_window,}
                            
                              " The main animation step function that is called on each interval
   13              0.000048   function! animation.step(timer)
                                " Store the target window so we can preserve the current window
                                let current_window = winnr()
                            
                                " If the current window is different from the target window then we want
                                " to focus the current window
                                if self.target_window != current_window
                                  if ! animate#window_focus(self.target_window)
                                    call timer_stop(get(g:animate#timer_ids, self.target_window, 0))
                                    let g:animate#timer_ids[self.target_window] = 0
                                    return
                                  endif
                                endif
                            
                                " Calculate the time elapsed
                                let elapsed = min([float2nr(g:animate#duration), float2nr(animate#time() - self.start_time)])
                            
                                " Calculate the appropriate width for this amount of elapsed time
                                let width = float2nr(g:Animate#Ease(elapsed, self.width_initial, self.width_delta, g:animate#duration))
                            
                                " Calculate the appropriate height for this amount of elapsed time
                                let height = float2nr(g:Animate#Ease(elapsed, self.height_initial, self.height_delta, g:animate#duration))
                            
                                " Store old winfix states
                                let winfixheight = &winfixheight
                                let winfixwidth = &winfixwidth
                            
                                " Store old fixity states
                                let nowinfixheights = {}
                                let nowinfixwidths = {}
                            
                                " Perform the animation if the heights are different
                                if height != winheight(0)
                                  " Perform the resize
                                  execute 'resize ' . string(height)
                            
                                  " Distribute space and clean up our changes to windows
                                  if g:animate#distribute_space
                                    " Store the widths
                                    noautocmd silent! windo if ! &winfixwidth | let nowinfixwidths[winnr()] = 1 | set winfixwidth | endif
                                    " Restore focus
                                    call animate#window_focus(self.target_window)
                                    if winfixheight
                                      noautocmd wincmd =
                                    else
                                      set winfixheight
                                      noautocmd wincmd =
                                      set nowinfixheight
                                    endif
                                    " Restore the widths
                                    noautocmd silent! windo if has_key(nowinfixwidths, winnr()) | set nowinfixwidth | endif
                                   
                                    " Restore focus
                                    call animate#window_focus(self.target_window)
                                  endif
                                endif
                            
                                " Perform the animation if the widths are different
                                if width != winwidth(0)
                                  " Perform the resize
                                  execute 'vertical resize ' . string(width)
                            
                                  " Distribute space and clean up our changes to windows
                                  if g:animate#distribute_space
                                    " Store the heights
                                    noautocmd windo if ! &winfixheight | let nowinfixheights[winnr()] = 1 | set winfixheight | endif
                                    " Restore focus
                                    call animate#window_focus(self.target_window)
                                    if winfixwidth
                                      wincmd =
                                    else
                                      set winfixwidth
                                      noautocmd wincmd =
                                      set nowinfixwidth
                                    endif
                                    " Restore the heights
                                    noautocmd windo if has_key(nowinfixheights, winnr()) | set nowinfixheight | endif
                                    " Restore focus
                                    call animate#window_focus(self.target_window)
                                  endif
                                endif
                            
                                " If the time elapsed is less than the animation duration then schedule
                                " anoanother step, otherwise remove the timer id
                                if elapsed < g:animate#duration
                                  let g:animate#timer_ids[self.target_window] = timer_start(16, self.step)
                                else
                                  let g:animate#timer_ids[self.target_window] = 0
                                endif
                              endfunction
                            
                              " Run the first step
   13   0.003375   0.000147   call animation.step(0)

FUNCTION  fzf_preview#remote#mr#mru_file_path()
    Defined: ~/Repos/Configs/Neovim/.config/coc/extensions/node_modules/coc-fzf-preview/autoload/fzf_preview/remote/mr.vim:8
Called 28 times
Total time:   0.002563
 Self time:   0.002563

count  total (s)   self (s)
   28              0.002455   return g:fzf_preview_cache_directory . '/mru'

FUNCTION  coc#client#get_channel()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/coc.nvim/autoload/coc/client.vim:141
Called 832 times
Total time:   0.018711
 Self time:   0.018711

count  total (s)   self (s)
  832              0.007178   if s:is_vim
                                return a:client['channel']
  832              0.001291   endif
  832              0.004580   return a:client['chan_id']

FUNCTION  8()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:120
Called 5 times
Total time:   0.215993
 Self time:   0.000513

count  total (s)   self (s)
    5   0.003241   0.000091   let path = s:strip_trailing_new_line(a:path)
    5   0.000274   0.000084   call gitgutter#utility#setbufvar(a:buffer, 'path', path)
                            
    5              0.000060   if type(self.continuation) == type(function('tr'))
    5   0.212304   0.000164     call self.continuation()
                              else
                                call call(self.continuation.function, self.continuation.arguments)
    5              0.000006   endif

FUNCTION  <SNR>173_untracked_output()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/autoload/airline/async.vim:12
Called 10 times
Total time:   0.012040
 Self time:   0.012040

count  total (s)   self (s)
   10              0.000128   if a:buf =~? ('^'. a:dict.cfg['untracked_mark'])
    1              0.000018     let a:dict.cfg.untracked[a:dict.file] = get(g:, 'airline#extensions#branch#notexists', g:airline_symbols.notexists)
    9              0.000017   else
    9              0.000080     let a:dict.cfg.untracked[a:dict.file] = ''
   10              0.000012   endif

FUNCTION  <SNR>145_open_buffer()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-startify/autoload/startify.vim:525
Called 1 time
Total time:   0.238602
 Self time:   0.018497

count  total (s)   self (s)
    1              0.000007   if a:entry.type == 'special'
                                execute a:entry.cmd
    1              0.000004   elseif a:entry.type == 'session'
                                execute a:entry.cmd a:entry.path
    1              0.000003   elseif a:entry.type == 'file'
    1              0.000039     if line2byte('$') == -1
                                  execute 'edit' a:entry.path
    1              0.000002     else
    1              0.000004       if a:entry.cmd == 'tabnew'
                                    wincmd =
    1              0.000001       endif
    1   0.238386   0.018360       execute a:entry.cmd a:entry.path
    1              0.000002     endif
    1   0.000111   0.000032     call s:check_user_options(a:entry.path)
    1              0.000002   endif
    1              0.000018   if exists('#User#StartifyBufferOpened')
                                doautocmd <nomodeline> User StartifyBufferOpened
    1              0.000001   endif

FUNCTION  airline#util#exec_funcrefs()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/autoload/airline/util.vim:93
Called 57 times
Total time:   0.113495
 Self time:   0.008586

count  total (s)   self (s)
  358              0.000850     for Fn in a:list
  358   0.110605   0.005695       let code = call(Fn, a:000)
  358              0.000679       if code != 0
   57              0.000085         return code
  301              0.000243       endif
  301              0.000272     endfor
                                return 0

FUNCTION  <SNR>48_fzf_getcwd()
    Defined: ~/.fzf/plugin/fzf.vim:102
Called 40 times
Total time:   0.002349
 Self time:   0.000572

count  total (s)   self (s)
   40   0.002311   0.000534   return s:fzf_call('getcwd')

FUNCTION  <SNR>172_RunBufDelete()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-fugitive/autoload/fugitive.vim:2408
Called 1 time
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
    1              0.000005   if has_key(s:edit_jobs, a:bufnr) |
                                call add(s:resume_queue, remove(s:edit_jobs, a:bufnr))
                                call feedkeys(":redraw!|call fugitive#Resume()|silent checktime\r", 'n')
    1              0.000001   endif

FUNCTION  coc#float#valid()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/coc.nvim/autoload/coc/float.vim:216
Called 8 times
Total time:   0.000238
 Self time:   0.000238

count  total (s)   self (s)
    8              0.000042   if a:winid <= 0
                                return 0
    8              0.000010   endif
    8              0.000054   if has('nvim')
    8              0.000078     return nvim_win_is_valid(a:winid) ? 1 : 0
                              endif
                              return s:popup_visible(a:winid)

FUNCTION  animate#time()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/animate.vim/plugin/animate.vim:268
Called 106 times
Total time:   0.002541
 Self time:   0.002541

count  total (s)   self (s)
  106              0.002324   return str2float(reltimestr(reltime())) * 1000.0

FUNCTION  gitgutter#process_buffer()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter.vim:21
Called 121 times
Total time:   0.607901
 Self time:   0.079094

count  total (s)   self (s)
                              " NOTE a:bufnr is not necessarily the current buffer.
                            
  121   0.092301   0.001832   if gitgutter#utility#is_active(a:bufnr)
                            
  102              0.001190     if has('patch-7.4.1559')
  102              0.002055       let l:Callback = function('gitgutter#process_buffer', [a:bufnr, a:force])
                                else
                                  let l:Callback = {'function': 'gitgutter#process_buffer', 'arguments': [a:bufnr, a:force]}
  102              0.000177     endif
  102   0.156385   0.002434     let how = s:setup_path(a:bufnr, l:Callback)
  102              0.001039     if [how] == ['async']  " avoid string-to-number conversion if how is a number
   17              0.000052       return
   85              0.000135     endif
                            
   85   0.007933   0.001362     if a:force || s:has_fresh_changes(a:bufnr)
                            
   26              0.000101       let diff = 'NOT SET'
   26              0.000052       try
   26   0.335925   0.058110         let diff = gitgutter#diff#run_diff(a:bufnr, g:gitgutter_diff_relative_to, 0)
                                  catch /gitgutter not tracked/
                                    call gitgutter#debug#log('Not tracked: '.gitgutter#utility#file(a:bufnr))
                                  catch /gitgutter diff failed/
                                    call gitgutter#debug#log('Diff failed: '.gitgutter#utility#file(a:bufnr))
                                    call gitgutter#hunk#reset(a:bufnr)
   26              0.000069       endtry
                            
   26              0.000216       if diff != 'async' && diff != 'NOT SET'
                                    call gitgutter#diff#handler(a:bufnr, diff)
   26              0.000049       endif
                            
   85              0.000118     endif
  104              0.000143   endif

FUNCTION  <SNR>131_get_hunks_gitgutter()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/autoload/airline/extensions/hunks.vim:60
Called 1263 times
Total time:   0.189689
 Self time:   0.038914

count  total (s)   self (s)
 1263   0.054935   0.018993   if !get(g:, 'gitgutter_enabled', 0) || s:is_branch_empty()
   19              0.000032     return ''
 1244              0.001522   endif
 1244   0.128602   0.013769   return GitGutterGetHunkSummary()

FUNCTION  <SNR>142_get_transitioned_seperator()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/autoload/airline/builder.vim:140
Called 224 times
Total time:   0.293198
 Self time:   0.012546

count  total (s)   self (s)
  224              0.000517   let line = ''
  224              0.001592   if get(a:self._context, 'tabline', 0) && get(g:, 'airline#extensions#tabline#alt_sep', 0) && a:group ==# 'airline_tabsel' && a:side
                                call airline#highlighter#add_separator(a:prev_group, a:group, 0)
                                let line .= '%#'.a:prev_group.'_to_'.a:group.'#'
                                let line .=  a:self._context.right_sep.'%#'.a:group.'#'
  224              0.000188   else
  224   0.283168   0.002517     call airline#highlighter#add_separator(a:prev_group, a:group, a:side)
  224              0.001764     let line .= '%#'.a:prev_group.'_to_'.a:group.'#'
  224              0.001534     let line .= a:side ? a:self._context.left_sep : a:self._context.right_sep
  224              0.000956     let line .= '%#'.a:group.'#'
  224              0.000192   endif
  224              0.000401   return line

FUNCTION  gitgutter#utility#system()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:92
Called 1 time
Total time:   0.045074
 Self time:   0.000146

count  total (s)   self (s)
    1   0.000058   0.000009   call gitgutter#debug#log(a:cmd, a:000)
                            
    1   0.000059   0.000009   call s:use_known_shell()
    1   0.044843   0.000068   silent let output = (a:0 == 0) ? system(a:cmd) : system(a:cmd, a:1)
    1   0.000105   0.000051   call s:restore_shell()
                            
    1              0.000004   return output

FUNCTION  <SNR>160_coc_handler()
    Defined: ~/Repos/Configs/Neovim/.config/coc/extensions/node_modules/coc-fzf-preview/autoload/fzf_preview/remote/runner.vim:27
Called 4 times
Total time:   1.212796
 Self time:   0.000121

count  total (s)   self (s)
    4   1.212790   0.000116   call CocAction('runCommand', 'fzf-preview.HandleResource', [a:lines])

FUNCTION  fzf_preview#remote#util#uniq()
    Defined: ~/Repos/Configs/Neovim/.config/coc/extensions/node_modules/coc-fzf-preview/autoload/fzf_preview/remote/util.vim:72
Called 32 times
Total time:   0.010834
 Self time:   0.010834

count  total (s)   self (s)
   32              0.000173   let result = []
  618              0.001717   for item in a:list
  586              0.003337     if index(result, item) == -1
  559              0.003231       call add(result, item)
  586              0.000662     endif
  618              0.000698   endfor
   32              0.000092   return result

FUNCTION  <SNR>68_set()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-textobj-function-syntax/plugin/textobj/function/syntax.vim:22
Called 7 times
Total time:   0.000097
 Self time:   0.000097

count  total (s)   self (s)
    7              0.000061   if has_key(b:, 'textobj_function_select')
    6              0.000009     return
    1              0.000001   endif
    1              0.000007   let b:textobj_function_select = function('textobj#function#syntax#select')

FUNCTION  fzf#exec()
    Defined: ~/.fzf/plugin/fzf.vim:170
Called 14 times
Total time:   0.113541
 Self time:   0.001215

count  total (s)   self (s)
   14              0.000065   if !exists('s:exec')
    1              0.000038     if executable(s:fzf_go)
    1              0.000003       let s:exec = s:fzf_go
                                elseif executable('fzf')
                                  let s:exec = 'fzf'
                                elseif input('fzf executable not found. Download binary? (y/n) ') =~? '^y'
                                  redraw
                                  call fzf#install()
                                  return fzf#exec()
                                else
                                  redraw
                                  throw 'fzf executable not found'
    1              0.000001     endif
   14              0.000010   endif
                            
   14              0.000077   if a:0 && !has_key(s:checked, a:1)
    1              0.000003     let command = s:exec . ' --version'
    1   0.112304   0.000048     let output = systemlist(command)
    1              0.000012     if v:shell_error || empty(output)
                                  throw printf('Failed to run "%s": %s', command, output)
    1              0.000001     endif
    1              0.000023     let fzf_version = matchstr(output[-1], '[0-9.]\+')
    1   0.000110   0.000040     if s:version_requirement(fzf_version, a:1)
    1              0.000004       let s:checked[a:1] = 1
    1              0.000002       return s:exec
                                elseif a:0 < 2 && input(printf('You need fzf %s or above. Found: %s. Download binary? (y/n) ', a:1, fzf_version)) =~? '^y'
                                  redraw
                                  call fzf#install()
                                  return fzf#exec(a:1, 1)
                                else
                                  throw printf('You need to upgrade fzf (required: %s or above)', a:1)
                                endif
   13              0.000009   endif
                            
   13              0.000025   return s:exec

FUNCTION  <SNR>78_init()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/plugin/airline.vim:15
Called 34 times
Total time:   0.000183
 Self time:   0.000183

count  total (s)   self (s)
   34              0.000084   if s:airline_initialized
   34              0.000044     return
                              endif
                              let s:airline_initialized = 1
                            
                              call airline#extensions#load()
                              call airline#init#sections()
                            
                              let s:theme_in_vimrc = exists('g:airline_theme')
                              if s:theme_in_vimrc
                                try
                                  if g:airline_theme is# 'random'
                                    let g:airline_theme=s:random_theme()
                                  endif
                                  let palette = g:airline#themes#{g:airline_theme}#palette
                                catch
                                  call airline#util#warning(printf('Could not resolve airline theme "%s". Themes have been migrated to github.com/vim-airline/vim-airline-themes.', g:airline_theme))
                                  let g:airline_theme = 'dark'
                                endtry
                                try
                                  silent call airline#switch_theme(g:airline_theme)
                                catch
                                  call airline#util#warning(printf('Could not find airline theme "%s".', g:airline_theme))
                                  let g:airline_theme = 'dark'
                                  silent call airline#switch_theme(g:airline_theme)
                                endtry
                              else
                                let g:airline_theme = 'dark'
                                silent call s:on_colorscheme_changed()
                              endif
                            
                              call airline#util#doautocmd('AirlineAfterInit')

FUNCTION  airline#extensions#coc#get_error()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/autoload/airline/extensions/coc.vim:14
Called 1263 times
Total time:   0.073950
 Self time:   0.013095

count  total (s)   self (s)
 1263   0.072767   0.011912   return airline#extensions#coc#get('error')

FUNCTION  <SNR>169_on_exit_nvim()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/async.vim:72
Called 43 times
Total time:   0.346134
 Self time:   0.001640

count  total (s)   self (s)
   43              0.000299   if !a:exit_code
   31   0.345613   0.001119     call self.handler.out(self.buffer, join(self.stdoutbuffer, "\n"))
   43              0.000058   endif

FUNCTION  <SNR>50_TmuxAwareNavigate()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-tmux-navigator/plugin/tmux_navigator.vim:93
Called 3 times
Total time:   0.121300
 Self time:   0.000445

count  total (s)   self (s)
    3              0.000026   let nr = winnr()
    3              0.000021   let tmux_last_pane = (a:direction == 'p' && s:tmux_is_last_pane)
    3              0.000007   if !tmux_last_pane
    3   0.120844   0.000045     call s:VimNavigate(a:direction)
    3              0.000004   endif
    3              0.000024   let at_tab_page_edge = (nr == winnr())
                              " Forward the switch panes command to tmux if:
                              " a) we're toggling between the last tmux pane;
                              " b) we tried switching windows in vim but it didn't have effect.
    3   0.000169   0.000113   if s:ShouldForwardNavigationBackToTmux(tmux_last_pane, at_tab_page_edge)
                                if g:tmux_navigator_save_on_switch == 1
                                  try
                                    update " save the active buffer. See :help update
                                  catch /^Vim\%((\a\+)\)\=:E32/ " catches the no file name error
                                  endtry
                                elseif g:tmux_navigator_save_on_switch == 2
                                  try
                                    wall " save all the buffers. See :help wall
                                  catch /^Vim\%((\a\+)\)\=:E141/ " catches the no file name error
                                  endtry
                                endif
                                let args = 'select-pane -t ' . shellescape($TMUX_PANE) . ' -' . tr(a:direction, 'phjkl', 'lLDUR')
                                silent call s:TmuxCommand(args)
                                if s:NeedsVitalityRedraw()
                                  redraw!
                                endif
                                let s:tmux_is_last_pane = 1
    3              0.000004   else
    3              0.000012     let s:tmux_is_last_pane = 0
    3              0.000003   endif

FUNCTION  coc#util#do_autocmd()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/coc.nvim/autoload/coc/util.vim:709
Called 34 times
Total time:   0.001384
 Self time:   0.001384

count  total (s)   self (s)
   34              0.000972   if exists('#User#'.a:name)
                                exe 'doautocmd <nomodeline> User '.a:name
   34              0.000065   endif

FUNCTION  <SNR>17_LoadIndent()
    Defined: /usr/local/Cellar/neovim/HEAD-40a7427/share/nvim/runtime/indent.vim:13
Called 13 times
Total time:   0.051566
 Self time:   0.048558

count  total (s)   self (s)
   13              0.000111     if exists("b:undo_indent")
                                  exe b:undo_indent
                                  unlet! b:undo_indent b:did_indent
   13              0.000015     endif
   13              0.000116     let s = expand("<amatch>")
   13              0.000053     if s != ""
   13              0.000056       if exists("b:did_indent")
                            	unlet b:did_indent
   13              0.000014       endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "indent/aaa.vim" and then "indent/bbb.vim".
   26              0.000178       for name in split(s, '\.')
   13   0.050675   0.047667 	exe 'runtime! indent/' . name . '.vim'
   26              0.000068       endfor
   13              0.000017     endif

FUNCTION  airline#check_mode()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/autoload/airline.vim:199
Called 1463 times
Total time:   2.681214
 Self time:   0.511198

count  total (s)   self (s)
 1463              0.013337   if !has_key(s:contexts, a:winnr)
                                return ''
 1463              0.002547   endif
 1463              0.011707   let context = s:contexts[a:winnr]
                            
 1463              0.010497   if get(w:, 'airline_active', 1)
 1449              0.010611     let l:m = mode(1)
 1449              0.006255     if l:m ==# "i"
   54              0.000203       let l:mode = ['insert']
 1395              0.006938     elseif l:m[0] ==# "i"
   15              0.000053       let l:mode = ['insert']
 1380              0.004518     elseif l:m ==# "Rv"
                                  let l:mode =['replace']
 1380              0.005114     elseif l:m[0] ==# "R"
                                  let l:mode = ['replace']
 1380              0.028420     elseif l:m[0] =~# '\v(v|V||s|S|)'
    7              0.000030       let l:mode = ['visual']
 1373              0.004642     elseif l:m ==# "t"
                                  let l:mode = ['terminal']
 1373              0.005553     elseif l:m[0] ==# "c"
   26              0.000115       let l:mode = ['commandline']
 1347              0.006407     elseif l:m ==# "no"   " does not work, most likely, Vim does not refresh the statusline in OP mode
                                  let l:mode = ['normal']
 1347              0.005969     elseif l:m[0:1] ==# 'ni'
                                  let l:mode = ['insert']
                                  let l:m = 'ni'
 1347              0.001990     else
 1347              0.006753       let l:mode = ['normal']
 1449              0.002145     endif
 1449   0.060422   0.033733     if exists("*VMInfos") && !empty(VMInfos())
                                  " Vim plugin Multiple Cursors https://github.com/mg979/vim-visual-multi
                                  let l:m = 'multi'
 1449              0.002353     endif
 1449              0.024937     if index(['Rv', 'no', 'ni', 'ix', 'ic', 'multi'], l:m) == -1
 1434              0.008156       let l:m = l:m[0]
 1449              0.002187     endif
 1449              0.019564     let w:airline_current_mode = get(g:airline_mode_map, l:m, l:m)
   14              0.000017   else
   14              0.000061     let l:mode = ['inactive']
   14              0.000130     let w:airline_current_mode = get(g:airline_mode_map, '__')
 1463              0.002035   endif
                            
 1463              0.012520   if g:airline_detect_modified && &modified
  384              0.003090     call add(l:mode, 'modified')
 1463              0.001861   endif
                            
 1463              0.006527   if g:airline_detect_paste && &paste
                                call add(l:mode, 'paste')
 1463              0.001784   endif
                            
 1463              0.024036   if g:airline_detect_crypt && exists("+key") && !empty(&key)
                                call add(l:mode, 'crypt')
 1463              0.001796   endif
                            
 1463              0.014350   if g:airline_detect_spell && &spell
                                call add(l:mode, 'spell')
 1463              0.001584   endif
                            
 1463              0.006004   if &readonly || ! &modifiable
  188              0.001711     call add(l:mode, 'readonly')
 1463              0.001683   endif
                            
 1463              0.015320   let mode_string = join(l:mode)
 1463              0.014762   if get(w:, 'airline_lastmode', '') != mode_string
   57   0.060332   0.001338     call airline#highlighter#highlight_modified_inactive(context.bufnr)
   57   2.075946   0.002402     call airline#highlighter#highlight(l:mode, context.bufnr)
   57   0.011499   0.000711     call airline#util#doautocmd('AirlineModeChanged')
   57              0.000325     let w:airline_lastmode = mode_string
 1463              0.004604   endif
                            
 1463              0.003708   return ''

FUNCTION  <SNR>144_setup_path()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter.vim:156
Called 102 times
Total time:   0.153952
 Self time:   0.002727

count  total (s)   self (s)
  102   0.022707   0.001726   if gitgutter#utility#has_repo_path(a:bufnr) | return | endif
                            
   17   0.131017   0.000773   return gitgutter#utility#set_repo_path(a:bufnr, a:continuation)

FUNCTION  airline#util#append()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/autoload/airline/util.vim:49
Called 8841 times
Total time:   0.233466
 Self time:   0.233466

count  total (s)   self (s)
 8841              0.054847   if a:minwidth > 0 && airline#util#winwidth() < a:minwidth
                                return ''
 8841              0.009812   endif
 8841              0.069924   let prefix = s:spc == "\ua0" ? s:spc : s:spc.s:spc
 8841              0.065529   return empty(a:text) ? '' : prefix.g:airline_left_alt_sep.s:spc.a:text

FUNCTION  <SNR>175_write_buffer()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:376
Called 26 times
Total time:   0.015993
 Self time:   0.015993

count  total (s)   self (s)
   26              0.001224   let bufcontents = getbufline(a:bufnr, 1, '$')
                            
   26              0.000255   if bufcontents == [''] && line2byte(1) == -1
                                " Special case: completely empty buffer.
                                " A nearly empty buffer of only a newline has line2byte(1) == 1.
                                call writefile([], a:file)
                                return
   26              0.000036   endif
                            
   26              0.000288   if getbufvar(a:bufnr, '&fileformat') ==# 'dos'
                                call map(bufcontents, 'v:val."\r"')
   26              0.000035   endif
                            
   26              0.000180   if getbufvar(a:bufnr, '&endofline')
   26              0.000191     call add(bufcontents, '')
   26              0.000037   endif
                            
   26              0.000212   let fenc = getbufvar(a:bufnr, '&fileencoding')
   26              0.000117   if fenc !=# &encoding
                                call map(bufcontents, 'iconv(v:val, &encoding, "'.fenc.'")')
   26              0.000034   endif
                            
   26              0.000152   if getbufvar(a:bufnr, '&bomb')
                                let bufcontents[0]=''.bufcontents[0]
   26              0.000032   endif
                            
   26              0.012213   call writefile(bufcontents, a:file, 'b')

FUNCTION  animate#ease_in_out_sine()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/animate.vim/plugin/animate.vim:305
Called 186 times
Total time:   0.004216
 Self time:   0.004216

count  total (s)   self (s)
  186              0.001133   let percent = a:elapsed / a:duration
  186              0.000674   let pi = 3.14159265359
  186              0.002010   return a:delta * 0.5 * (1 - cos(pi * percent)) + a:initial

FUNCTION  <SNR>78_on_cursor_moved()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/plugin/airline.vim:91
Called 309 times
Total time:   0.020926
 Self time:   0.013359

count  total (s)   self (s)
  309              0.005276   if winnr() != s:active_winnr || !exists('w:airline_active')
                                call s:on_window_changed('CursorMoved')
  309              0.000535   endif
  309   0.012043   0.004476   call airline#update_tabline()

FUNCTION  <SNR>172_FileIgnoreCase()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-fugitive/autoload/fugitive.vim:120
Called 14 times
Total time:   0.000205
 Self time:   0.000205

count  total (s)   self (s)
   14              0.000186   return (exists('+fileignorecase') && &fileignorecase) || (a:for_completion && exists('+wildignorecase') && &wildignorecase)

FUNCTION  <SNR>52_CursorHoldUpdate()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-devicons/plugin/webdevicons.vim:393
Called 89 times
Total time:   0.003357
 Self time:   0.003357

count  total (s)   self (s)
   89              0.001155   if g:NERDTreeUpdateOnCursorHold != 1 || g:NERDTreeGitStatusUpdateOnCursorHold != 1
                                return
   89              0.000145   endif
                            
   89              0.001146   if !exists('g:NERDTree') || !g:NERDTree.IsOpen()
   89              0.000216     return
                              endif
                            
                              " Do not update when a special buffer is selected
                              if !empty(&l:buftype)
                                return
                              endif
                            
                              " winnr need to make focus go to opened file
                              " CursorToTreeWin needed to avoid error on opening file
                              let l:winnr = winnr()
                              let l:altwinnr = winnr('#')
                            
                              call g:NERDTree.CursorToTreeWin()
                              call b:NERDTree.root.refreshFlags()
                              call NERDTreeRender()
                            
                              exec l:altwinnr . 'wincmd w'
                              exec l:winnr . 'wincmd w'

FUNCTION  <SNR>173_set_clean_variables()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/autoload/airline/async.vim:67
Called 10 times
Total time:   0.002477
 Self time:   0.002477

count  total (s)   self (s)
   10              0.000460   let var=getbufvar(fnameescape(a:file), 'buffer_vcs_config', {})
   10              0.000475   if has_key(var, a:vcs) && has_key(var[a:vcs], 'dirty') && type(getbufvar(fnameescape(a:file), 'buffer_vcs_config')) == type({})
   10              0.000070     let var[a:vcs].dirty=a:val
   10              0.000015     try
   10              0.001274       call setbufvar(fnameescape(a:file), 'buffer_vcs_config', var)
   10              0.000066       unlet! b:airline_head
                                catch
   10              0.000016     endtry
   10              0.000010   endif

FUNCTION  <SNR>172_TempReadPost()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-fugitive/autoload/fugitive.vim:2252
Called 5 times
Total time:   0.000488
 Self time:   0.000217

count  total (s)   self (s)
    5   0.000342   0.000071   if has_key(s:temp_files, s:cpath(a:file))
                                let dict = s:temp_files[s:cpath(a:file)]
                                setlocal nobuflisted
                                if has_key(dict, 'filetype') && dict.filetype !=# &l:filetype
                                  let &l:filetype = dict.filetype
                                endif
                                setlocal foldmarker=<<<<<<<,>>>>>>>
                                if empty(mapcheck('q', 'n'))
                                  nnoremap <buffer> <silent> q    :<C-U>bdelete<Bar>echohl WarningMsg<Bar>echo "Temp file q is deprecated in favor of the built-in <Lt>C-W>q"<Bar>echohl NONE<CR>
                                endif
                                if !&modifiable
                                  call s:Map('n', 'gq', ":<C-U>bdelete<CR>", '<silent> <unique>')
                                endif
    5              0.000004   endif
    5              0.000006   return ''

FUNCTION  airline#util#try_focusgained()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/autoload/airline/util.vim:203
Called 2 times
Total time:   0.003848
 Self time:   0.003848

count  total (s)   self (s)
                              " Ignore lasts for at most one second and is cleared on the first
                              " focusgained. We use ignore to prevent system() calls from triggering
                              " FocusGained (which occurs 100% on win32 and seem to sometimes occur under
                              " tmux).
    2              0.000102   let dt = localtime() - s:focusgained_ignore_time
    2              0.000018   let s:focusgained_ignore_time = 0
    2              0.000009   return dt >= 1

FUNCTION  airline#extensions#branch#update_untracked_config()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/autoload/airline/extensions/branch.vim:183
Called 1128 times
Total time:   0.038011
 Self time:   0.038011

count  total (s)   self (s)
 1128              0.011929   if !has_key(s:vcs_config[a:vcs].untracked, a:file)
    4              0.000011     return
 1124              0.011963   elseif s:vcs_config[a:vcs].untracked[a:file] != b:buffer_vcs_config[a:vcs].untracked
    1              0.000011     let b:buffer_vcs_config[a:vcs].untracked = s:vcs_config[a:vcs].untracked[a:file]
    1              0.000004     unlet! b:airline_head
 1124              0.001193   endif

FUNCTION  <SNR>48_version_requirement()
    Defined: ~/.fzf/plugin/fzf.vim:157
Called 1 time
Total time:   0.000070
 Self time:   0.000070

count  total (s)   self (s)
    1              0.000010   let val = split(a:val, '\.')
    1              0.000007   let min = split(a:min, '\.')
    3              0.000011   for idx in range(0, len(min) - 1)
    3              0.000010     let v = get(val, idx, 0)
    3              0.000010     if     v < min[idx] | return 0
    4              0.000009     elseif v > min[idx] | return 1
    2              0.000001     endif
    2              0.000002   endfor
                              return 1

FUNCTION  <SNR>130_get_array()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/autoload/airline/highlighter.vim:53
Called 4515 times
Total time:   0.074311
 Self time:   0.074311

count  total (s)   self (s)
 4515              0.070772   return [ a:guifg, a:guibg, a:ctermfg, a:ctermbg, empty(a:opts) ? '' : join(a:opts, ',') ]

FUNCTION  airline#themes#get_highlight()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/autoload/airline/themes.vim:31
Called 1816 times
Total time:   0.681588
 Self time:   0.033041

count  total (s)   self (s)
 1816   0.680196   0.031648   return call('airline#highlighter#get_highlight', [a:group] + a:000)

FUNCTION  FugitiveWorkTree()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-fugitive/plugin/fugitive.vim:151
Called 1263 times
Total time:   0.206962
 Self time:   0.028885

count  total (s)   self (s)
 1263   0.205818   0.027740   return s:Tree(FugitiveGitDir(a:0 ? a:1 : -1))

FUNCTION  <SNR>130_get_syn()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/autoload/airline/highlighter.vim:37
Called 18060 times
Total time:   0.973069
 Self time:   0.973069

count  total (s)   self (s)
18060              0.041273   let color = ''
18060              0.146514   if hlexists(a:group)
16780              0.220703     let color = synIDattr(synIDtrans(hlID(a:group)), a:what, a:mode)
18060              0.022686   endif
18060              0.079094   if empty(color) || color == -1
                                " should always exist
 1280              0.028827     let color = synIDattr(synIDtrans(hlID('Normal')), a:what, a:mode)
                                " however, just in case
 1280              0.005813     if empty(color) || color == -1
                                  let color = 'NONE'
 1280              0.001020     endif
18060              0.012839   endif
18060              0.032752   return color

FUNCTION  <SNR>150_mrw_append()
    Defined: ~/Repos/Configs/Neovim/.config/coc/extensions/node_modules/coc-fzf-preview/plugin/fzf_preview.vim:168
Called 4 times
Total time:   0.032694
 Self time:   0.000400

count  total (s)   self (s)
    4   0.000316   0.000121   if s:enable_file(a:path)
    4   0.032317   0.000218     call fzf_preview#remote#mr#append(a:path, fzf_preview#remote#mr#mrw_file_path())
    4              0.000035   endif

FUNCTION  FugitiveHead()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-fugitive/plugin/fugitive.vim:128
Called 1263 times
Total time:   1.504699
 Self time:   0.090012

count  total (s)   self (s)
 1263   0.079299   0.016308   let dir = FugitiveGitDir(a:0 > 1 ? a:2 : -1)
 1263              0.004676   if empty(dir)
                                return ''
 1263              0.008796   endif
 1263   1.407511   0.055814   return fugitive#Head(a:0 ? a:1 : 0, dir)

FUNCTION  <SNR>132_format_name()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/autoload/airline/extensions/branch.vim:77
Called 20 times
Total time:   0.000109
 Self time:   0.000109

count  total (s)   self (s)
   20              0.000058     return a:name

FUNCTION  <SNR>87_Tree()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-fugitive/plugin/fugitive.vim:164
Called 1270 times
Total time:   0.027749
 Self time:   0.027749

count  total (s)   self (s)
 1270              0.005548   let dir = a:path
 1270              0.009646   if dir =~# '/\.git$'
 1263              0.010331     return len(dir) ==# 5 ? '/' : dir[0:-6]
    7              0.000018   elseif dir ==# ''
    7              0.000011     return ''
                              endif
                              if !has_key(s:worktree_for_dir, dir)
                                let s:worktree_for_dir[dir] = ''
                                let config_file = dir . '/config'
                                if filereadable(config_file)
                                  let config = readfile(config_file,'',10)
                                  call filter(config,'v:val =~# "^\\s*worktree *="')
                                  if len(config) == 1
                                    let worktree = FugitiveVimPath(matchstr(config[0], '= *\zs.*'))
                                  endif
                                elseif filereadable(dir . '/gitdir')
                                  let worktree = fnamemodify(FugitiveVimPath(readfile(dir . '/gitdir')[0]), ':h')
                                  if worktree ==# '.'
                                    unlet! worktree
                                  endif
                                endif
                                if exists('worktree')
                                  let s:worktree_for_dir[dir] = s:Slash(resolve(worktree))
                                  let s:dir_for_worktree[s:worktree_for_dir[dir]] = dir
                                endif
                              endif
                              if s:worktree_for_dir[dir] =~# '^\.'
                                return simplify(dir . '/' . s:worktree_for_dir[dir])
                              else
                                return s:worktree_for_dir[dir]
                              endif

FUNCTION  gitgutter#sign#update_signs()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/sign.vim:57
Called 26 times
Total time:   0.016228
 Self time:   0.010804

count  total (s)   self (s)
   26              0.000133   if exists('*sign_unplace')
                                " Vim is (hopefully) now quick enough to remove all signs then place new ones.
   26              0.000367     call sign_unplace('gitgutter', {'buffer': a:bufnr})
                            
   26   0.000805   0.000291     let modified_lines = s:handle_double_hunk(a:modified_lines)
   26   0.008576   0.003667     let signs = map(copy(modified_lines), '{'. '"buffer":   a:bufnr,'. '"group":    "gitgutter",'. '"name":     s:highlight_name_for_change(v:val[1]),'. '"lnum":     v:val[0],'. '"priority": g:gitgutter_sign_priority'. '}')
                            
   26              0.000121     if exists('*sign_placelist')
                                  call sign_placelist(signs)
                                  return
   26              0.000023     endif
                            
  250              0.000386     for sign in signs
  224              0.004938       call sign_place(0, sign.group, sign.name, sign.buffer, {'lnum': sign.lnum, 'priority': sign.priority})
  250              0.000256     endfor
   26              0.000035     return
                              endif
                            
                            
                              " Derive a delta between the current signs and the ones we want.
                              " Remove signs from lines that no longer need a sign.
                              " Upsert the remaining signs.
                            
                              call s:find_current_signs(a:bufnr)
                            
                              let new_gitgutter_signs_line_numbers = map(copy(a:modified_lines), 'v:val[0]')
                              let obsolete_signs = s:obsolete_gitgutter_signs_to_remove(a:bufnr, new_gitgutter_signs_line_numbers)
                            
                              call s:remove_signs(a:bufnr, obsolete_signs, s:remove_all_old_signs)
                              call s:upsert_new_gitgutter_signs(a:bufnr, a:modified_lines)

FUNCTION  coc#float#get_related()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/coc.nvim/autoload/coc/float.vim:1271
Called 309 times
Total time:   0.013830
 Self time:   0.013830

count  total (s)   self (s)
  309              0.005369   for winid in getwinvar(a:winid, 'related', [])
                                if getwinvar(winid, 'kind', '') ==# a:kind
                                  return winid
                                endif
  309              0.001284   endfor
  309              0.001099   return 0

FUNCTION  <SNR>14_DetectCoffee()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-coffee-script/ftdetect/coffee.vim:11
Called 7 times
Total time:   0.000113
 Self time:   0.000113

count  total (s)   self (s)
    7              0.000068     if getline(1) =~ '^#!.*\<coffee\>'
                                    set filetype=coffee
    7              0.000008     endif

FUNCTION  airline#extensions#coc#get_warning()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/autoload/airline/extensions/coc.vim:10
Called 1263 times
Total time:   0.086694
 Self time:   0.014438

count  total (s)   self (s)
 1263   0.085607   0.013352   return airline#extensions#coc#get('warning')

FUNCTION  gitgutter#utility#set_repo_path()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:139
Called 17 times
Total time:   0.130244
 Self time:   0.008751

count  total (s)   self (s)
                              " Values of path:
                              " * non-empty string - path
                              " *               -1 - pending
                              " *               -2 - not tracked by git
                            
   17   0.000942   0.000255   call gitgutter#utility#setbufvar(a:bufnr, 'path', -1)
   17   0.010559   0.000727   let cmd = gitgutter#utility#cd_cmd(a:bufnr, g:gitgutter_git_executable.' '.g:gitgutter_git_args.' ls-files --error-unmatch --full-name -z -- '.gitgutter#utility#shellescape(s:filename(a:bufnr)))
                            
   17   0.006358   0.006006   if g:gitgutter_async && gitgutter#async#available() && !has('vim_starting')
   17              0.000185     let handler = copy(s:set_path_handler)
   17              0.000098     let handler.continuation = a:continuation
   17   0.111652   0.001031     call gitgutter#async#execute(cmd, a:bufnr, handler)
   17              0.000168     return 'async'
                              endif
                            
                              let path = gitgutter#utility#system(cmd)
                              if v:shell_error
                                call gitgutter#utility#setbufvar(a:bufnr, 'path', -2)
                              else
                                call gitgutter#utility#setbufvar(a:bufnr, 'path', s:strip_trailing_new_line(path))
                              endif

FUNCTION  <SNR>85_restore_shell()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:185
Called 1 time
Total time:   0.000054
 Self time:   0.000047

count  total (s)   self (s)
    1              0.000014   if has('unix') && exists('s:shell')
    1   0.000033   0.000027     let [&shell, &shellcmdflag, &shellredir] = [s:shell, s:shellcmdflag, s:shellredir]
    1              0.000002   endif

FUNCTION  vimspector#OnBufferCreated()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vimspector/autoload/vimspector.vim:494
Called 23 times
Total time:   0.000916
 Self time:   0.000776

count  total (s)   self (s)
   23              0.000219   if len( a:file_name ) == 0
    7              0.000012     return
   16              0.000027   endif
                            
                              " Don't actually load up vimsepctor python in autocommands that trigger
                              " regularly. We'll only create the session obkect in s:Enabled()
   16   0.000442   0.000301   if !s:Initialised()
   16              0.000029     return
                              endif
                            
                              if !s:Enabled()
                                return
                              endif
                            
                              py3 _vimspector_session.RefreshSigns( vim.eval( 'a:file_name' ) )

FUNCTION  fzf_preview#remote#resource#directory_files#get()
    Defined: ~/Repos/Configs/Neovim/.config/coc/extensions/node_modules/coc-fzf-preview/autoload/fzf_preview/remote/resource/directory_files.vim:1
Called 6 times
Total time:   0.565714
 Self time:   0.033913

count  total (s)   self (s)
    6   0.565674   0.033874   return systemlist(a:command)

FUNCTION  coc#float#check_related()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/coc.nvim/autoload/coc/float.vim:849
Called 89 times
Total time:   0.015276
 Self time:   0.015276

count  total (s)   self (s)
   89              0.000662   let invalids = []
   89              0.000465   if s:is_vim
                                if !exists('*popup_list')
                                  return
                                endif
                                for id in popup_list()
                                  let target = getwinvar(id, 'target_winid', 0)
                                  if target && !s:popup_visible(target)
                                    call add(invalids, id)
                                  endif
                                endfor
   89              0.000180   else
  201              0.001648     for i in range(1, winnr('$'))
  112              0.001257       let target = getwinvar(i, 'target_winid', 0)
  112              0.000804       if target && !nvim_win_is_valid(target)
                                    call add(invalids, win_getid(i))
  112              0.000187       endif
  201              0.000775     endfor
   89              0.000171   endif
   89              0.000447   for id in invalids
                                call s:close_win(id)
   89              0.000235   endfor

FUNCTION  airline#util#has_fugitive()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/autoload/airline/util.vim:143
Called 2577 times
Total time:   0.045871
 Self time:   0.045871

count  total (s)   self (s)
 2577              0.019644   if !exists("s:has_fugitive")
                                let s:has_fugitive = exists('*fugitive#head') || exists('*FugitiveHead')
 2577              0.002619   endif
 2577              0.006531   return s:has_fugitive

FUNCTION  repeat#set()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-repeat/autoload/repeat.vim:62
Called 7 times
Total time:   0.038243
 Self time:   0.038243

count  total (s)   self (s)
    7              0.000112     let g:repeat_sequence = a:sequence
    7              0.000053     let g:repeat_count = a:0 ? a:1 : v:count
    7              0.000034     let g:repeat_tick = b:changedtick
    7              0.000042     augroup repeat_custom_motion
    7              0.037820         autocmd!
    7              0.000120         autocmd CursorMoved <buffer> let g:repeat_tick = b:changedtick | autocmd! repeat_custom_motion
    7              0.000016     augroup END

FUNCTION  airline#highlighter#add_accent()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/autoload/airline/highlighter.vim:218
Called 6 times
Total time:   0.000044
 Self time:   0.000044

count  total (s)   self (s)
    6              0.000039   let s:accents[a:accent] = 1

FUNCTION  <SNR>145_check_user_options()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-startify/autoload/startify.vim:942
Called 1 time
Total time:   0.000079
 Self time:   0.000079

count  total (s)   self (s)
    1              0.000009   let session = a:path . s:sep .'Session.vim'
                            
    1              0.000011   if get(g:, 'startify_session_autoload') && filereadable(glob(session))
                                execute 'silent bwipeout' a:path
                                call startify#session_delete_buffers()
                                execute 'source' session
                                return
    1              0.000001   endif
                            
    1              0.000008   if get(g:, 'startify_change_to_vcs_root') && s:cd_to_vcs_root(a:path)
                                return
    1              0.000001   endif
                            
    1              0.000005   if get(g:, 'startify_change_to_dir', 1)
                                if isdirectory(a:path)
                                  execute s:cd_cmd() a:path
                                else
                                  let dir = fnamemodify(a:path, ':h')
                                  if isdirectory(dir)
                                    execute s:cd_cmd() dir
                                  else
                                    " Do nothing. E.g. a:path == `scp://foo/bar`
                                  endif
                                endif
    1              0.000001   endif

FUNCTION  <SNR>172_ReloadWinStatus()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-fugitive/autoload/fugitive.vim:2875
Called 4 times
Total time:   0.000059
 Self time:   0.000059

count  total (s)   self (s)
    4              0.000041   if get(b:, 'fugitive_type', '') !=# 'index' || &modified
    4              0.000009     return
                              endif
                              if !exists('b:fugitive_reltime')
                                exe s:ReloadStatusBuffer()
                                return
                              endif
                              let t = b:fugitive_reltime
                              if reltimestr(reltime(s:last_time, t)) =~# '-\|\d\{10\}\.' || reltimestr(reltime(get(s:last_times, s:cpath(s:Dir()), t), t)) =~# '-\|\d\{10\}\.'
                                exe s:ReloadStatusBuffer()
                              endif

FUNCTION  <SNR>135_check_mixed_indent()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/autoload/airline/extensions/whitespace.vim:16
Called 29 times
Total time:   0.030885
 Self time:   0.030885

count  total (s)   self (s)
   29              0.000215   let indent_algo = get(g:, 'airline#extensions#whitespace#mixed_indent_algo', 0)
   29              0.000067   if indent_algo == 1
                                " [<tab>]<space><tab>
                                " spaces before or between tabs are not allowed
                                let t_s_t = '(^\t* +\t\s*\S)'
                                " <tab>(<space> x count)
                                " count of spaces at the end of tabs should be less than tabstop value
                                let t_l_s = '(^\t+ {' . &ts . ',}' . '\S)'
                                return search('\v' . t_s_t . '|' . t_l_s, 'nw')
   29              0.000065   elseif indent_algo == 2
                                return search('\v(^\t* +\t\s*\S)', 'nw', 0, 500)
   29              0.000028   else
   29              0.030028     return search('\v(^\t+ +)|(^ +\t+)', 'nw', 0, 500)
                              endif

FUNCTION  <SNR>175_is_modified()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:282
Called 76 times
Total time:   0.000489
 Self time:   0.000489

count  total (s)   self (s)
   76              0.000368   return a:from_count > 0 && a:to_count > 0 && a:from_count == a:to_count

FUNCTION  coc#util#cursor()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/coc.nvim/autoload/coc/util.vim:81
Called 340 times
Total time:   0.016370
 Self time:   0.016370

count  total (s)   self (s)
  340              0.005150   let pos = getcurpos()
  340              0.005703   let content = pos[2] == 1 ? '' : getline('.')[0: pos[2] - 2]
  340              0.003889   return [pos[1] - 1, strchars(content)]

FUNCTION  <SNR>96_strip_white_space()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-commentary/plugin/commentary.vim:16
Called 7 times
Total time:   0.000460
 Self time:   0.000460

count  total (s)   self (s)
    7              0.000087   let [l, r] = [a:l, a:r]
    7              0.000144   if l[-1:] ==# ' ' && stridx(a:line,l) == -1 && stridx(a:line,l[0:-2]) == 0
                                let l = l[:-2]
    7              0.000012   endif
    7              0.000091   if r[0] ==# ' ' && a:line[-strlen(r):] != r && a:line[1-strlen(r):] == r[1:]
                                let r = r[1:]
    7              0.000010   endif
    7              0.000038   return [l, r]

FUNCTION  startify#open_buffers()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-startify/autoload/startify.vim:402
Called 1 time
Total time:   0.245824
 Self time:   0.007222

count  total (s)   self (s)
    1              0.000019   if exists('a:1')  " used in mappings
                                let entry = b:startify.entries[a:1]
                                if !empty(s:batchmode) && entry.type == 'file'
                                  call startify#set_mark(s:batchmode, a:1)
                                else
                                  call s:open_buffer(entry)
                                endif
                                return
    1              0.000002   endif
                            
    1              0.007052   let marked = filter(copy(b:startify.entries), 'v:val.marked')
    1              0.000011   if empty(marked)  " open current entry
    1   0.238685   0.000083     call s:open_buffer(b:startify.entries[line('.')])
    1              0.000003     return
                              endif
                            
                              enew
                              setlocal nobuflisted
                            
                              " Open all marked entries.
                              for entry in sort(values(marked), 's:sort_by_tick')
                                call s:open_buffer(entry)
                              endfor
                            
                              wincmd =
                            
                              if exists('#User#StartifyAllBuffersOpened')
                                doautocmd <nomodeline> User StartifyAllBuffersOpened
                              endif

FUNCTION  36()
    Defined: ~/.fzf/plugin/fzf.vim:785
Called 1 time
Total time:   0.012856
 Self time:   0.000729

count  total (s)   self (s)
    1   0.000043   0.000022     if s:getpos() == self.ppos " {'window': 'enew'}
                                  for [opt, val] in items(self.winopts)
                                    execute 'let' opt '=' val
                                  endfor
                                  call self.switch_back(1)
    1              0.000001     else
    1              0.000005       if bufnr('') == self.buf
                                    " We use close instead of bd! since Vim does not close the split when
                                    " there's no other listed buffer (nvim +'set nobuflisted')
    1   0.012710   0.000620         close
    1              0.000001       endif
    1              0.000008       silent! execute 'tabnext' self.ppos.tab
    1              0.000006       silent! execute self.ppos.win.'wincmd w'
    1              0.000001     endif
                            
    1              0.000003     if bufexists(self.buf)
                                  execute 'bd!' self.buf
    1              0.000001     endif
                            
    1   0.000025   0.000013     if &lines == self.lines && &columns == self.columns && s:getpos() == self.ppos
    1              0.000007       execute self.winrest
    1              0.000001     endif
                            
    1   0.000016   0.000012     if !s:exit_handler(a:code, self.command, 1)
    1              0.000001       return
                                endif
                            
                                call s:pushd(self.dict)
                                let lines = s:collect(self.temps)
                                call s:callback(self.dict, lines)
                                call self.switch_back(s:getpos() == self.ppos)

FUNCTION  gitgutter#utility#get_diff_base()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:191
Called 26 times
Total time:   0.004717
 Self time:   0.004717

count  total (s)   self (s)
   26              0.003338   let p = resolve(expand('#'.a:bufnr.':p'))
   26              0.000726   let ml = matchlist(p, '\v^fugitive:/.*/(\x{40,})/')
   26              0.000251   if !empty(ml) && !empty(ml[1])
                                return ml[1].'^'
   26              0.000046   endif
   26              0.000149   return g:gitgutter_diff_base

FUNCTION  <SNR>172_ExpireStatus()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-fugitive/autoload/fugitive.vim:2859
Called 4 times
Total time:   0.001203
 Self time:   0.000472

count  total (s)   self (s)
    4              0.000023   if a:bufnr == -2
                                let s:head_cache = {}
                                let s:last_time = reltime()
                                return ''
    4              0.000008   endif
    4   0.000450   0.000075   let dir = s:Dir(a:bufnr)
    4              0.000026   if len(dir)
    4   0.000514   0.000158     let s:last_times[s:cpath(dir)] = reltime()
    4              0.000033     if has_key(s:head_cache, dir)
    4              0.000051       call remove(s:head_cache, dir)
    4              0.000006     endif
    4              0.000004   endif
    4              0.000009   return ''

FUNCTION  airline#util#stl_disabled()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/autoload/airline/util.vim:185
Called 93 times
Total time:   0.004889
 Self time:   0.003119

count  total (s)   self (s)
                              " setting the statusline is disabled,
                              " either globally, per window, or per buffer
                              " w:airline_disabled is deprecated!
   93   0.004601   0.002831   return get(g:, 'airline_disable_statusline', 0) || airline#util#getwinvar(a:winnr, 'airline_disable_statusline', 0) || airline#util#getwinvar(a:winnr, 'airline_disabled', 0) || airline#util#getbufvar(winbufnr(a:winnr), 'airline_disable_statusline', 0)

FUNCTION  airline#parts#filetype()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/autoload/airline/parts.vim:102
Called 1275 times
Total time:   0.046990
 Self time:   0.021924

count  total (s)   self (s)
 1275   0.045622   0.020557   return (airline#util#winwidth() < 90 && strlen(&filetype) > 3) ? matchstr(&filetype, '...'). (&encoding is? 'utf-8' ? '' : '>') : &filetype

FUNCTION  airline#extensions#netrw#apply()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/autoload/airline/extensions/netrw.vim:11
Called 36 times
Total time:   0.001424
 Self time:   0.001424

count  total (s)   self (s)
   36              0.000416   if &ft == 'netrw'
                                let spc = g:airline_symbols.space
                            
                                call a:1.add_section('airline_a', spc.'netrw'.spc)
                                if exists('*airline#extensions#branch#get_head')
                                  call a:1.add_section('airline_b', spc.'%{airline#extensions#branch#get_head()}'.spc)
                                endif
                                call a:1.add_section('airline_c', spc.'%f'.spc)
                                call a:1.split()
                                call a:1.add_section('airline_y', spc.'%{airline#extensions#netrw#sortstring()}'.spc)
                                return 1
   36              0.000027   endif

FUNCTION  airline#parts#iminsert()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/autoload/airline/parts.vim:82
Called 1263 times
Total time:   0.018456
 Self time:   0.018456

count  total (s)   self (s)
 1263              0.007922   if g:airline_detect_iminsert && &iminsert && exists('b:keymap_name')
                                return toupper(b:keymap_name)
 1263              0.001411   endif
 1263              0.002065   return ''

FUNCTION  <SNR>56_Autocmd()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/coc.nvim/plugin/coc.vim:217
Called 621 times
Total time:   0.240660
 Self time:   0.018577

count  total (s)   self (s)
  621              0.004034   if !g:coc_workspace_initialized
                                return
  621              0.000892   endif
  621   0.232499   0.010417   call coc#rpc#notify('CocAutocmd', a:000)

FUNCTION  airline#extensions#term#apply()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/autoload/airline/extensions/term.vim:14
Called 29 times
Total time:   0.001091
 Self time:   0.001091

count  total (s)   self (s)
   29              0.000294   if &buftype ==? 'terminal' || bufname(a:2.bufnr)[0] ==? '!'
                                call a:1.add_section_spaced('airline_a', s:section_a)
                                call a:1.add_section_spaced('airline_b', s:neoterm_id(a:2.bufnr))
                                call a:1.add_section('airline_term', s:spc.s:termname(a:2.bufnr))
                                call a:1.split()
                                call a:1.add_section('airline_y', '')
                                call a:1.add_section_spaced('airline_z', s:section_z)
                                return 1
   29              0.000021   endif

FUNCTION  <SNR>129_wrap_accent()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/autoload/airline/section.vim:9
Called 6 times
Total time:   0.000180
 Self time:   0.000136

count  total (s)   self (s)
    6              0.000027   if exists('a:part.accent')
    6   0.000105   0.000061     call airline#highlighter#add_accent(a:part.accent)
    6              0.000040     return '%#__accent_'.(a:part.accent).'#'.a:value.'%#__restore__#'
                              endif
                              return a:value

FUNCTION  coc#rpc#request()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/coc.nvim/autoload/coc/rpc.vim:88
Called 12 times
Total time:   2.236405
 Self time:   0.000460

count  total (s)   self (s)
   12   0.000458   0.000192   if !coc#rpc#ready()
                                return ''
   12              0.000014   endif
   12   1.462391   0.439211   return s:client['request'](a:method, a:args)

FUNCTION  gitgutter#async#execute()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/async.vim:16
Called 43 times
Total time:   0.278949
 Self time:   0.273822

count  total (s)   self (s)
   43   0.013139   0.008673   call gitgutter#debug#log('[async] '.a:cmd)
                            
   43              0.000632   let options = {   'stdoutbuffer': [],   'buffer': a:bufnr,   'handler': a:handler }
   43   0.001344   0.000683   let command = s:build_command(a:cmd)
                            
   43              0.000266   if has('nvim')
   43              0.257175     call jobstart(command, extend(options, {   'on_stdout': function('s:on_stdout_nvim'),   'on_stderr': function('s:on_stderr_nvim'),   'on_exit':   function('s:on_exit_nvim') }))
                              else
                                let job = job_start(command, {   'out_cb':   function('s:on_stdout_vim', options),   'err_cb':   function('s:on_stderr_vim', options),   'close_cb': function('s:on_exit_vim', options) })
                                let s:jobs[s:job_id(job)] = 1
   43              0.000146   endif

FUNCTION  coc#_hide()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/coc.nvim/autoload/coc.vim:97
Called 2 times
Total time:   0.000017
 Self time:   0.000017

count  total (s)   self (s)
    2              0.000014   if !pumvisible() | return | endif
                              call feedkeys("\<C-e>", 'in')

FUNCTION  <SNR>85_exists_file()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:218
Called 114 times
Total time:   0.044559
 Self time:   0.017757

count  total (s)   self (s)
  114   0.044418   0.017617   return filereadable(s:abs_path(a:bufnr, 0))

FUNCTION  airline#extensions#coc#get()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/autoload/airline/extensions/coc.vim:18
Called 2526 times
Total time:   0.133111
 Self time:   0.133111

count  total (s)   self (s)
 2526              0.017948   if !exists(':CocCommand')
                                return ''
 2526              0.002263   endif
 2526              0.015648   let _backup = get(g:, 'coc_stl_format', '')
 2526              0.011433   let is_err = (a:type  is# 'error')
 2526              0.004237   if is_err
 1263              0.011596     let g:coc_stl_format = get(g:, 'airline#extensions#coc#stl_format_err', '%E{[%e(#%fe)]}')
 1263              0.001206   else
 1263              0.012574     let g:coc_stl_format = get(g:, 'airline#extensions#coc#stl_format_warn', '%W{[%w(#%fw)]}')
 2526              0.002920   endif
 2526              0.014179   let info = get(b:, 'coc_diagnostic_info', {})
 2526              0.011847   if empty(info) | return '' | endif
                            
                            
  128              0.000627   let cnt = get(info, a:type, 0)
  128              0.000419   if !empty(_backup)
  128              0.000705     let g:coc_stl_format = _backup
  128              0.000118   endif
                            
  128              0.000355   if empty(cnt)
  128              0.000187     return ''
                              else
                                return (is_err ? s:error_symbol : s:warning_symbol).cnt
                              endif

FUNCTION  <SNR>173_nvim_untracked_job_handler()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/autoload/airline/async.vim:238
Called 10 times
Total time:   0.012526
 Self time:   0.000486

count  total (s)   self (s)
   10              0.000064     if a:event == 'exit'
   10   0.012217   0.000177       call s:untracked_output(self, self.buf)
   10              0.000070       if has_key(s:untracked_jobs, self.file)
   10              0.000081         call remove(s:untracked_jobs, self.file)
   10              0.000011       endif
   10              0.000008     endif

FUNCTION  <SNR>48_dopopd()
    Defined: ~/.fzf/plugin/fzf.vim:541
Called 31 times
Total time:   0.011358
 Self time:   0.004233

count  total (s)   self (s)
   31              0.000392   if !exists('w:fzf_pushd')
   20              0.000032     return
   11              0.000013   endif
                            
                              " FIXME: We temporarily change the working directory to 'dir' entry
                              " of options dictionary (set to the current working directory if not given)
                              " before running fzf.
                              "
                              " e.g. call fzf#run({'dir': '/tmp', 'source': 'ls', 'sink': 'e'})
                              "
                              " After processing the sink function, we have to restore the current working
                              " directory. But doing so may not be desirable if the function changed the
                              " working directory on purpose.
                              "
                              " So how can we tell if we should do it or not? A simple heuristic we use
                              " here is that we change directory only if the current working directory
                              " matches 'dir' entry. However, it is possible that the sink function did
                              " change the directory to 'dir'. In that case, the user will have an
                              " unexpected result.
   11   0.001220   0.000547   if s:fzf_getcwd() ==# w:fzf_pushd.dir && (!&autochdir || w:fzf_pushd.bufname ==# bufname(''))
   11   0.009302   0.002850     execute w:fzf_pushd.command s:escape(w:fzf_pushd.origin)
   11              0.000043   endif
   11              0.000084   unlet! w:fzf_pushd

FUNCTION  fzf_preview#remote#util#get_columns()
    Defined: ~/Repos/Configs/Neovim/.config/coc/extensions/node_modules/coc-fzf-preview/autoload/fzf_preview/remote/util.vim:68
Called 7 times
Total time:   0.000186
 Self time:   0.000186

count  total (s)   self (s)
    7              0.000099   return &columns

FUNCTION  airline#update_tabline()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/autoload/airline.vim:273
Called 368 times
Total time:   0.008309
 Self time:   0.008309

count  total (s)   self (s)
  368              0.004153   if get(g:, 'airline_statusline_ontop', 0)
                                call airline#extensions#tabline#redraw()
  368              0.001011   endif

FUNCTION  <SNR>105_vm_persist()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-visual-multi/plugin/visual-multi.vim:76
Called 1 time
Total time:   0.000022
 Self time:   0.000022

count  total (s)   self (s)
    1              0.000007   if exists('g:VM_PERSIST') && !g:VM_persistent_registers
                                unlet g:VM_PERSIST
    1              0.000003   elseif g:VM_persistent_registers
                                let g:VM_PERSIST = deepcopy(g:Vm.registers)
    1              0.000001   endif

FUNCTION  <SNR>115_LocalBrowse()
    Defined: /usr/local/Cellar/neovim/HEAD-40a7427/share/nvim/runtime/plugin/netrwPlugin.vim:102
Called 19 times
Total time:   0.002585
 Self time:   0.002585

count  total (s)   self (s)
                              " Unfortunate interaction -- only DechoMsg debugging calls can be safely used here.
                              " Otherwise, the BufEnter event gets triggered when attempts to write to
                              " the DBG buffer are made.
                            
   19              0.000104   if !exists("s:vimentered")
                               " If s:vimentered doesn't exist, then the VimEnter event hasn't fired.  It will,
                               " and so s:VimEnter() will then be calling this routine, but this time with s:vimentered defined.
                            "   call Dfunc("s:LocalBrowse(dirname<".a:dirname.">)  (s:vimentered doesn't exist)")
                            "   call Dret("s:LocalBrowse")
                               return
   19              0.000017   endif
                            
                            "  call Dfunc("s:LocalBrowse(dirname<".a:dirname.">)  (s:vimentered=".s:vimentered.")")
                            
   19              0.000109   if has("amiga")
                               " The check against '' is made for the Amiga, where the empty
                               " string is the current directory and not checking would break
                               " things such as the help command.
                            "   call Decho("(LocalBrowse) dirname<".a:dirname.">  (isdirectory, amiga)")
                               if a:dirname != '' && isdirectory(a:dirname)
                                sil! call netrw#LocalBrowseCheck(a:dirname)
                                if exists("w:netrw_bannercnt") && line('.') < w:netrw_bannercnt
                                 exe w:netrw_bannercnt
                                endif
                               endif
                            
   19              0.001392   elseif isdirectory(a:dirname)
                            "   call Decho("(LocalBrowse) dirname<".a:dirname."> ft=".&ft."  (isdirectory, not amiga)")
                            "   call Dredir("LocalBrowse ft last set: ","verbose set ft")
                               sil! call netrw#LocalBrowseCheck(a:dirname)
                               if exists("w:netrw_bannercnt") && line('.') < w:netrw_bannercnt
                                exe w:netrw_bannercnt
                               endif
                            
   19              0.000017   else
                               " not a directory, ignore it
                            "   call Decho("(LocalBrowse) dirname<".a:dirname."> not a directory, ignoring...")
   19              0.000018   endif
                            
                            "  call Dret("s:LocalBrowse")

FUNCTION  <SNR>176_highlight_name_for_change()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/sign.vim:234
Called 224 times
Total time:   0.004910
 Self time:   0.004910

count  total (s)   self (s)
  224              0.000533   if a:text ==# 'added'
  130              0.000185     return 'GitGutterLineAdded'
   94              0.000183   elseif a:text ==# 'removed'
    1              0.000001     return 'GitGutterLineRemoved'
   93              0.000948   elseif a:text ==# 'removed_first_line'
                                return 'GitGutterLineRemovedFirstLine'
   93              0.000180   elseif a:text ==# 'modified'
   93              0.000139     return 'GitGutterLineModified'
                              elseif a:text ==# 'modified_removed'
                                return 'GitGutterLineModifiedRemoved'
                              elseif a:text ==# 'removed_above_and_below'
                                return 'GitGutterLineRemovedAboveAndBelow'
                              endif

FUNCTION  provider#python3#Call()
    Defined: /usr/local/Cellar/neovim/HEAD-40a7427/share/nvim/runtime/autoload/provider/python3.vim:26
Called 1 time
Total time:   0.042619
 Self time:   0.042619

count  total (s)   self (s)
    1              0.000010   if s:err != ''
                                return
    1              0.000002   endif
    1              0.000011   if !exists('s:host')
                                let s:rpcrequest = function('rpcrequest')
                            
                                " Ensure that we can load the Python3 host before bootstrapping
                                try
                                  let s:host = remote#host#Require('legacy-python3-provider')
                                catch
                                  let s:err = v:exception
                                  echohl WarningMsg
                                  echomsg v:exception
                                  echohl None
                                  return
                                endtry
    1              0.000002   endif
    1              0.042544   return call(s:rpcrequest, insert(insert(a:args, 'python_'.a:method), s:host))

FUNCTION  gitgutter#utility#has_repo_path()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:102
Called 102 times
Total time:   0.020980
 Self time:   0.014486

count  total (s)   self (s)
  102   0.020841   0.014346   return index(['', -1, -2], gitgutter#utility#repo_path(a:bufnr, 0)) == -1

FUNCTION  <SNR>48_collect()
    Defined: ~/.fzf/plugin/fzf.vim:855
Called 4 times
Total time:   0.052955
 Self time:   0.052955

count  total (s)   self (s)
    4              0.000010   try
    4              0.044946     return filereadable(a:temps.result) ? readfile(a:temps.result) : []
    4              0.000040   finally
   12              0.000156     for tf in values(a:temps)
    8              0.007630       silent! call delete(tf)
   12              0.000070     endfor
    4              0.000015   endtry

FUNCTION  fzf_preview#remote#mr#mrw_file_path()
    Defined: ~/Repos/Configs/Neovim/.config/coc/extensions/node_modules/coc-fzf-preview/autoload/fzf_preview/remote/mr.vim:12
Called 4 times
Total time:   0.000088
 Self time:   0.000088

count  total (s)   self (s)
    4              0.000080   return g:fzf_preview_cache_directory . '/mrw'

FUNCTION  <SNR>175_git_supports_command_line_config_override()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:8
Called 1 time
Total time:   0.045114
 Self time:   0.000040

count  total (s)   self (s)
    1   0.045106   0.000031   call gitgutter#utility#system(g:gitgutter_git_executable.' '.g:gitgutter_git_args.' -c foo.bar=baz --version')
    1              0.000003   return !v:shell_error

FUNCTION  airline#highlighter#add_separator()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/autoload/airline/highlighter.vim:213
Called 224 times
Total time:   0.280652
 Self time:   0.006222

count  total (s)   self (s)
  224              0.002498   let s:separators[a:from.a:to] = [a:from, a:to, a:inverse]
  224   0.277931   0.003501   call <sid>exec_separator({}, a:from, a:to, a:inverse, '')

FUNCTION  <SNR>25_show_hover_doc()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugin-coc-diagnostic.vim:7
Called 92 times
Total time:   0.003268
 Self time:   0.003268

count  total (s)   self (s)
   92              0.002406   call timer_start(500, 'ShowDocIfNoDiagnostic')

FUNCTION  <SNR>132_reset_untracked_cache()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/autoload/airline/extensions/branch.vim:319
Called 4 times
Total time:   0.001694
 Self time:   0.001334

count  total (s)   self (s)
                              " shellcmdpost - whether function was called as a result of ShellCmdPost hook
    4              0.000065   if !g:airline#init#vim_async && !has('nvim')
                                if a:shellcmdpost
                                  " Clear cache only if there was no error or the script uses an
                                  " asynchronous interface. Otherwise, cache clearing would overwrite
                                  " v:shell_error with a system() call inside get_*_untracked.
                                  if v:shell_error
                                    return
                                  endif
                                endif
    4              0.000006   endif
                            
    4              0.000465   let file = expand("%:p")
   12              0.000109   for vcs in keys(s:vcs_config)
                                " Dump the value of the cache for the current file. Partially mitigates the
                                " issue of cache invalidation happening before a call to
                                " s:update_untracked()
    8   0.000588   0.000229     call airline#extensions#branch#update_untracked_config(file, vcs)
    8              0.000159     let s:vcs_config[vcs].untracked = {}
   12              0.000039   endfor

FUNCTION  airline#extensions#po#apply()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/autoload/airline/extensions/po.vim:54
Called 29 times
Total time:   0.000398
 Self time:   0.000398

count  total (s)   self (s)
   29              0.000145   if &ft ==# 'po'
                                call airline#extensions#prepend_to_section('z', '%{airline#extensions#po#stats()}')
                                " Also reset the cache variable, if a window has been split, e.g. the winwidth changed
                                autocmd airline BufWritePost * unlet! b:airline_po_stats
                                autocmd airline WinEnter * call airline#extensions#po#on_winenter()
   29              0.000023   endif

FUNCTION  21()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/autoload/airline/builder.vim:8
Called 50 times
Total time:   0.000369
 Self time:   0.000369

count  total (s)   self (s)
   50              0.000326   call add(self._sections, ['|', a:0 ? a:1 : '%='])

FUNCTION  23()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/autoload/airline/builder.vim:17
Called 306 times
Total time:   0.002298
 Self time:   0.002298

count  total (s)   self (s)
  306              0.002078   call add(self._sections, [a:group, a:contents])

FUNCTION  28()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/autoload/airline/builder.vim:62
Called 57 times
Total time:   0.544197
 Self time:   0.062922

count  total (s)   self (s)
   57              0.000142   let side = 1
   57              0.000105   let line = ''
   57              0.000092   let i = 0
   57              0.000440   let length = len(self._sections)
   57              0.000110   let split = 0
   57              0.000113   let is_empty = 0
   57              0.000195   let prev_group = ''
                            
  413              0.000948   while i < length
  356              0.001317     let section = self._sections[i]
  356              0.001113     let group = section[0]
  356              0.001070     let contents = section[1]
  356              0.000854     let pgroup = prev_group
  356   0.010829   0.003835     let prev_group = airline#builder#get_prev_group(self._sections, i)
  356              0.004026     if group ==# 'airline_c' && &buftype ==# 'terminal' && self._context.active
    7              0.000015       let group = 'airline_term'
  349              0.001926     elseif group ==# 'airline_c' && !self._context.active && has_key(self._context, 'bufnr')
    4              0.000017       let group = 'airline_c'. self._context.bufnr
  345              0.002898     elseif prev_group ==# 'airline_c' && !self._context.active && has_key(self._context, 'bufnr')
    4              0.000016       let prev_group = 'airline_c'. self._context.bufnr
  356              0.000288     endif
  356              0.000506     if is_empty
                                  let prev_group = pgroup
  356              0.000246     endif
  356   0.010762   0.003657     let is_empty = s:section_is_empty(self, contents)
                            
  356              0.000491     if is_empty
                                  " need to fix highlighting groups, since we
                                  " have skipped a section, we actually need
                                  " the previous previous group and so the
                                  " seperator goes from the previous previous group
                                  " to the current group
                                  let pgroup = group
  356              0.000262     endif
                            
  356              0.000747     if group == ''
                                  let line .= contents
  356              0.000753     elseif group == '|'
   50              0.000072       let side = 0
   50              0.000197       let line .= contents
   50              0.000075       let split = 1
  306              0.000243     else
  306              0.000632       if prev_group == ''
   57              0.000283         let line .= '%#'.group.'#'
  249              0.000334       elseif split
   42              0.000055         if !is_empty
   42   0.058407   0.000581           let line .= s:get_transitioned_seperator(self, prev_group, group, side)
   42              0.000045         endif
   42              0.000081         let split = 0
  207              0.000156       else
  207              0.000307         if !is_empty
  207   0.388714   0.003230           let line .= s:get_seperator(self, prev_group, group, side)
  207              0.000267         endif
  306              0.000382       endif
  306   0.028748   0.004881       let line .= is_empty ? '' : s:get_accented_line(self, group, contents)
  356              0.000319     endif
                            
  356              0.000818     let i = i + 1
  413              0.005833   endwhile
                            
   57              0.000147   if !self._context.active
                                "let line = substitute(line, '%#airline_c#', '%#airline_c'.self._context.bufnr.'#', '')
   21              0.000882     let line = substitute(line, '%#.\{-}\ze#', '\0_inactive', 'g')
   57              0.000050   endif
   57              0.000108   return line

FUNCTION  <SNR>130_GetHiCmd()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/autoload/airline/highlighter.vim:157
Called 160 times
Total time:   0.032158
 Self time:   0.032158

count  total (s)   self (s)
                              " a:list needs to have 5 items!
  160              0.000379   let res = ''
  160              0.000322   let i = -1
  960              0.001530   while i < 4
  800              0.001464     let i += 1
  800              0.005771     let item = get(a:list, i, '')
  800              0.001825     if item is ''
  148              0.000181       continue
  652              0.000453     endif
  652              0.000872     if i == 0
  160              0.000706       let res .= ' guifg='.item
  492              0.000661     elseif i == 1
  144              0.000519       let res .= ' guibg='.item
  348              0.000417     elseif i == 2
  160              0.000709       let res .= ' ctermfg='.item
  188              0.000252     elseif i == 3
  144              0.000646       let res .= ' ctermbg='.item
   44              0.000055     elseif i == 4
   44              0.000354       let res .= printf(' gui=%s cterm=%s term=%s', item, item, item)
  652              0.000683     endif
  812              0.001170   endwhile
  160              0.000346   return res

FUNCTION  coc#_do_complete()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/coc.nvim/autoload/coc.vim:68
Called 4 times
Total time:   0.000282
 Self time:   0.000282

count  total (s)   self (s)
    4              0.000119   let g:coc#_context = { 'start': a:start, 'candidates': a:items, 'preselect': a:preselect}
    4              0.000086   if mode() =~# 'i' && &paste != 1
    4              0.000056     call feedkeys("\<Plug>CocRefresh", 'i')
    4              0.000006   endif

FUNCTION  gitgutter#utility#cd_cmd()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:164
Called 43 times
Total time:   0.018433
 Self time:   0.002176

count  total (s)   self (s)
   43   0.009422   0.001309   let cd = s:unc_path(a:bufnr) ? 'pushd' : (gitgutter#utility#windows() && s:dos_shell() ? 'cd /d' : 'cd')
   43   0.008942   0.000799   return cd.' '.s:dir(a:bufnr).' && '.a:cmd

FUNCTION  smoothie#upwards()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-smoothie/autoload/smoothie.vim:186
Called 4 times
Total time:   0.000616
 Self time:   0.000173

count  total (s)   self (s)
    4   0.000171   0.000092   call s:count_to_scroll()
    4   0.000433   0.000070   call s:update_target(-&scroll)

FUNCTION  airline#util#winwidth()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/autoload/airline/util.vim:19
Called 16611 times
Total time:   0.355136
 Self time:   0.355136

count  total (s)   self (s)
16611              0.103588   let nr = get(a:000, 0, 0)
16611              0.099735   if get(g:, 'airline_statusline_ontop', 0)
                                return &columns
16611              0.018986   else
16611              0.066254     return winwidth(nr)
                              endif

FUNCTION  <SNR>114_Highlight_Matching_Pair()
    Defined: /usr/local/Cellar/neovim/HEAD-40a7427/share/nvim/runtime/plugin/matchparen.vim:39
Called 361 times
Total time:   0.097111
 Self time:   0.097111

count  total (s)   self (s)
                              " Remove any previous match.
  361              0.003505   if exists('w:paren_hl_on') && w:paren_hl_on
    9              0.000098     silent! call matchdelete(3)
    9              0.000084     let w:paren_hl_on = 0
  361              0.000575   endif
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
  361              0.004580   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
  361              0.000424   endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
  361              0.003034   let c_lnum = line('.')
  361              0.002128   let c_col = col('.')
  361              0.001214   let before = 0
                            
  361              0.002698   let text = getline(c_lnum)
  361              0.015184   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
  361              0.002076   if empty(matches)
                                let [c_before, c] = ['', '']
  361              0.000657   else
  361              0.004264     let [c_before, c] = matches[1:2]
  361              0.000568   endif
  361              0.008448   let plist = split(&matchpairs, '.\zs[:,]')
  361              0.003336   let i = index(plist, c)
  361              0.001128   if i < 0
                                " not found, in Insert mode try character before the cursor
  352              0.003183     if c_col > 1 && (mode() == 'i' || mode() == 'R')
   18              0.000083       let before = strlen(c_before)
   18              0.000038       let c = c_before
   18              0.000063       let i = index(plist, c)
  352              0.000515     endif
  352              0.000926     if i < 0
                                  " not found, nothing to do
  352              0.000992       return
                                endif
    9              0.000009   endif
                            
                              " Figure out the arguments for searchpairpos().
    9              0.000024   if i % 2 == 0
    6              0.000017     let s_flags = 'nW'
    6              0.000029     let c2 = plist[i + 1]
    3              0.000004   else
    3              0.000011     let s_flags = 'nbW'
    3              0.000011     let c2 = c
    3              0.000017     let c = plist[i - 1]
    9              0.000009   endif
    9              0.000026   if c == '['
    6              0.000014     let c = '\['
    6              0.000013     let c2 = '\]'
    9              0.000009   endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
    9              0.000021   if before > 0
                                let has_getcurpos = exists("*getcurpos")
                                if has_getcurpos
                                  " getcurpos() is more efficient but doesn't exist before 7.4.313.
                                  let save_cursor = getcurpos()
                                else
                                  let save_cursor = winsaveview()
                                endif
                                call cursor(c_lnum, c_col - before)
    9              0.000009   endif
                            
    9              0.000097   if !has("syntax") || !exists("g:syntax_on")
                                let s_skip = "0"
    9              0.000010   else
                                " Build an expression that detects whether the current cursor position is
                                " in certain syntax types (string, comment, etc.), for use as
                                " searchpairpos()'s skip argument.
                                " We match "escape" for special items, such as lispEscapeSpecial.
    9              0.000084     let s_skip = '!empty(filter(map(synstack(line("."), col(".")), ''synIDattr(v:val, "name")''), ' . '''v:val =~? "string\\|character\\|singlequote\\|escape\\|comment"''))'
                                " If executing the expression determines that the cursor is currently in
                                " one of the syntax types, then we want searchpairpos() to find the pair
                                " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                                " outside of the syntax types and s_skip should keep its value so we skip
                                " any matching pair inside the syntax types.
                                " Catch if this throws E363: pattern uses more memory than 'maxmempattern'.
    9              0.000015     try
    9              0.005768       execute 'if ' . s_skip . ' | let s_skip = "0" | endif'
                                catch /^Vim\%((\a\+)\)\=:E363/
                                  " We won't find anything, so skip searching, should keep Vim responsive.
                                  return
    9              0.000016     endtry
    9              0.000011   endif
                            
                              " Limit the search to lines visible in the window.
    9              0.000074   let stoplinebottom = line('w$')
    9              0.000063   let stoplinetop = line('w0')
    9              0.000030   if i % 2 == 0
    6              0.000030     let stopline = stoplinebottom
    3              0.000004   else
    3              0.000018     let stopline = stoplinetop
    9              0.000010   endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
    9              0.000066   if mode() == 'i' || mode() == 'R'
                                let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
    9              0.000012   else
    9              0.000095     let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
    9              0.000010   endif
    9              0.000013   try
    9              0.002192     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
                              catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
    9              0.000016   endtry
                            
    9              0.000025   if before > 0
                                if has_getcurpos
                                  call setpos('.', save_cursor)
                                else
                                  call winrestview(save_cursor)
                                endif
    9              0.000009   endif
                            
                              " If a match is found setup match highlighting.
    9              0.000059   if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
    9              0.000056     if exists('*matchaddpos')
    9              0.000413       call matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10, 3)
                                else
                                  exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
    9              0.000010     endif
    9              0.000036     let w:paren_hl_on = 1
    9              0.000011   endif

FUNCTION  <SNR>178_step_up()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-smoothie/autoload/smoothie.vim:38
Called 108 times
Total time:   0.026734
 Self time:   0.004053

count  total (s)   self (s)
  108              0.000795   if line('.') > 1
  108   0.025080   0.002398     call s:execute_preserving_scroll("normal! 1\<C-U>")
  108              0.000552     return 0
                              else
                                return 1
                              endif

FUNCTION  airline#util#doautocmd()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/autoload/airline/util.vim:176
Called 59 times
Total time:   0.099004
 Self time:   0.073023

count  total (s)   self (s)
   59   0.098891   0.072910   exe printf("silent doautocmd %s User %s", s:nomodeline, a:event)

FUNCTION  30()
    Defined: /usr/local/Cellar/neovim/HEAD-40a7427/share/nvim/runtime/autoload/provider/clipboard.vim:147
Called 2 times
Total time:   1.419131
 Self time:   0.000149

count  total (s)   self (s)
    2              0.000027   if type(s:paste[a:reg]) == v:t_func
                                return s:paste[a:reg]()
    2              0.000016   elseif s:selections[a:reg].owner > 0
                                return s:selections[a:reg].data
    2              0.000003   end
    2   1.419057   0.000075   return s:try_cmd(s:paste[a:reg])

FUNCTION  31()
    Defined: /usr/local/Cellar/neovim/HEAD-40a7427/share/nvim/runtime/autoload/provider/clipboard.vim:156
Called 2 times
Total time:   3.408768
 Self time:   0.000227

count  total (s)   self (s)
    2              0.000022   if a:reg == '"'
                                call s:clipboard.set(a:lines,a:regtype,'+')
                                if s:copy['*'] != s:copy['+']
                                  call s:clipboard.set(a:lines,a:regtype,'*')
                                end
                                return 0
    2              0.000003   end
                            
    2              0.000020   if type(s:copy[a:reg]) == v:t_func
                                call s:copy[a:reg](a:lines, a:regtype)
                                return 0
    2              0.000002   end
                            
    2              0.000006   if s:cache_enabled == 0
    2   3.408631   0.000090     call s:try_cmd(s:copy[a:reg], a:lines)
    2              0.000008     return 0
                              end
                            
                              if s:selections[a:reg].owner > 0
                                let prev_job = s:selections[a:reg].owner
                              end
                              let s:selections[a:reg] = copy(s:selection)
                              let selection = s:selections[a:reg]
                              let selection.data = [a:lines, a:regtype]
                              let selection.argv = s:copy[a:reg]
                              let selection.detach = s:cache_enabled
                              let selection.cwd = "/"
                              let jobid = jobstart(selection.argv, selection)
                              if jobid > 0
                                call jobsend(jobid, a:lines)
                                call jobclose(jobid, 'stdin')
                                " xclip does not close stdout when receiving input via stdin
                                if selection.argv[0] ==# 'xclip'
                                  call jobclose(jobid, 'stdout')
                                endif
                                let selection.owner = jobid
                                let ret = 1
                              else
                                echohl WarningMsg
                                echomsg 'clipboard: failed to execute: '.(s:copy[a:reg])
                                echohl None
                                let ret = 1
                              endif
                            
                              " The previous provider instance should exit when the new one takes
                              " ownership, but kill it to be sure we don't fill up the job table.
                              if exists('prev_job')
                                call timer_start(1000, {... -> jobwait([prev_job], 0)[0] == -1 && jobstop(prev_job)})
                              endif
                            
                              return ret

FUNCTION  33()
    Defined: ~/.fzf/plugin/fzf.vim:785
Called 1 time
Total time:   0.010830
 Self time:   0.001176

count  total (s)   self (s)
    1   0.000044   0.000022     if s:getpos() == self.ppos " {'window': 'enew'}
                                  for [opt, val] in items(self.winopts)
                                    execute 'let' opt '=' val
                                  endfor
                                  call self.switch_back(1)
    1              0.000001     else
    1              0.000006       if bufnr('') == self.buf
                                    " We use close instead of bd! since Vim does not close the split when
                                    " there's no other listed buffer (nvim +'set nobuflisted')
    1   0.010672   0.001057         close
    1              0.000001       endif
    1              0.000008       silent! execute 'tabnext' self.ppos.tab
    1              0.000006       silent! execute self.ppos.win.'wincmd w'
    1              0.000001     endif
                            
    1              0.000003     if bufexists(self.buf)
                                  execute 'bd!' self.buf
    1              0.000001     endif
                            
    1   0.000026   0.000013     if &lines == self.lines && &columns == self.columns && s:getpos() == self.ppos
    1              0.000019       execute self.winrest
    1              0.000001     endif
                            
    1   0.000016   0.000012     if !s:exit_handler(a:code, self.command, 1)
    1              0.000001       return
                                endif
                            
                                call s:pushd(self.dict)
                                let lines = s:collect(self.temps)
                                call s:callback(self.dict, lines)
                                call self.switch_back(s:getpos() == self.ppos)

FUNCTION  38()
    Defined: ~/.fzf/plugin/fzf.vim:774
Called 1 time
Total time:   0.000025
 Self time:   0.000025

count  total (s)   self (s)
    1              0.000008     if a:inplace && bufnr('') == self.buf
                                  if bufexists(self.pbuf)
                                    execute 'keepalt b' self.pbuf
                                  endif
                                  " No other listed buffer
                                  if bufnr('') == self.buf
                                    enew
                                  endif
    1              0.000001     endif

FUNCTION  coc#util#get_complete_option()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/coc.nvim/autoload/coc/util.vim:374
Called 2 times
Total time:   0.000506
 Self time:   0.000506

count  total (s)   self (s)
    2              0.000015   let pos = getcurpos()
    2              0.000013   let line = getline(pos[1])
    2              0.000030   let input = matchstr(strpart(line, 0, pos[2] - 1), '\k*$')
    2              0.000012   let col = pos[2] - strlen(input)
    2              0.000149   let synname = synIDattr(synID(pos[1], col, 1), 'name')
    2              0.000279   return { 'word': matchstr(strpart(line, col - 1), '^\k\+'), 'input': empty(input) ? '' : input, 'line': line, 'filetype': &filetype, 'filepath': expand('%:p'), 'bufnr': bufnr('%'), 'linenr': pos[1], 'colnr' : pos[2], 'col': col - 1, 'synname': synname, 'changedtick': b:changedtick, 'blacklist': get(b:, 'coc_suggest_blacklist', []),}

FUNCTION  <SNR>85_use_known_shell()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:177
Called 1 time
Total time:   0.000050
 Self time:   0.000048

count  total (s)   self (s)
    1              0.000007   if has('unix') && &shell !=# 'sh'
    1              0.000009     let [s:shell, s:shellcmdflag, s:shellredir] = [&shell, &shellcmdflag, &shellredir]
    1   0.000017   0.000015     let &shell = 'sh'
    1   0.000015   0.000014     set shellcmdflag=-c shellredir=>%s\ 2>&1
    1              0.000001   endif

FUNCTION  FugitiveIsGitDir()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-fugitive/plugin/fugitive.vim:155
Called 28 times
Total time:   0.001146
 Self time:   0.001146

count  total (s)   self (s)
   28              0.000416   let path = substitute(a:path, '[\/]$', '', '') . '/'
   28              0.000693   return len(a:path) && getfsize(path.'HEAD') > 10 && ( isdirectory(path.'objects') && isdirectory(path.'refs') || getftype(path.'commondir') ==# 'file')

FUNCTION  <SNR>172_add_methods()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-fugitive/autoload/fugitive.vim:688
Called 5 times
Total time:   0.001413
 Self time:   0.000676

count  total (s)   self (s)
   21              0.000086   for name in a:method_names
   16   0.001205   0.000468     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
   21              0.000053   endfor

FUNCTION  41()
    Defined: ~/.fzf/plugin/fzf.vim:774
Called 1 time
Total time:   0.000025
 Self time:   0.000025

count  total (s)   self (s)
    1              0.000008     if a:inplace && bufnr('') == self.buf
                                  if bufexists(self.pbuf)
                                    execute 'keepalt b' self.pbuf
                                  endif
                                  " No other listed buffer
                                  if bufnr('') == self.buf
                                    enew
                                  endif
    1              0.000001     endif

FUNCTION  42()
    Defined: ~/.fzf/plugin/fzf.vim:785
Called 1 time
Total time:   0.266806
 Self time:   0.001555

count  total (s)   self (s)
    1   0.000051   0.000027     if s:getpos() == self.ppos " {'window': 'enew'}
                                  for [opt, val] in items(self.winopts)
                                    execute 'let' opt '=' val
                                  endfor
                                  call self.switch_back(1)
    1              0.000001     else
    1              0.000006       if bufnr('') == self.buf
                                    " We use close instead of bd! since Vim does not close the split when
                                    " there's no other listed buffer (nvim +'set nobuflisted')
    1   0.049720   0.001185         close
    1              0.000004       endif
    1              0.000021       silent! execute 'tabnext' self.ppos.tab
    1              0.000011       silent! execute self.ppos.win.'wincmd w'
    1              0.000001     endif
                            
    1              0.000007     if bufexists(self.buf)
                                  execute 'bd!' self.buf
    1              0.000001     endif
                            
    1   0.000061   0.000033     if &lines == self.lines && &columns == self.columns && s:getpos() == self.ppos
    1              0.000012       execute self.winrest
    1              0.000001     endif
                            
    1   0.000067   0.000023     if !s:exit_handler(a:code, self.command, 1)
                                  return
    1              0.000001     endif
                            
    1   0.000913   0.000047     call s:pushd(self.dict)
    1   0.006106   0.000024     let lines = s:collect(self.temps)
    1   0.209672   0.000048     call s:callback(self.dict, lines)
    1   0.000082   0.000034     call self.switch_back(s:getpos() == self.ppos)

FUNCTION  <SNR>172_can_diffoff()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-fugitive/autoload/fugitive.vim:4837
Called 18 times
Total time:   0.000408
 Self time:   0.000408

count  total (s)   self (s)
   18              0.000339   return getwinvar(bufwinnr(a:buf), '&diff') && !empty(getwinvar(bufwinnr(a:buf), 'fugitive_diff_restore'))

FUNCTION  <SNR>172_Slash()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-fugitive/autoload/fugitive.vim:104
Called 3789 times
Total time:   0.069761
 Self time:   0.069761

count  total (s)   self (s)
 3789              0.022526   if exists('+shellslash')
                                return tr(a:path, '\', '/')
 3789              0.004130   else
 3789              0.020980     return a:path
                              endif

FUNCTION  <SNR>175_process_removed()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:303
Called 1 time
Total time:   0.000011
 Self time:   0.000011

count  total (s)   self (s)
    1              0.000001   if a:to_line == 0
                                call add(a:modifications, [1, 'removed_first_line'])
    1              0.000001   else
    1              0.000004     call add(a:modifications, [a:to_line, 'removed'])
    1              0.000001   endif

FUNCTION  <SNR>135_ws_refresh()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/autoload/airline/extensions/whitespace.vim:184
Called 93 times
Total time:   0.002853
 Self time:   0.002853

count  total (s)   self (s)
   93              0.001324   if get(b:, 'airline_ws_changedtick', 0) == b:changedtick
   71              0.000188     return
   22              0.000036   endif
   22              0.000296   unlet! b:airline_whitespace_check
   22              0.000194   if get(g:, 'airline_skip_empty_sections', 0)
                                exe ':AirlineRefresh!'
   22              0.000032   endif
   22              0.000187   let b:airline_ws_changedtick = b:changedtick

FUNCTION  <SNR>171_get_files_with_create_directory()
    Defined: ~/Repos/Configs/Neovim/.config/coc/extensions/node_modules/coc-fzf-preview/autoload/fzf_preview/remote/mr.vim:16
Called 32 times
Total time:   0.174990
 Self time:   0.174990

count  total (s)   self (s)
   32              0.000797   if !isdirectory(g:fzf_preview_cache_directory)
                                call mkdir(g:fzf_preview_cache_directory, 'p')
   32              0.000045   endif
                            
   32              0.000053   try
   32              0.170310     let files = readfile(a:cache_path)
                              catch
                                let files = []
   32              0.000110   endtry
                            
   32              0.000168   return files

FUNCTION  gitgutter#diff#parse_diff()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:206
Called 26 times
Total time:   0.016791
 Self time:   0.005388

count  total (s)   self (s)
   26              0.000089   let hunks = []
  129              0.000535   for line in split(a:diff, '\n')
  103   0.012886   0.001483     let hunk_info = gitgutter#diff#parse_hunk(line)
  103              0.002219     if len(hunk_info) == 4
  103              0.000386       call add(hunks, hunk_info)
  103              0.000090     endif
  129              0.000135   endfor
   26              0.000051   return hunks

FUNCTION  coc#util#refactor_foldlevel()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/coc.nvim/autoload/coc/util.vim:905
Called 52 times
Total time:   0.000607
 Self time:   0.000607

count  total (s)   self (s)
   52              0.000161   if a:lnum <= 2 | return 0 | endif
   46              0.000138   let line = getline(a:lnum)
   46              0.000221   if line =~# '^\%u3000\s*$' | return 0 | endif
   42              0.000036   return 1

FUNCTION  <SNR>175_is_added()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:274
Called 103 times
Total time:   0.000436
 Self time:   0.000436

count  total (s)   self (s)
  103              0.000326   return a:from_count == 0 && a:to_count > 0

FUNCTION  <SNR>175_process_modified()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:311
Called 62 times
Total time:   0.002048
 Self time:   0.002048

count  total (s)   self (s)
   62              0.000169   let offset = 0
  135              0.000313   while offset < a:to_count
   73              0.000238     let line_number = a:to_line + offset
   73              0.000396     call add(a:modifications, [line_number, 'modified'])
   73              0.000171     let offset += 1
  135              0.000177   endwhile

FUNCTION  51()
    Defined: ~/.fzf/plugin/fzf.vim:785
Called 1 time
Total time:   0.499754
 Self time:   0.001416

count  total (s)   self (s)
    1   0.000051   0.000027     if s:getpos() == self.ppos " {'window': 'enew'}
                                  for [opt, val] in items(self.winopts)
                                    execute 'let' opt '=' val
                                  endfor
                                  call self.switch_back(1)
    1              0.000002     else
    1              0.000006       if bufnr('') == self.buf
                                    " We use close instead of bd! since Vim does not close the split when
                                    " there's no other listed buffer (nvim +'set nobuflisted')
    1   0.043348   0.000915         close
    1              0.000004       endif
    1              0.000015       silent! execute 'tabnext' self.ppos.tab
    1              0.000014       silent! execute self.ppos.win.'wincmd w'
    1              0.000001     endif
                            
    1              0.000008     if bufexists(self.buf)
                                  execute 'bd!' self.buf
    1              0.000001     endif
                            
    1   0.000052   0.000030     if &lines == self.lines && &columns == self.columns && s:getpos() == self.ppos
    1              0.000011       execute self.winrest
    1              0.000001     endif
                            
    1   0.000054   0.000017     if !s:exit_handler(a:code, self.command, 1)
                                  return
    1              0.000001     endif
                            
    1   0.000629   0.000012     call s:pushd(self.dict)
    1   0.014108   0.000024     let lines = s:collect(self.temps)
    1   0.441122   0.000042     call s:callback(self.dict, lines)
    1   0.000273   0.000233     call self.switch_back(s:getpos() == self.ppos)

FUNCTION  airline#extensions#keymap#status()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/autoload/airline/extensions/keymap.vim:10
Called 1263 times
Total time:   0.109047
 Self time:   0.109047

count  total (s)   self (s)
 1263              0.017139   if (get(g:, 'airline#extensions#keymap#enabled', 1) && has('keymap'))
 1263              0.011251     let short_codes = get(g:, 'airline#extensions#keymap#short_codes', {})
 1263              0.012271     let label = get(g:, 'airline#extensions#keymap#label', g:airline_symbols.keymap)
 1263              0.009025     let default = get(g:, 'airline#extensions#keymap#default', '')
 1263              0.004755     if (label !=# '')
 1263              0.006179       let label .= ' '
 1263              0.001780     endif
 1263              0.005582     let keymap = &keymap
 1263              0.007997     if has_key(short_codes, keymap)
                                  let keymap = short_codes[keymap]
 1263              0.001449     endif
 1263              0.020061     return printf('%s', (!empty(keymap) && &iminsert ? (label . keymap) : (!empty(default) ? label . default : default)))
                              else
                                return ''
                              endif

FUNCTION  <SNR>175_process_added()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:294
Called 26 times
Total time:   0.001547
 Self time:   0.001547

count  total (s)   self (s)
   26              0.000068   let offset = 0
  121              0.000232   while offset < a:to_count
   95              0.000254     let line_number = a:to_line + offset
   95              0.000407     call add(a:modifications, [line_number, 'added'])
   95              0.000206     let offset += 1
  121              0.000125   endwhile

FUNCTION  <SNR>175_is_removed()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:278
Called 77 times
Total time:   0.000406
 Self time:   0.000406

count  total (s)   self (s)
   77              0.000337   return a:from_count > 0 && a:to_count == 0

FUNCTION  <SNR>48_escape()
    Defined: ~/.fzf/plugin/fzf.vim:231
Called 22 times
Total time:   0.000407
 Self time:   0.000407

count  total (s)   self (s)
   22              0.000243   let path = fnameescape(a:path)
   22              0.000118   return s:is_win ? escape(path, '$') : path

FUNCTION  <SNR>48_create_popup()
    Defined: ~/.fzf/plugin/fzf.vim:898
Called 7 times
Total time:   0.235575
 Self time:   0.007251

count  total (s)   self (s)
    7   0.092916   0.003085     let buf = nvim_create_buf(v:false, v:true)
    7              0.000156     let opts = extend({'relative': 'editor', 'style': 'minimal'}, a:opts)
    7              0.000054     let border = has_key(opts, 'border') ? remove(opts, 'border') : []
    7   0.141997   0.003528     let win = nvim_open_win(buf, v:true, opts)
    7   0.000283   0.000268     call setwinvar(win, '&winhighlight', 'NormalFloat:'..a:hl)
    7   0.000072   0.000063     call setwinvar(win, '&colorcolumn', '')
    7              0.000024     if !empty(border)
                                  call nvim_buf_set_lines(buf, 0, -1, v:true, border)
    7              0.000006     endif
    7              0.000013     return buf

FUNCTION  <SNR>85_not_git_dir()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:59
Called 102 times
Total time:   0.026130
 Self time:   0.003851

count  total (s)   self (s)
  102   0.025768   0.003489   return s:dir(a:bufnr) !~ '[/\\]\.git\($\|[/\\]\)'

FUNCTION  gitgutter#diff#process_hunks()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:232
Called 26 times
Total time:   0.053771
 Self time:   0.002196

count  total (s)   self (s)
   26              0.000088   let modified_lines = []
  129              0.000255   for hunk in a:hunks
  103   0.053015   0.001441     call extend(modified_lines, s:process_hunk(a:bufnr, hunk))
  129              0.000154   endfor
   26              0.000049   return modified_lines

FUNCTION  <SNR>132_update_branch()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/autoload/airline/extensions/branch.vim:173
Called 1263 times
Total time:   2.041387
 Self time:   0.152855

count  total (s)   self (s)
 3789              0.020397   for vcs in keys(s:vcs_config)
 2526   1.937270   0.048738     call {s:vcs_config[vcs].update_branch}()
 2526              0.024536     if b:buffer_vcs_config[vcs].branch != s:vcs_config[vcs].branch
    7              0.000043       let b:buffer_vcs_config[vcs].branch = s:vcs_config[vcs].branch
    7              0.000016       unlet! b:airline_head
 2526              0.002791     endif
 3789              0.006432   endfor

FUNCTION  animate#window_is_animating()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/animate.vim/plugin/animate.vim:260
Called 26 times
Total time:   0.000254
 Self time:   0.000254

count  total (s)   self (s)
   26              0.000177   let timer_id = get(g:animate#timer_ids, a:target_window, 0)
   26              0.000054   return timer_id != 0

FUNCTION  <SNR>173_nvim_output_handler()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/autoload/airline/async.vim:232
Called 58 times
Total time:   0.006288
 Self time:   0.006288

count  total (s)   self (s)
   58              0.001451     if a:event == 'stdout' || a:event == 'stderr'
   58              0.004559       let self.buf .=  join(a:data)
   58              0.000121     endif

FUNCTION  airline#section#create()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/autoload/airline/section.vim:74
Called 6 times
Total time:   0.001819
 Self time:   0.000097

count  total (s)   self (s)
    6   0.001815   0.000093   return s:create(a:parts, 0)

FUNCTION  <SNR>97_add_format()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-speeddating/plugin/speeddating.vim:21
Called 19 times
Total time:   0.000716
 Self time:   0.000716

count  total (s)   self (s)
                              " Calls with neither argument nor count are for information,
                              " and so should be handled immediately.
                              " Call loadformats to cause autoloading to happen
   19              0.000081   if a:master == "" && !a:count
                                call speeddating#loadformats()
   19              0.000017   endif
                            
   19              0.000093   if exists("g:speeddating_loaded_formats")
                                " Autoloading already done pass on request immediately
                                call speeddating#adddate(a:master,a:count,a:bang)
   19              0.000018   else
                                " Defer handling of format specifications until autoloading is done
   19              0.000221     let g:speeddating_formats += [[a:master,a:count,a:bang]]
   19              0.000018   endif

FUNCTION  airline#extensions#default#apply()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/autoload/airline/extensions/default.vim:79
Called 50 times
Total time:   0.081571
 Self time:   0.004735

count  total (s)   self (s)
   50              0.000193   let winnr = a:context.winnr
   50              0.000135   let active = a:context.active
                            
   50   0.004846   0.000694   if airline#util#getwinvar(winnr, 'airline_render_left', active || (!active && !g:airline_inactive_collapse))
   33   0.032397   0.000437     call s:build_sections(a:builder, a:context, s:layout[0])
   17              0.000016   else
   17   0.001530   0.000167     let text = s:get_section(winnr, 'c')
   17              0.000050     if empty(text)
                                  let text = ' %f%m '
   17              0.000015     endif
   17   0.000323   0.000186     call a:builder.add_section('airline_c'.(a:context.bufnr), text)
   50              0.000044   endif
                            
   50   0.004513   0.000838   call a:builder.split(s:get_section(winnr, 'gutter', '', ''))
                            
   50   0.000676   0.000393   if airline#util#getwinvar(winnr, 'airline_render_right', 1)
   42   0.035781   0.000517     call s:build_sections(a:builder, a:context, s:layout[1])
   50              0.000045   endif
                            
   50              0.000063   return 1

FUNCTION  <SNR>87_CeilingDirectories()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-fugitive/plugin/fugitive.vim:198
Called 28 times
Total time:   0.001236
 Self time:   0.001236

count  total (s)   self (s)
   28              0.000166   if !exists('s:ceiling_directories')
    1              0.000003     let s:ceiling_directories = []
    1              0.000002     let resolve = 1
    2              0.000014     for dir in split($GIT_CEILING_DIRECTORIES, has('win32') ? ';' : ':', 1)
    1              0.000003       if empty(dir)
    1              0.000002         let resolve = 0
                                  elseif resolve
                                    call add(s:ceiling_directories, resolve(dir))
                                  else
                                    call add(s:ceiling_directories, dir)
    1              0.000001       endif
    2              0.000003     endfor
   28              0.000027   endif
   28              0.000208   return s:ceiling_directories + get(g:, 'ceiling_directories', [])

FUNCTION  <SNR>48_pushd()
    Defined: ~/.fzf/plugin/fzf.vim:519
Called 11 times
Total time:   0.010304
 Self time:   0.005969

count  total (s)   self (s)
   11   0.000294   0.000114   if s:present(a:dict, 'dir')
   11   0.000954   0.000116     let cwd = s:fzf_getcwd()
   11              0.000209     let w:fzf_pushd = {   'command': haslocaldir() ? 'lcd' : (exists(':tcd') && haslocaldir(-1) ? 'tcd' : 'cd'),   'origin': cwd,   'bufname': bufname('') }
   11   0.008207   0.005128     execute 'lcd' s:escape(a:dict.dir)
   11   0.000407   0.000168     let cwd = s:fzf_getcwd()
   11              0.000064     let w:fzf_pushd.dir = cwd
   11              0.000091     let a:dict.pushd = w:fzf_pushd
   11              0.000032     return cwd
                              endif
                              return ''

FUNCTION  <SNR>85_winshell()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:68
Called 26 times
Total time:   0.000504
 Self time:   0.000504

count  total (s)   self (s)
   26              0.000467   return &shell =~? 'cmd' || exists('+shellslash') && !&shellslash

FUNCTION  <SNR>131_is_branch_empty()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/autoload/airline/extensions/hunks.vim:55
Called 1263 times
Total time:   0.035942
 Self time:   0.035942

count  total (s)   self (s)
 1263              0.033275   return exists('*airline#extensions#branch#head') && empty(get(b:, 'airline_head', ''))

FUNCTION  <SNR>87_Slash()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-fugitive/plugin/fugitive.vim:313
Called 1290 times
Total time:   0.020084
 Self time:   0.020084

count  total (s)   self (s)
 1290              0.007520   if exists('+shellslash')
                                return tr(a:path, '\', '/')
 1290              0.001344   else
 1290              0.004557     return a:path
                              endif

FUNCTION  FugitiveVimPath()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-fugitive/plugin/fugitive.vim:301
Called 1277 times
Total time:   0.020411
 Self time:   0.020411

count  total (s)   self (s)
 1277              0.008422   if exists('+shellslash') && !&shellslash
                                return tr(a:path, '/', '\')
 1277              0.001410   else
 1277              0.003252     return a:path
                              endif

FUNCTION  <SNR>125_invoke_funcrefs()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/autoload/airline.vim:177
Called 57 times
Total time:   0.667312
 Self time:   0.006683

count  total (s)   self (s)
   57   0.003563   0.000626   let builder = airline#builder#new(a:context)
   57   0.115503   0.002008   let err = airline#util#exec_funcrefs(a:funcrefs + s:core_funcrefs, builder, a:context)
   57              0.000095   if err == 1
   57   0.544960   0.000762     let a:context.line = builder.build()
   57              0.001530     let s:contexts[a:context.winnr] = a:context
   57              0.000378     let option = get(g:, 'airline_statusline_ontop', 0) ? '&tabline' : '&statusline'
   57              0.001043     call setwinvar(a:context.winnr, option, '%!airline#statusline('.a:context.winnr.')')
   57              0.000061   endif

FUNCTION  <SNR>48_split()
    Defined: ~/.fzf/plugin/fzf.vim:720
Called 7 times
Total time:   0.237299
 Self time:   0.000873

count  total (s)   self (s)
    7              0.000118   let directions = { 'up':    ['topleft', 'resize', &lines], 'down':  ['botright', 'resize', &lines], 'left':  ['vertical topleft', 'vertical resize', &columns], 'right': ['vertical botright', 'vertical resize', &columns] }
    7   0.000165   0.000066   let ppos = s:getpos()
    7              0.000015   let is_popup = 0
    7              0.000008   try
    7   0.000145   0.000056     if s:present(a:dict, 'window')
    7              0.000034       if type(a:dict.window) == type({})
    7   0.000108   0.000043         if !s:popup_support()
                                      throw 'Nvim 0.4+ or Vim 8.2.191+ with popupwin feature is required for pop-up window'
    7              0.000006         end
    7   0.236252   0.000079         call s:popup(a:dict.window)
    7              0.000019         let is_popup = 1
                                  else
                                    execute 'keepalt' a:dict.window
    7              0.000005       endif
                                elseif !s:splittable(a:dict)
                                  execute (tabpagenr()-1).'tabnew'
                                else
                                  for [dir, triple] in items(directions)
                                    let val = get(a:dict, dir, '')
                                    if !empty(val)
                                      let [cmd, resz, max] = triple
                                      if (dir == 'up' || dir == 'down') && val[0] == '~'
                                        let sz = s:calc_size(max, val, a:dict)
                                      else
                                        let sz = s:calc_size(max, val, {})
                                      endif
                                      execute cmd sz.'new'
                                      execute resz sz
                                      return [ppos, {}, is_popup]
                                    endif
                                  endfor
    7              0.000005     endif
    7              0.000041     return [ppos, is_popup ? {} : { '&l:wfw': &l:wfw, '&l:wfh': &l:wfh }, is_popup]
    7              0.000010   finally
    7              0.000010     if !is_popup
                                  setlocal winfixwidth winfixheight
    7              0.000005     endif
    7              0.000009   endtry

FUNCTION  airline#extensions#fugitiveline#bufname()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/autoload/airline/extensions/fugitiveline.vim:15
Called 1275 times
Total time:   0.267960
 Self time:   0.255493

count  total (s)   self (s)
 1275              0.008608   if !exists('b:fugitive_name')
    9              0.000035     let b:fugitive_name = ''
    9              0.000015     try
    9              0.003737       if bufname('%') =~? '^fugitive:' && exists('*FugitiveReal')
                                    let b:fugitive_name = FugitiveReal(bufname('%'))
    9              0.000187       elseif exists('b:git_dir') && exists('*fugitive#repo')
    9              0.000082         if get(b:, 'fugitive_type', '') is# 'blob'
                                      let b:fugitive_name = fugitive#repo().translate(FugitivePath(@%, ''))
    9              0.000019         endif
                                  elseif exists('b:git_dir') && !exists('*fugitive#repo')
                                    let buffer = fugitive#buffer()
                                    if buffer.type('blob')
                                      let b:fugitive_name = buffer.repo().translate(buffer.path('/'))
                                    endif
    9              0.000009       endif
                                catch
    9              0.000016     endtry
 1275              0.001202   endif
                            
 1275   0.026768   0.014302   let fmod = s:ModifierFlags()
 1275              0.006336   if empty(b:fugitive_name)
 1275              0.139694     return fnamemodify(bufname('%'), fmod)
                              else
                                return fnamemodify(b:fugitive_name, fmod). " [git]"
                              endif

FUNCTION  airline#highlighter#exec()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/autoload/airline/highlighter.vim:101
Called 2285 times
Total time:   1.349733
 Self time:   0.263049

count  total (s)   self (s)
 2285              0.006946   if pumvisible()
                                return
 2285              0.001896   endif
 2285              0.006519   let colors = a:colors
 2285              0.004342   if s:is_win32term
                                let colors[2] = s:gui2cui(get(colors, 0, ''), get(colors, 2, ''))
                                let colors[3] = s:gui2cui(get(colors, 1, ''), get(colors, 3, ''))
 2285              0.002096   endif
 2285   0.916661   0.035391   let old_hi = airline#highlighter#get_highlight(a:group)
 2285              0.008754   if len(colors) == 4
  914              0.003655     call add(colors, '')
 2285              0.002079   endif
 2285              0.036643   let new_hi = [colors[0], colors[1], printf('%s', colors[2]), printf('%s', colors[3]), colors[4]]
 2285   0.149055   0.031570   let colors = s:CheckDefined(colors)
 2285   0.088472   0.032702   if old_hi != new_hi || !s:hl_group_exists(a:group)
  160   0.034641   0.002484     let cmd = printf('hi %s%s', a:group, s:GetHiCmd(colors))
  160              0.007219     exe cmd
  160              0.001064     if has_key(s:hl_groups, a:group)
  160              0.000821       let s:hl_groups[a:group] = colors
  160              0.000168     endif
 2285              0.001618   endif

FUNCTION  FugitiveGitDir()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-fugitive/plugin/fugitive.vim:11
Called 2530 times
Total time:   0.213752
 Self time:   0.195600

count  total (s)   self (s)
 2530              0.024780   if !a:0 || type(a:1) == type(0) && a:1 < 0
 1267              0.006838     if exists('g:fugitive_event')
                                  return g:fugitive_event
 1267              0.001462     endif
 1267              0.009299     let dir = get(b:, 'git_dir', '')
 1267              0.011774     if empty(dir) && (empty(bufname('')) || &buftype =~# '^\%(nofile\|acwrite\|quickfix\|prompt\)$')
                                  return FugitiveExtractGitDir(getcwd())
 1267              0.001353     endif
 1267              0.002905     return dir
 1263              0.006680   elseif type(a:1) == type(0)
                                return getbufvar(a:1, 'git_dir')
 1263              0.006616   elseif type(a:1) == type('')
 1263   0.044809   0.026658     return substitute(s:Slash(a:1), '/$', '', '')
                              else
                                return ''
                              endif

FUNCTION  <SNR>132_update_git_branch()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/autoload/airline/extensions/branch.vim:87
Called 1263 times
Total time:   1.735314
 Self time:   0.143539

count  total (s)   self (s)
 1263   0.038063   0.016821   call airline#util#ignore_next_focusgain()
 1263   0.034843   0.013959   if !airline#util#has_fugitive() && !airline#util#has_gina()
                                let s:vcs_config['git'].branch = ''
                                return
 1263              0.001208   endif
 1263   0.027824   0.009464   if airline#util#has_fugitive()
 1263   1.536211   0.031513     let s:vcs_config['git'].branch = exists("*FugitiveHead") ? FugitiveHead(s:sha1size) : fugitive#head(s:sha1size)
 1263   0.047372   0.020782     if s:vcs_config['git'].branch is# 'master' && airline#util#winwidth() < 81
                                  " Shorten default a bit
                                  let s:vcs_config['git'].branch='mas'
 1263              0.001500     endif
                              else
                                try
                                  let g:gina#component#repo#commit_length = s:sha1size
                                  let s:vcs_config['git'].branch = gina#component#repo#branch()
                                catch
                                endtry
                                if s:vcs_config['git'].branch is# 'master' && airline#util#winwidth() < 81
                                  " Shorten default a bit
                                  let s:vcs_config['git'].branch='mas'
                                endif
 1263              0.001159   endif

FUNCTION  airline#parts#get()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/autoload/airline/parts.vim:49
Called 2532 times
Total time:   0.023049
 Self time:   0.023049

count  total (s)   self (s)
 2532              0.020507   return get(s:parts, a:key, {})

FUNCTION  gitgutter#debug#log()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/debug.vim:70
Called 70 times
Total time:   0.005850
 Self time:   0.005850

count  total (s)   self (s)
   70              0.000242   if g:gitgutter_log
                                if s:new_log_session && gitgutter#async#available()
                                  if exists('*ch_logfile')
                                    call ch_logfile(s:channel_log, 'w')
                                  endif
                                endif
                            
                                execute 'redir >> '.s:log_file
                                  if s:new_log_session
                                    let s:start = reltime()
                                    silent echo "\n==== start log session ===="
                                  endif
                            
                                  let elapsed = reltimestr(reltime(s:start)).' '
                                  silent echo ''
                                  " callers excluding this function
                                  silent echo elapsed.expand('<sfile>')[:-22].':'
                                  silent echo elapsed.s:format_for_log(a:message)
                                  if a:0 && !empty(a:1)
                                    for msg in a:000
                                      silent echo elapsed.s:format_for_log(msg)
                                    endfor
                                  endif
                                redir END
                            
                                let s:new_log_session = 0
   70              0.000085   endif

FUNCTION  airline#util#wrap()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/autoload/airline/util.vim:42
Called 14141 times
Total time:   0.227664
 Self time:   0.181219

count  total (s)   self (s)
14141   0.141429   0.094984   if a:minwidth > 0 && airline#util#winwidth() < a:minwidth
                                return ''
14141              0.013154   endif
14141              0.031674   return a:text

FUNCTION  <SNR>48_present()
    Defined: ~/.fzf/plugin/fzf.vim:485
Called 18 times
Total time:   0.000268
 Self time:   0.000268

count  total (s)   self (s)
   18              0.000079   for key in a:000
   18              0.000121     if !empty(get(a:dict, key, ''))
   18              0.000028       return 1
                                endif
                              endfor
                              return 0

FUNCTION  <SNR>48_fzf_call()
    Defined: ~/.fzf/plugin/fzf.vim:73
Called 68 times
Total time:   0.002039
 Self time:   0.002039

count  total (s)   self (s)
   68              0.001781     return call(a:fn, a:000)

FUNCTION  <SNR>130_CheckDefined()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/autoload/airline/highlighter.vim:125
Called 2285 times
Total time:   0.117485
 Self time:   0.117485

count  total (s)   self (s)
                              " Checks, whether the definition of the colors is valid and is not empty or NONE
                              " e.g. if the colors would expand to this:
                              " hi airline_c ctermfg=NONE ctermbg=NONE
                              " that means to clear that highlighting group, therefore, fallback to Normal
                              " highlighting group for the cterm values
                            
                              " This only works, if the Normal highlighting group is actually defined, so
                              " return early, if it has been cleared
 2285              0.023169   if !exists("g:airline#highlighter#normal_fg_hi")
                                let g:airline#highlighter#normal_fg_hi = synIDattr(synIDtrans(hlID('Normal')), 'fg', 'cterm')
 2285              0.009435   endif
 2285              0.016744   if empty(g:airline#highlighter#normal_fg_hi) || g:airline#highlighter#normal_fg_hi < 0
                                return a:colors
 2285              0.001747   endif
                            
 2285              0.009960   for val in a:colors
 2285              0.011358     if !empty(val) && val !=# 'NONE'
 2285              0.004452       return a:colors
                                endif
                              endfor
                              " this adds the bold attribute to the term argument of the :hi command,
                              " but at least this makes sure, the group will be defined
                              let fg = g:airline#highlighter#normal_fg_hi
                              let bg = synIDattr(synIDtrans(hlID('Normal')), 'bg', 'cterm')
                              if bg < 0
                                " in case there is no background color defined for Normal
                                let bg = a:colors[3]
                              endif
                              return a:colors[0:1] + [fg, bg] + [a:colors[4]]

FUNCTION  fzf_preview#remote#store#restore_store()
    Defined: ~/Repos/Configs/Neovim/.config/coc/extensions/node_modules/coc-fzf-preview/autoload/fzf_preview/remote/store.vim:7
Called 8 times
Total time:   0.000145
 Self time:   0.000145

count  total (s)   self (s)
    8              0.000116   return s:state

FUNCTION  <SNR>173_on_exit_clean()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/autoload/airline/async.vim:87
Called 10 times
Total time:   0.003220
 Self time:   0.000743

count  total (s)   self (s)
   10              0.000127   let buf=self.buf
   10   0.002866   0.000389   call s:set_clean_variables(self.file, self.vcs, !empty(buf))
   10              0.000107   if has_key(get(s:clean_jobs, self.vcs, {}), self.file)
   10              0.000085     call remove(s:clean_jobs[self.vcs], self.file)
   10              0.000011   endif

FUNCTION  gitgutter#utility#extension()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:88
Called 26 times
Total time:   0.004574
 Self time:   0.000545

count  total (s)   self (s)
   26   0.004543   0.000514   return fnamemodify(s:abs_path(a:bufnr, 0), ':e')

FUNCTION  airline#extensions#term#inactive_apply()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/autoload/airline/extensions/term.vim:26
Called 21 times
Total time:   0.000784
 Self time:   0.000784

count  total (s)   self (s)
   21              0.000158   if getbufvar(a:2.bufnr, '&buftype') ==? 'terminal'
                                call a:1.add_section_spaced('airline_a', s:section_a)
                                call a:1.add_section_spaced('airline_b', s:neoterm_id(a:2.bufnr))
                                call a:1.add_section('airline_term', s:spc.s:termname(a:2.bufnr))
                                call a:1.split()
                                call a:1.add_section('airline_y', '')
                                call a:1.add_section_spaced('airline_z', s:section_z)
                                return 1
   21              0.000016   endif

FUNCTION  9()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:131
Called 12 times
Total time:   0.000698
 Self time:   0.000244

count  total (s)   self (s)
   12   0.000659   0.000204   call gitgutter#utility#setbufvar(a:buffer, 'path', -2)

FUNCTION  <SNR>135_conflict_marker()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/autoload/airline/extensions/whitespace.vim:51
Called 29 times
Total time:   0.002883
 Self time:   0.002883

count  total (s)   self (s)
                              " Checks for git conflict markers
   29              0.000138   let annotation = '\%([0-9A-Za-z_.:]\+\)\?'
   29              0.000179   if &ft is# 'rst'
                                " rst filetypes use '=======' as header
                                let pattern = '^\%(\%(<\{7} '.annotation. '\)\|\%(>\{7\} '.annotation.'\)\)$'
   29              0.000027   else
   29              0.000236     let pattern = '^\%(\%(<\{7} '.annotation. '\)\|\%(=\{7\}\)\|\%(>\{7\} '.annotation.'\)\)$'
   29              0.000028   endif
   29              0.002063   return search(pattern, 'nw')

FUNCTION  <SNR>78_on_focus_gained()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/plugin/airline.vim:85
Called 2 times
Total time:   0.290296
 Self time:   0.012761

count  total (s)   self (s)
    2   0.004163   0.000315   if airline#util#try_focusgained()
    2   0.286062   0.012374     unlet! w:airline_lastmode | :call <sid>airline_refresh(1)
    2              0.000002   endif

FUNCTION  airline#builder#get_prev_group()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/autoload/airline/builder.vim:37
Called 356 times
Total time:   0.006994
 Self time:   0.006994

count  total (s)   self (s)
  356              0.001063   let x = a:i - 1
  398              0.000945   while x >= 0
  341              0.001299     let group = a:sections[x][0]
  341              0.001209     if group != '' && group != '|'
  299              0.000555       return group
   42              0.000032     endif
   42              0.000069     let x = x - 1
   99              0.000154   endwhile
   57              0.000080   return ''

FUNCTION  <SNR>172_cpath()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-fugitive/autoload/fugitive.vim:125
Called 14 times
Total time:   0.001012
 Self time:   0.000591

count  total (s)   self (s)
   14   0.000365   0.000160   if s:FileIgnoreCase(0)
                                let path = FugitiveVimPath(tolower(a:path))
   14              0.000023   else
   14   0.000390   0.000174     let path = FugitiveVimPath(a:path)
   14              0.000017   endif
   14              0.000083   return a:0 ? path ==# s:cpath(a:1) : path

FUNCTION  airline#extensions#apply_left_override()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/autoload/airline/extensions.vim:63
Called 6 times
Total time:   0.002003
 Self time:   0.000184

count  total (s)   self (s)
    6              0.000030   let w:airline_section_a = a:section1
    6              0.000022   let w:airline_section_b = a:section2
    6   0.001901   0.000082   let w:airline_section_c = airline#section#create(['readonly'])
    6              0.000020   let w:airline_render_left = 1
    6              0.000017   let w:airline_render_right = 0

FUNCTION  airline#util#getwinvar()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/autoload/airline/util.vim:82
Called 678 times
Total time:   0.008181
 Self time:   0.008181

count  total (s)   self (s)
  678              0.003974     return getwinvar(a:winnr, a:key, a:def)

FUNCTION  FugitiveDetect()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-fugitive/plugin/fugitive.vim:272
Called 7 times
Total time:   0.008061
 Self time:   0.000378

count  total (s)   self (s)
    7              0.000047   if exists('b:git_dir') && b:git_dir =~# '^$\|/$\|^fugitive:'
                                unlet b:git_dir
    7              0.000008   endif
    7              0.000027   if !exists('b:git_dir')
    7   0.007782   0.000099     let dir = FugitiveExtractGitDir(a:path)
    7              0.000017     if dir !=# ''
    7              0.000021       let b:git_dir = dir
    7              0.000007     endif
    7              0.000005   endif
    7              0.000079   if !exists('b:git_dir') || !exists('#User#Fugitive')
    7              0.000010     return ''
                              endif
                              if v:version >= 704 || (v:version == 703 && has('patch442'))
                                doautocmd <nomodeline> User Fugitive
                              elseif &modelines > 0
                                let modelines = &modelines
                                try
                                  set modelines=0
                                  doautocmd User Fugitive
                                finally
                                  let &modelines = modelines
                                endtry
                              else
                                doautocmd User Fugitive
                              endif
                              return ''

FUNCTION  airline#extensions#whitespace#check()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/autoload/airline/extensions/whitespace.vim:63
Called 1263 times
Total time:   0.459634
 Self time:   0.318368

count  total (s)   self (s)
 1263              0.013148   let max_lines = get(g:, 'airline#extensions#whitespace#max_lines', 20000)
 1263              0.015695   if &readonly || !&modifiable || !s:enabled || line('$') > max_lines || get(b:, 'airline_whitespace_disabled', 0)
                                return ''
 1263              0.001382   endif
 1263              0.024491   let skip_check_ft = extend(s:skip_check_ft, get(g:, 'airline#extensions#whitespace#skip_indent_check_ft', {}), 'force')
                            
 1263              0.007775   if !exists('b:airline_whitespace_check')
   29              0.000132     let b:airline_whitespace_check = ''
   29              0.000282     let checks = get(b:, 'airline_whitespace_checks', get(g:, 'airline#extensions#whitespace#checks', s:default_checks))
                            
   29              0.000071     let trailing = 0
   29              0.000066     let check = 'trailing'
   29              0.000431     if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
   29              0.000045       try
   29              0.000177         let regexp = get(g:, 'airline#extensions#whitespace#trailing_regexp', '\s$')
   29              0.003686         let trailing = search(regexp, 'nw')
                                  catch
                                    call airline#util#warning(printf('Whitespace: error occurred evaluating "%s"', regexp))
                                    echomsg v:exception
                                    return ''
   29              0.000042       endtry
   29              0.000027     endif
                            
   29              0.000069     let mixed = 0
   29              0.000069     let check = 'indent'
   29              0.000392     if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
   29   0.031378   0.000492       let mixed = s:check_mixed_indent()
   29              0.000072     endif
                            
   29              0.000106     let mixed_file = ''
   29              0.000077     let check = 'mixed-indent-file'
   29              0.000501     if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
   29   0.018048   0.000506       let mixed_file = s:check_mixed_indent_file()
   29              0.000033     endif
                            
   29              0.000068     let long = 0
   29              0.000148     if index(checks, 'long') > -1 && &tw > 0
                                  let long = search('\%>'.&tw.'v.\+', 'nw')
   29              0.000027     endif
                            
   29              0.000094     let conflicts = 0
   29              0.000141     if index(checks, 'conflicts') > -1
   29   0.003265   0.000383       let conflicts = s:conflict_marker()
   29              0.000044     endif
                            
   29              0.000209     if trailing != 0 || mixed != 0 || long != 0 || !empty(mixed_file) || conflicts != 0
   11              0.000046       let b:airline_whitespace_check = s:symbol
   11              0.000039       if strlen(s:symbol) > 0
   11              0.000048         let space = (g:airline_symbols.space)
                                  else
                                    let space = ''
   11              0.000012       endif
                            
   11              0.000022       if s:show_message
   11              0.000020         if trailing != 0
   11              0.000107           let trailing_fmt = get(g:, 'airline#extensions#whitespace#trailing_format', '[%s]trailing')
   11              0.000231           let b:airline_whitespace_check .= space.printf(trailing_fmt, trailing)
   11              0.000015         endif
   11              0.000023         if mixed != 0
                                      let mixed_indent_fmt = get(g:, 'airline#extensions#whitespace#mixed_indent_format', '[%s]mixed-indent')
                                      let b:airline_whitespace_check .= space.printf(mixed_indent_fmt, mixed)
   11              0.000010         endif
   11              0.000018         if long != 0
                                      let long_fmt = get(g:, 'airline#extensions#whitespace#long_format', '[%s]long')
                                      let b:airline_whitespace_check .= space.printf(long_fmt, long)
   11              0.000009         endif
   11              0.000039         if !empty(mixed_file)
                                      let mixed_indent_file_fmt = get(g:, 'airline#extensions#whitespace#mixed_indent_file_format', '[%s]mix-indent-file')
                                      let b:airline_whitespace_check .= space.printf(mixed_indent_file_fmt, mixed_file)
   11              0.000009         endif
   11              0.000021         if conflicts != 0
                                      let conflicts_fmt = get(g:, 'airline#extensions#whitespace#conflicts_format', '[%s]conflicts')
                                      let b:airline_whitespace_check .= space.printf(conflicts_fmt, conflicts)
   11              0.000009         endif
   11              0.000009       endif
   29              0.000024     endif
 1263              0.001175   endif
 1263   0.105738   0.015781   return airline#util#shorten(b:airline_whitespace_check, 120, 9)

FUNCTION  gitgutter#hunk#hunks()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/hunk.vim:10
Called 26 times
Total time:   0.000866
 Self time:   0.000334

count  total (s)   self (s)
   26   0.000789   0.000257   return gitgutter#utility#getbufvar(a:bufnr, 'hunks', [])

FUNCTION  fzf#shellescape()
    Defined: ~/.fzf/plugin/fzf.vim:94
Called 14 times
Total time:   0.000671
 Self time:   0.000535

count  total (s)   self (s)
   14              0.000125   let shell = get(a:000, 0, s:is_win ? 'cmd.exe' : 'sh')
   14              0.000155   if shell =~# 'cmd.exe$'
                                return s:shellesc_cmd(a:arg)
   14              0.000016   endif
   14   0.000276   0.000139   return s:fzf_call('shellescape', a:arg)

FUNCTION  <SNR>85_unc_path()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:169
Called 43 times
Total time:   0.006965
 Self time:   0.000809

count  total (s)   self (s)
   43   0.006922   0.000766   return s:abs_path(a:bufnr, 0) =~ '^\\\\'

FUNCTION  <SNR>50_ShouldForwardNavigationBackToTmux()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-tmux-navigator/plugin/tmux_navigator.vim:86
Called 3 times
Total time:   0.000056
 Self time:   0.000056

count  total (s)   self (s)
    3              0.000026   if g:tmux_navigator_disable_when_zoomed && s:TmuxVimPaneIsZoomed()
                                return 0
    3              0.000003   endif
    3              0.000013   return a:tmux_last_pane || a:at_tab_page_edge

FUNCTION  GetVimIndentIntern()
    Defined: /usr/local/Cellar/neovim/HEAD-40a7427/share/nvim/runtime/indent/vim.vim:36
Called 1 time
Total time:   0.000345
 Self time:   0.000345

count  total (s)   self (s)
                              " Find a non-blank line above the current line.
    1              0.000011   let lnum = prevnonblank(v:lnum - 1)
                            
                              " If the current line doesn't start with '\' or '"\ ' and below a line that
                              " starts with '\' or '"\ ', use the indent of the line above it.
    1              0.000007   let cur_text = getline(v:lnum)
    1              0.000018   if cur_text !~ s:lineContPat
    1              0.000016     while lnum > 0 && getline(lnum) =~ s:lineContPat
                                  let lnum = lnum - 1
    1              0.000003     endwhile
    1              0.000001   endif
                            
                              " At the start of the file use zero indent.
    1              0.000002   if lnum == 0
                                return 0
    1              0.000001   endif
    1              0.000006   let prev_text = getline(lnum)
                            
                              " Add a 'shiftwidth' after :if, :while, :try, :catch, :finally, :function
                              " and :else.  Add it three times for a line that starts with '\' or '"\ '
                              " after a line that doesn't (or g:vim_indent_cont if it exists).
    1              0.000006   let ind = indent(lnum)
    1              0.000013   if cur_text =~ s:lineContPat && v:lnum > 1 && prev_text !~ s:lineContPat
                                if exists("g:vim_indent_cont")
                                  let ind = ind + g:vim_indent_cont
                                else
                                  let ind = ind + shiftwidth() * 3
                                endif
    1              0.000013   elseif prev_text =~ '^\s*aug\%[roup]\s\+' && prev_text !~ '^\s*aug\%[roup]\s\+[eE][nN][dD]\>'
                                let ind = ind + shiftwidth()
    1              0.000001   else
                                " A line starting with :au does not increment/decrement indent.
    1              0.000009     if prev_text !~ '^\s*au\%[tocmd]'
    1              0.000088       let i = match(prev_text, '\(^\||\)\s*\(if\|wh\%[ile]\|for\|try\|cat\%[ch]\|fina\%[lly]\|fu\%[nction]\|el\%[seif]\)\>')
    1              0.000003       if i >= 0
                            	let ind += shiftwidth()
                            	if strpart(prev_text, i, 1) == '|' && has('syntax_items') && synIDattr(synID(lnum, i, 1), "name") =~ '\(Comment\|String\)$'
                            	  let ind -= shiftwidth()
                            	endif
    1              0.000001       endif
    1              0.000001     endif
    1              0.000001   endif
                            
                              " If the previous line contains an "end" after a pipe, but not in an ":au"
                              " command.  And not when there is a backslash before the pipe.
                              " And when syntax HL is enabled avoid a match inside a string.
    1              0.000030   let i = match(prev_text, '[^\\]|\s*\(ene\@!\)')
    1              0.000004   if i > 0 && prev_text !~ '^\s*au\%[tocmd]'
                                if !has('syntax_items') || synIDattr(synID(lnum, i + 2, 1), "name") !~ '\(Comment\|String\)$'
                                  let ind = ind - shiftwidth()
                                endif
    1              0.000001   endif
                            
                            
                              " Subtract a 'shiftwidth' on a :endif, :endwhile, :catch, :finally, :endtry,
                              " :endfun, :else and :augroup END.
    1              0.000020   if cur_text =~ '^\s*\(ene\@!\|cat\|fina\|el\|aug\%[roup]\s\+[eE][nN][dD]\)'
                                let ind = ind - shiftwidth()
    1              0.000001   endif
                            
    1              0.000002   return ind

FUNCTION  <SNR>130_exec_separator()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/autoload/airline/highlighter.vim:182
Called 908 times
Total time:   1.258052
 Self time:   0.068451

count  total (s)   self (s)
  908              0.002667   if pumvisible()
                                return
  908              0.000640   endif
  908              0.005252   let group = a:from.'_to_'.a:to.a:suffix
  908   0.332064   0.009732   let l:from = airline#themes#get_highlight(a:from.a:suffix)
  908   0.369363   0.010106   let l:to = airline#themes#get_highlight(a:to.a:suffix)
  908              0.001618   if a:inverse
  297              0.002154     let colors = [ l:from[1], l:to[1], l:from[3], l:to[3] ]
  611              0.000497   else
  611              0.004306     let colors = [ l:to[1], l:from[1], l:to[3], l:from[3] ]
  908              0.000730   endif
  908              0.011086   let a:dict[group] = colors
  908   0.519346   0.011334   call airline#highlighter#exec(group, colors)

FUNCTION  airline#async#nvim_vcs_untracked()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/autoload/airline/async.vim:336
Called 51 times
Total time:   0.037921
 Self time:   0.036478

count  total (s)   self (s)
   51              0.000690   let cmd = a:cfg.cmd . shellescape(a:file)
   51              0.000138   let id = -1
   51   0.003579   0.002136   let config = { 'buf': '', 'vcs': a:vcs, 'cfg': a:cfg, 'file': a:file, 'cwd': s:valid_dir(fnamemodify(a:file, ':p:h')) }
   51              0.000430   if has("nvim")
   51              0.001689     call extend(config, { 'on_stdout': function('s:nvim_output_handler'), 'on_exit': function('s:nvim_untracked_job_handler')})
   51              0.000378     if has_key(s:untracked_jobs, config.file)
                                  " still running
   41              0.000065       return
   10              0.000010     endif
   10              0.000012     try
   10              0.029442     let id = jobstart(cmd, config)
                                catch
                                  " catch-all, jobstart() failed, fall back to system()
                                  let id=-1
   10              0.000027     endtry
   10              0.000162     let s:untracked_jobs[a:file] = id
   10              0.000017   endif
                              " vim without job feature or nvim jobstart failed
   10              0.000031   if id < 1
                                let output=system(cmd)
                                call s:untracked_output(config, output)
                                call airline#extensions#branch#update_untracked_config(a:file, a:vcs)
   10              0.000012   endif

FUNCTION  fzf_preview#remote#util#is_git_directory()
    Defined: ~/Repos/Configs/Neovim/.config/coc/extensions/node_modules/coc-fzf-preview/autoload/fzf_preview/remote/util.vim:1
Called 1 time
Total time:   0.084354
 Self time:   0.000175

count  total (s)   self (s)
    1   0.084284   0.000104   let git_root = system('git rev-parse --show-toplevel 2>/dev/null')
    1              0.000032   if git_root ==# ''
                                return v:false
    1              0.000004   else
    1              0.000007     return v:true
                              endif

FUNCTION  gitgutter#hunk#increment_lines_modified()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/hunk.vim:34
Called 76 times
Total time:   0.006252
 Self time:   0.001676

count  total (s)   self (s)
   76   0.003282   0.000669   let summary = gitgutter#hunk#summary(a:bufnr)
   76              0.000245   let summary[1] += a:count
   76   0.002641   0.000677   call gitgutter#utility#setbufvar(a:bufnr, 'summary', summary)

FUNCTION  ObsessionStatus()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-obsession/plugin/obsession.vim:102
Called 1275 times
Total time:   0.094785
 Self time:   0.094785

count  total (s)   self (s)
 1275              0.009429   let args = copy(a:000)
 1275              0.012626   let numeric = !empty(v:this_session) + exists('g:this_obsession')
 1275              0.010120   if type(get(args, 0, '')) == type(0)
                                if !remove(args, 0)
                                  return ''
                                endif
 1275              0.001049   endif
 1275              0.004030   if empty(args)
                                let args = ['[$]', '[S]']
 1275              0.001119   endif
 1275              0.005461   if len(args) == 1 && numeric == 1
                                let fmt = args[0]
 1275              0.001240   else
 1275              0.007417     let fmt = get(args, 2-numeric, '')
 1275              0.001316   endif
 1275              0.020341   return substitute(fmt, '%s', get(['', 'Session', 'Obsession'], numeric), 'g')

FUNCTION  <SNR>172_TempReadPre()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-fugitive/autoload/fugitive.vim:2238
Called 5 times
Total time:   0.000622
 Self time:   0.000237

count  total (s)   self (s)
    5   0.000487   0.000102   if has_key(s:temp_files, s:cpath(a:file))
                                let dict = s:temp_files[s:cpath(a:file)]
                                setlocal nomodeline
                                setlocal bufhidden=delete
                                setlocal buftype=nowrite
                                setlocal nomodifiable
                                if len(dict.dir)
                                  let b:git_dir = dict.dir
                                  call extend(b:, {'fugitive_type': 'temp'}, 'keep')
                                endif
    5              0.000005   endif

FUNCTION  <SNR>7_SelectJavascript()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-javascript/ftdetect/javascript.vim:1
Called 7 times
Total time:   0.000192
 Self time:   0.000192

count  total (s)   self (s)
    7              0.000142   if getline(1) =~# '^#!.*/bin/\%(env\s\+\)\?node\>'
                                set ft=javascript
    7              0.000009   endif

FUNCTION  <SNR>146_try_cmd()
    Defined: /usr/local/Cellar/neovim/HEAD-40a7427/share/nvim/runtime/autoload/provider/clipboard.vim:37
Called 4 times
Total time:   4.827523
 Self time:   0.005101

count  total (s)   self (s)
    4   4.827293   0.004871   let out = systemlist(a:cmd, (a:0 ? a:1 : ['']), 1)
    4              0.000048   if v:shell_error
                                if !exists('s:did_error_try_cmd')
                                  echohl WarningMsg
                                  echomsg "clipboard: error: ".(len(out) ? out[0] : v:shell_error)
                                  echohl None
                                  let s:did_error_try_cmd = 1
                                endif
                                return 0
    4              0.000004   endif
    4              0.000014   return out

FUNCTION  <SNR>132_init_buffer()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/autoload/airline/extensions/branch.vim:51
Called 7 times
Total time:   0.000304
 Self time:   0.000304

count  total (s)   self (s)
    7              0.000027   let b:buffer_vcs_config = {}
   21              0.000073   for vcs in keys(s:vcs_config)
   14              0.000116     let b:buffer_vcs_config[vcs] = {     'branch': '',     'untracked': '',     'dirty': 0,   }
   21              0.000027   endfor
    7              0.000018   unlet! b:airline_head

FUNCTION  airline#update_statusline_inactive()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/autoload/airline.vim:156
Called 36 times
Total time:   0.164751
 Self time:   0.003416

count  total (s)   self (s)
   36   0.002077   0.000278   if airline#util#stl_disabled(winnr())
                                return
   36              0.000031   endif
   57              0.000170   for nr in a:range
   21   0.001257   0.000238     if airline#util#stl_disabled(nr)
                                  continue
   21              0.000017     endif
   21              0.000217     call setwinvar(nr, 'airline_active', 0)
   21              0.000210     let context = { 'winnr': nr, 'active': 0, 'bufnr': winbufnr(nr) }
   21              0.000093     if get(g:, 'airline_inactive_alt_sep', 0)
                                  call extend(context, { 'left_sep': g:airline_left_alt_sep, 'right_sep': g:airline_right_alt_sep }, 'keep')
   21              0.000020     endif
   21   0.159172   0.000655     call s:invoke_funcrefs(context, s:inactive_funcrefs)
   57              0.000154   endfor

FUNCTION  <SNR>178_update_target()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-smoothie/autoload/smoothie.vim:159
Called 4 times
Total time:   0.000363
 Self time:   0.000175

count  total (s)   self (s)
    4              0.000033   if g:smoothie_break_on_reverse && s:target_displacement * a:lines < 0
                                call s:stop_moving()
    4              0.000008   else
    4              0.000035     let s:target_displacement += a:lines
    4   0.000240   0.000053     call s:start_moving()
    4              0.000006   endif

FUNCTION  coc#float#nvim_win_enter()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/coc.nvim/autoload/coc/float.vim:1186
Called 20 times
Total time:   0.000382
 Self time:   0.000382

count  total (s)   self (s)
   20              0.000128   let kind = getwinvar(a:winid, 'kind', '')
   20              0.000077   if kind == 'buttons' || kind == 'close'
                                if empty(maparg('<LeftRelease>', 'n'))
                                  nnoremap <buffer><silent> <LeftRelease> :call coc#float#nvim_float_click()<CR>
                                endif
   20              0.000015   endif

FUNCTION  airline#async#vcs_untracked()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/autoload/airline/async.vim:57
Called 51 times
Total time:   0.042868
 Self time:   0.004947

count  total (s)   self (s)
   51              0.000201   if g:airline#init#vim_async
                                " Vim 8 with async support
                                noa call airline#async#vim_vcs_untracked(a:config, a:file)
   51              0.000068   else
                                " nvim async or vim without job-feature
   51   0.041658   0.003737     noa call airline#async#nvim_vcs_untracked(a:config, a:file, a:vcs)
   51              0.000095   endif

FUNCTION  gitgutter#all()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter.vim:3
Called 7 times
Total time:   0.032740
 Self time:   0.004130

count  total (s)   self (s)
    7              0.000054   let visible = tabpagebuflist()
                            
   69              0.000284   for bufnr in range(1, bufnr('$') + 1)
   62              0.000253     if buflisted(bufnr)
   17              0.001340       let file = expand('#'.bufnr.':p')
   17              0.000101       if !empty(file)
   17              0.000114         if index(visible, bufnr) != -1
    5   0.028007   0.000194           call gitgutter#process_buffer(bufnr, a:force)
   12              0.000029         elseif a:force
   12   0.000968   0.000171           call s:reset_tick(bufnr)
   17              0.000034         endif
   17              0.000018       endif
   62              0.000065     endif
   69              0.000129   endfor

FUNCTION  coc#util#jump()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/coc.nvim/autoload/coc/util.vim:181
Called 1 time
Total time:   0.151572
 Self time:   0.002637

count  total (s)   self (s)
    1              0.000032   silent! normal! m'
    1              0.000006   let path = a:filepath
    1              0.000008   if (has('win32unix'))
                                let path = substitute(a:filepath, '\v\\', '/', 'g')
    1              0.000001   endif
    1              0.000122   let file = fnamemodify(path, ":~:.")
    1   0.151330   0.002395   exe a:cmd.' '.fnameescape(file)
    1              0.000012   if !empty(get(a:, 1, []))
    1              0.000011     let line = getline(a:1[0] + 1)
                                " TODO need to use utf16 here
    1              0.000008     let col = byteidx(line, a:1[1]) + 1
    1              0.000003     if col == 0
    1              0.000003       let col = 999
    1              0.000001     endif
    1              0.000007     call cursor(a:1[0] + 1, col)
    1              0.000001   endif
    1              0.000005   if &filetype ==# ''
                                filetype detect
    1              0.000001   endif
    1              0.000002   if s:is_vim
                                redraw
    1              0.000001   endif

FUNCTION  fzf_preview#remote#store#persist_store()
    Defined: ~/Repos/Configs/Neovim/.config/coc/extensions/node_modules/coc-fzf-preview/autoload/fzf_preview/remote/store.vim:3
Called 7 times
Total time:   0.000377
 Self time:   0.000377

count  total (s)   self (s)
    7              0.000204   let s:state[a:module] = a:state

FUNCTION  airline#async#vcs_clean()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/autoload/airline/async.vim:95
Called 51 times
Total time:   0.053532
 Self time:   0.003997

count  total (s)   self (s)
   51              0.000215   if g:airline#init#vim_async
                                " Vim 8 with async support
                                noa call airline#async#vim_vcs_clean(a:cmd, a:file, a:vcs)
   51              0.000332   elseif has("nvim")
                                " nvim async
   51   0.051508   0.001973     noa call airline#async#nvim_vcs_clean(a:cmd, a:file, a:vcs)
                              else
                                " Vim pre 8 using system()
                                call airline#async#vim7_vcs_clean(a:cmd, a:file, a:vcs)
   51              0.000077   endif

FUNCTION  <SNR>150_mru_append()
    Defined: ~/Repos/Configs/Neovim/.config/coc/extensions/node_modules/coc-fzf-preview/plugin/fzf_preview.vim:162
Called 30 times
Total time:   0.185493
 Self time:   0.003993

count  total (s)   self (s)
   30   0.001018   0.000412   if s:enable_file(a:path)
   28   0.184246   0.003351     call fzf_preview#remote#mr#append(a:path, fzf_preview#remote#mr#mru_file_path())
   30              0.000115   endif

FUNCTION  <SNR>48_evaluate_opts()
    Defined: ~/.fzf/plugin/fzf.vim:335
Called 7 times
Total time:   0.000095
 Self time:   0.000095

count  total (s)   self (s)
    7              0.000088   return type(a:options) == type([]) ? join(map(copy(a:options), 'fzf#shellescape(v:val)')) : a:options

FUNCTION  coc#util#clear_pos_matches()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/coc.nvim/autoload/coc/util.vim:945
Called 16 times
Total time:   0.000985
 Self time:   0.000985

count  total (s)   self (s)
   16              0.000204   let winid = get(a:, 1, win_getid())
   16              0.000237   if empty(getwininfo(winid))
                                " not valid
    8              0.000011     return
    8              0.000008   endif
    8              0.000031   if win_getid() == winid
    7              0.000107     let arr = filter(getmatches(), 'v:val["group"] =~# "'.a:match.'"')
    7              0.000026     for item in arr
                                  call matchdelete(item['id'])
    7              0.000015     endfor
    1              0.000003   elseif s:clear_match_by_id
    1              0.000045     let arr = filter(getmatches(winid), 'v:val["group"] =~# "'.a:match.'"')
    3              0.000008     for item in arr
    2              0.000014       call matchdelete(item['id'], winid)
    3              0.000005     endfor
    8              0.000009   endif

FUNCTION  airline#highlighter#highlight()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/autoload/airline/highlighter.vim:236
Called 57 times
Total time:   2.073545
 Self time:   0.270326

count  total (s)   self (s)
   57              0.000413   let bufnr = a:0 ? a:1 : ''
   57              0.000546   let p = g:airline#themes#{g:airline_theme}#palette
                            
                              " draw the base mode, followed by any overrides
   57              0.001307   let mapped = map(a:modes, 'v:val == a:modes[0] ? v:val : a:modes[0]."_".v:val')
   57              0.000359   let suffix = a:modes[0] == 'inactive' ? '_inactive' : ''
   57              0.000228   let airline_grouplist = []
   57              0.002238   let buffers_in_tabpage = sort(tabpagebuflist())
   57              0.000324   if exists("*uniq")
   57              0.000417     let buffers_in_tabpage = uniq(buffers_in_tabpage)
   57              0.000133   endif
                              " mapped might be something like ['normal', 'normal_modified']
                              " if a group is in both modes available, only define the second
                              " that is how this was done previously overwrite the previous definition
  137              0.000560   for mode in reverse(mapped)
   80              0.001100     if exists('g:airline#themes#{g:airline_theme}#palette[mode]')
   57              0.000446       let dict = g:airline#themes#{g:airline_theme}#palette[mode]
 1122              0.005511       for kvp in items(dict)
 1065              0.003616         let mode_colors = kvp[1]
 1065              0.003089         let name = kvp[0]
 1065              0.008293         if name is# 'airline_c' && !empty(bufnr) && suffix is# '_inactive'
   12              0.000054           let name = 'airline_c'.bufnr
 1065              0.001025         endif
                                    " do not re-create highlighting for buffers that are no longer visible
                                    " in the current tabpage
 1065              0.009744         if name =~# 'airline_c\d\+'
  254              0.003066           let bnr = matchstr(name, 'airline_c\zs\d\+') + 0
  254              0.001519           if bnr > 0 && index(buffers_in_tabpage, bnr) == -1
  225              0.000297             continue
   29              0.000028           endif
  811              0.008442         elseif (name =~# '_to_') || (name[0:10] is# 'airline_tab' && !empty(suffix))
                                      " group will be redefined below at exec_separator
                                      " or is not needed for tabline with '_inactive' suffix
                                      " since active flag is 1 for builder)
  360              0.000590           continue
  480              0.000466         endif
  480   0.014504   0.006495         if s:group_not_done(airline_grouplist, name.suffix)
  440   0.264687   0.006630           call airline#highlighter#exec(name.suffix, mode_colors)
  480              0.000533         endif
                            
  480              0.002217         if !has_key(p, 'accents') 
                                      " work around a broken installation
                                      " shouldn't actually happen, p should always contain accents
                                      continue
  480              0.000449         endif
                            
 1440              0.005555         for accent in keys(s:accents)
  960              0.005154           if !has_key(p.accents, accent)
                                        continue
  960              0.000849           endif
  960              0.007394           let colors = copy(mode_colors)
  960              0.004961           if p.accents[accent][0] != ''
  480              0.002527             let colors[0] = p.accents[accent][0]
  960              0.001039           endif
  960              0.005146           if p.accents[accent][2] != ''
  480              0.002325             let colors[2] = p.accents[accent][2]
  960              0.000795           endif
  960              0.004269           if len(colors) >= 5
  952              0.006485             let colors[4] = get(p.accents[accent], 4, '')
    8              0.000007           else
    8              0.000061             call add(colors, get(p.accents[accent], 4, ''))
  960              0.000807           endif
  960   0.036019   0.014718           if s:group_not_done(airline_grouplist, name.suffix.'_'.accent)
  880   0.550571   0.018341             call airline#highlighter#exec(name.suffix.'_'.accent, colors)
  960              0.001390           endif
 1440              0.001605         endfor
  537              0.000568       endfor
                            
   57              0.000263       if empty(s:separators)
                                    " nothing to be done
                                    continue
   57              0.000043       endif
                                  " TODO: optimize this
  741              0.003505       for sep in items(s:separators)
                                    " we cannot check, that the group already exists, else the separators
                                    " might not be correctly defined. But perhaps we can skip above groups
                                    " that match the '_to_' name, because they would be redefined here...
  684   0.995717   0.012095         call <sid>exec_separator(dict, sep[1][0], sep[1][1], sep[1][2], suffix)
  741              0.002507       endfor
   80              0.000075     endif
  137              0.000723   endfor

FUNCTION  coc#rpc#ready()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/coc.nvim/autoload/coc/rpc.vim:31
Called 832 times
Total time:   0.035751
 Self time:   0.035751

count  total (s)   self (s)
  832              0.020519   if empty(s:client) || s:client['running'] == 0
                                return 0
  832              0.001181   endif
  832              0.001903   return 1

FUNCTION  <SNR>175_save_last_seen_change()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:407
Called 26 times
Total time:   0.003506
 Self time:   0.000394

count  total (s)   self (s)
   26   0.003477   0.000365   call gitgutter#utility#setbufvar(a:bufnr, 'tick', getbufvar(a:bufnr, 'changedtick'))

FUNCTION  GetVimIndent()
    Defined: /usr/local/Cellar/neovim/HEAD-40a7427/share/nvim/runtime/indent/vim.vim:24
Called 1 time
Total time:   0.000439
 Self time:   0.000078

count  total (s)   self (s)
    1              0.000016   let ignorecase_save = &ignorecase
    1              0.000003   try
    1   0.000025   0.000021     let &ignorecase = 0
    1   0.000363   0.000017     return GetVimIndentIntern()
    1              0.000002   finally
    1   0.000022   0.000011     let &ignorecase = ignorecase_save
    1              0.000003   endtry

FUNCTION  <SNR>47_on_vimleavepre()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-startify/plugin/startify.vim:52
Called 1 time
Total time:   0.000023
 Self time:   0.000023

count  total (s)   self (s)
    1              0.000012   if get(g:, 'startify_session_persistence') && exists('v:this_session') && filewritable(v:this_session)
                                call startify#session_write(fnameescape(v:this_session))
    1              0.000002   endif

FUNCTION  airline#parts#ffenc()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/autoload/airline/parts.vim:108
Called 1275 times
Total time:   0.060758
 Self time:   0.060758

count  total (s)   self (s)
 1275              0.011077   let expected = get(g:, 'airline#parts#ffenc#skip_expected_string', '')
 1275              0.005559   let bomb     = &l:bomb ? '[BOM]' : ''
 1275              0.018488   let ff       = strlen(&ff) ? '['.&ff.']' : ''
 1275              0.010932   if expected is# &fenc.bomb.ff
                                return ''
 1275              0.001334   else
 1275              0.008002     return &fenc.bomb.ff
                              endif

FUNCTION  gitgutter#utility#shellescape()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:73
Called 214 times
Total time:   0.006617
 Self time:   0.006113

count  total (s)   self (s)
  214              0.003970   if a:arg =~ '^[A-Za-z0-9_/.-]\+$'
  188              0.000778     return a:arg
   26   0.000849   0.000345   elseif s:winshell()
                                return '"' . substitute(substitute(a:arg, '"', '""', 'g'), '%', '"%"', 'g') . '"'
   26              0.000043   else
   26              0.000195     return shellescape(a:arg)
                              endif

FUNCTION  <SNR>142_section_is_empty()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/autoload/airline/builder.vim:182
Called 356 times
Total time:   0.007106
 Self time:   0.007106

count  total (s)   self (s)
  356              0.000854   let start=1
                            
                              " do not check for inactive windows or the tabline
  356              0.000910   if a:self._context.active == 0
  101              0.000131     return 0
  255              0.001687   elseif get(a:self._context, 'tabline', 0)
                                return 0
  255              0.000177   endif
                            
                              " only check, if airline#skip_empty_sections == 1
  255              0.001062   if get(g:, 'airline_skip_empty_sections', 0) == 0
  255              0.000304     return 0
                              endif
                            
                              " only check, if airline#skip_empty_sections == 1
                              if get(w:, 'airline_skip_empty_sections', -1) == 0
                                return 0
                              endif
                              " assume accents sections to be never empty
                              " (avoides, that on startup the mode message becomes empty)
                              if match(a:content, '%#__accent_[^#]*#.*__restore__#') > -1
                                return 0
                              endif
                              if empty(a:content)
                                return 1
                              endif
                              let list=matchlist(a:content, '%{\zs.\{-}\ze}', 1, start)
                              if empty(list)
                                return 0 " no function in statusline text
                              endif
                              while len(list) > 0
                                let expr = list[0]
                                try
                                  " catch all exceptions, just in case
                                  if !empty(eval(expr))
                                    return 0
                                  endif
                                catch
                                  return 0
                                endtry
                                let start += 1
                                let list=matchlist(a:content, '%{\zs.\{-}\ze}', 1, start)
                              endw
                              return 1

FUNCTION  airline#util#ignore_buf()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/autoload/airline/util.vim:136
Called 1367 times
Total time:   0.129977
 Self time:   0.129977

count  total (s)   self (s)
 1367              0.023723   let pat = '\c\v'. get(g:, 'airline#ignore_bufadd_pat', ''). get(g:, 'airline#extensions#tabline#ignore_bufadd_pat',  '!|defx|gundo|nerd_tree|startify|tagbar|term://|undotree|vimfiler')
 1367              0.103579   return match(a:name, pat) > -1

FUNCTION  VMInfos()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-visual-multi/plugin/visual-multi.vim:98
Called 1449 times
Total time:   0.026689
 Self time:   0.026689

count  total (s)   self (s)
 1449              0.017749     if !exists('b:VM_Selection') || empty(b:VM_Selection)
 1449              0.005155         return {}
                                endif
                            
                                let infos = {}
                                let VM = b:VM_Selection
                            
                                let m = g:Vm.mappings_enabled ?    'M' : 'm'
                                let s = VM.Vars.single_region ?    'S' : 's'
                                let l = VM.Vars.multiline ?        'V' : 'v'
                            
                                let infos.current = VM.Vars.index + 1
                                let infos.total = len(VM.Regions)
                                let infos.ratio = infos.current . ' / ' . infos.total
                                let infos.patterns = VM.Vars.search
                                let infos.status = m.s.l
                                return infos

FUNCTION  gitgutter#async#available()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/async.vim:11
Called 43 times
Total time:   0.000273
 Self time:   0.000273

count  total (s)   self (s)
   43              0.000156   return s:available

FUNCTION  <SNR>84_on_bufenter()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-gitgutter/plugin/gitgutter.vim:229
Called 19 times
Total time:   0.089200
 Self time:   0.002742

count  total (s)   self (s)
   19   0.009029   0.000135   call gitgutter#setup_maps()
                            
                              " To keep vim's start-up fast, do not process the buffer when vim is starting.
                              " Instead process it a short time later.  Normally we would rely on our
                              " CursorHold autocommand to handle this but it turns out CursorHold is not
                              " guaranteed to fire if the user has not typed anything yet; so set up a
                              " timer instead.  The disadvantage is that if CursorHold does fire, the
                              " plugin will do a round of unnecessary work; but since there will not have
                              " been any changes to the buffer since the first round, the second round
                              " will be cheap.
   19              0.000123   if has('vim_starting') && !$VIM_GITGUTTER_TEST
                                if exists('*timer_start')
                                  call timer_start(&updatetime, 'GitGutterCursorHold')
                                endif
                                return
   19              0.000013   endif
                            
   19              0.000089   if exists('t:gitgutter_didtabenter') && t:gitgutter_didtabenter
                                let t:gitgutter_didtabenter = 0
                                call gitgutter#all(!g:gitgutter_terminal_reports_focus)
   19              0.000016   else
   19   0.079277   0.001713     call gitgutter#process_buffer(bufnr(''), !g:gitgutter_terminal_reports_focus)
   19              0.000028   endif

FUNCTION  airline#extensions#hunks#get_raw_hunks()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/autoload/airline/extensions/hunks.vim:76
Called 1263 times
Total time:   0.277151
 Self time:   0.087462

count  total (s)   self (s)
 1263              0.014300   if !exists('b:source_func') || get(b:, 'source_func', '') is# 's:get_hunks_empty'
    7              0.000036     if get(g:, 'loaded_signify') && sy#buffer_is_active()
                                  let b:source_func = 's:get_hunks_signify'
    7              0.000036     elseif exists('*GitGutterGetHunkSummary')
    7              0.000023       let b:source_func = 's:get_hunks_gitgutter'
                                elseif exists('*changes#GetStats')
                                  let b:source_func = 's:get_hunks_changes'
                                elseif exists('*quickfixsigns#vcsdiff#GetHunkSummary')
                                  let b:source_func = 'quickfixsigns#vcsdiff#GetHunkSummary'
                                elseif s:coc_git_enabled()
                                  let b:source_func = 's:get_hunks_coc'
                                else
                                  let b:source_func = 's:get_hunks_empty'
    7              0.000006     endif
 1263              0.001238   endif
 1263   0.211293   0.021605   return {b:source_func}()

FUNCTION  gitgutter#diff#parse_hunk()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:217
Called 103 times
Total time:   0.011403
 Self time:   0.011403

count  total (s)   self (s)
  103              0.007709   let matches = matchlist(a:line, s:hunk_re)
  103              0.000369   if len(matches) > 0
  103              0.000510     let from_line  = str2nr(matches[1])
  103              0.000658     let from_count = (matches[2] == '') ? 1 : str2nr(matches[2])
  103              0.000422     let to_line    = str2nr(matches[3])
  103              0.000643     let to_count   = (matches[4] == '') ? 1 : str2nr(matches[4])
  103              0.000461     return [from_line, from_count, to_line, to_count]
                              else
                                return []
                              end

FUNCTION  <SNR>135_check_mixed_indent_file()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/autoload/airline/extensions/whitespace.vim:33
Called 29 times
Total time:   0.017541
 Self time:   0.017541

count  total (s)   self (s)
   29              0.000371   let c_like_langs = get(g:, 'airline#extensions#c_like_langs', [ 'arduino', 'c', 'cpp', 'cuda', 'go', 'javascript', 'ld', 'php' ])
   29              0.000229   if index(c_like_langs, &ft) > -1
                                " for C-like languages: allow /** */ comment style with one space before the '*'
                                let head_spc = '\v(^ +\*@!)'
   29              0.000029   else
   29              0.000077     let head_spc = '\v(^ +)'
   29              0.000027   endif
   29              0.010244   let indent_tabs = search('\v(^\t+)', 'nw')
   29              0.005971   let indent_spc  = search(head_spc, 'nw')
   29              0.000128   if indent_tabs > 0 && indent_spc > 0
                                return printf("%d:%d", indent_tabs, indent_spc)
   29              0.000031   else
   29              0.000045     return ''
                              endif

FUNCTION  <SNR>175_process_modified_and_added()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:320
Called 14 times
Total time:   0.007151
 Self time:   0.007151

count  total (s)   self (s)
   14              0.000039   let offset = 0
   34              0.000079   while offset < a:from_count
   20              0.000063     let line_number = a:to_line + offset
   20              0.000111     call add(a:modifications, [line_number, 'modified'])
   20              0.000043     let offset += 1
   34              0.000042   endwhile
   49              0.000099   while offset < a:to_count
   35              0.000105     let line_number = a:to_line + offset
   35              0.005854     call add(a:modifications, [line_number, 'added'])
   35              0.000409     let offset += 1
   49              0.000054   endwhile

FUNCTION  fzf_preview#remote#resource#project_files#get()
    Defined: ~/Repos/Configs/Neovim/.config/coc/extensions/node_modules/coc-fzf-preview/autoload/fzf_preview/remote/resource/project_files.vim:1
Called 1 time
Total time:   0.090122
 Self time:   0.000439

count  total (s)   self (s)
    1   0.090116   0.000434   return systemlist(a:command)

FUNCTION  airline#util#ignore_next_focusgain()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/autoload/airline/util.vim:195
Called 1283 times
Total time:   0.021552
 Self time:   0.021552

count  total (s)   self (s)
 1283              0.009710   if has('win32')
                                " Setup an ignore for platforms that trigger FocusLost on calls to
                                " system(). macvim (gui and terminal) and Linux terminal vim do not.
                                let s:focusgained_ignore_time = localtime()
 1283              0.001547   endif

FUNCTION  CocActionAsync()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/coc.nvim/plugin/coc.vim:77
Called 190 times
Total time:   0.079914
 Self time:   0.005885

count  total (s)   self (s)
  190   0.079408   0.005378   return s:AsyncRequest(a:name, a:000)

FUNCTION  <SNR>56_AsyncRequest()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/coc.nvim/plugin/coc.vim:107
Called 190 times
Total time:   0.074030
 Self time:   0.016160

count  total (s)   self (s)
  190              0.003921   let Cb = empty(a:args)? v:null : a:args[len(a:args) - 1]
  190              0.001607   if type(Cb) == 2
                                if !coc#rpc#ready()
                                  call Cb('service not started', v:null)
                                else
                                  call coc#rpc#request_async(a:name, a:args[0:-2], Cb)
                                endif
                                return ''
  190              0.000308   endif
  190   0.061523   0.003652   call coc#rpc#notify(a:name, a:args)
  190              0.000486   return ''

FUNCTION  <SNR>48_execute_term()
    Defined: ~/.fzf/plugin/fzf.vim:765
Called 7 times
Total time:   0.475109
 Self time:   0.025094

count  total (s)   self (s)
    7              0.000036   let winrest = winrestcmd()
    7              0.000024   let pbuf = bufnr('')
    7   0.237428   0.000129   let [ppos, winopts, is_popup] = s:split(a:dict)
    7   0.000338   0.000076   call s:use_sh()
    7              0.000020   let b:fzf = a:dict
    7              0.000115   let fzf = { 'buf': bufnr(''), 'pbuf': pbuf, 'ppos': ppos, 'dict': a:dict, 'temps': a:temps, 'winopts': winopts, 'winrest': winrest, 'lines': &lines, 'columns': &columns, 'command': a:command }
    7              0.000028   function! fzf.switch_back(inplace)
                                if a:inplace && bufnr('') == self.buf
                                  if bufexists(self.pbuf)
                                    execute 'keepalt b' self.pbuf
                                  endif
                                  " No other listed buffer
                                  if bufnr('') == self.buf
                                    enew
                                  endif
                                endif
                              endfunction
    7              0.000019   function! fzf.on_exit(id, code, ...)
                                if s:getpos() == self.ppos " {'window': 'enew'}
                                  for [opt, val] in items(self.winopts)
                                    execute 'let' opt '=' val
                                  endfor
                                  call self.switch_back(1)
                                else
                                  if bufnr('') == self.buf
                                    " We use close instead of bd! since Vim does not close the split when
                                    " there's no other listed buffer (nvim +'set nobuflisted')
                                    close
                                  endif
                                  silent! execute 'tabnext' self.ppos.tab
                                  silent! execute self.ppos.win.'wincmd w'
                                endif
                            
                                if bufexists(self.buf)
                                  execute 'bd!' self.buf
                                endif
                            
                                if &lines == self.lines && &columns == self.columns && s:getpos() == self.ppos
                                  execute self.winrest
                                endif
                            
                                if !s:exit_handler(a:code, self.command, 1)
                                  return
                                endif
                            
                                call s:pushd(self.dict)
                                let lines = s:collect(self.temps)
                                call s:callback(self.dict, lines)
                                call self.switch_back(s:getpos() == self.ppos)
                              endfunction
                            
    7              0.000008   try
    7   0.007402   0.000080     call s:pushd(a:dict)
    7              0.000018     if s:is_win
                                  let fzf.temps.batchfile = s:fzf_tempname().'.bat'
                                  call writefile(s:wrap_cmds(a:command), fzf.temps.batchfile)
                                  let command = fzf.temps.batchfile
    7              0.000009     else
    7              0.000034       let command = a:command
    7              0.000009     endif
    7              0.000045     let command .= s:term_marker
    7              0.000050     if has('nvim')
    7   0.027427   0.022263       call termopen(command, fzf)
                                else
                                  let term_opts = {'exit_cb': function(fzf.on_exit)}
                                  if is_popup
                                    let term_opts.hidden = 1
                                  else
                                    let term_opts.curwin = 1
                                  endif
                                  let fzf.buf = term_start([&shell, &shellcmdflag, command], term_opts)
                                  if is_popup && exists('#TerminalWinOpen')
                                    doautocmd <nomodeline> TerminalWinOpen
                                  endif
                                  if !has('patch-8.0.1261') && !s:is_win
                                    call term_wait(fzf.buf, 20)
                                  endif
    7              0.000008     endif
    7              0.000015   finally
    7   0.006922   0.000347     call s:dopopd()
    7              0.000015   endtry
    7   0.000434   0.000394   setlocal nospell bufhidden=wipe nobuflisted nonumber
    7   0.193593   0.000239   setf fzf
    7              0.000011   startinsert
    7              0.000029   return []

FUNCTION  <SNR>175_is_modified_and_added()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:286
Called 14 times
Total time:   0.000099
 Self time:   0.000099

count  total (s)   self (s)
   14              0.000089   return a:from_count > 0 && a:to_count > 0 && a:from_count < a:to_count

FUNCTION  <SNR>172_Tree()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-fugitive/autoload/fugitive.vim:281
Called 1263 times
Total time:   0.225562
 Self time:   0.018600

count  total (s)   self (s)
 1263   0.224426   0.017464   return a:0 ? FugitiveWorkTree(a:1) : FugitiveWorkTree()

FUNCTION  airline#parts#paste()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/autoload/airline/parts.vim:63
Called 1263 times
Total time:   0.010514
 Self time:   0.010514

count  total (s)   self (s)
 1263              0.009264   return g:airline_detect_paste && &paste ? g:airline_symbols.paste : ''

FUNCTION  coc#util#check_refresh()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/coc.nvim/autoload/coc/util.vim:109
Called 1 time
Total time:   0.000102
 Self time:   0.000102

count  total (s)   self (s)
    1              0.000023   if !bufloaded(a:bufnr)
                                return 0
    1              0.000004   endif
    1              0.000016   if getbufvar(a:bufnr, 'coc_diagnostic_disable', 0)
                                return 0
    1              0.000002   endif
    1              0.000015   if get(g: , 'EasyMotion_loaded', 0)
                                return EasyMotion#is_active() != 1
    1              0.000003   endif
    1              0.000006   return 1

FUNCTION  <SNR>48_use_sh()
    Defined: ~/.fzf/plugin/fzf.vim:401
Called 14 times
Total time:   0.000684
 Self time:   0.000661

count  total (s)   self (s)
   14              0.000191   let [shell, shellslash, shellcmdflag, shellxquote] = [&shell, &shellslash, &shellcmdflag, &shellxquote]
   14              0.000024   if s:is_win
                                set shell=cmd.exe
                                set noshellslash
                                let &shellcmdflag = has('nvim') ? '/s /c' : '/c'
                                let &shellxquote = has('nvim') ? '"' : '('
   14              0.000013   else
   14   0.000204   0.000181     set shell=sh
   14              0.000016   endif
   14              0.000082   return [shell, shellslash, shellcmdflag, shellxquote]

FUNCTION  airline#update_statusline()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/autoload/airline.vim:127
Called 36 times
Total time:   0.680623
 Self time:   0.005006

count  total (s)   self (s)
   36   0.002539   0.000468   if airline#util#stl_disabled(winnr())
                                return
   36              0.000047   endif
   36              0.000851   let range = filter(range(1, winnr('$')), 'v:val != winnr()')
                              " create inactive statusline
   36   0.165101   0.000350   call airline#update_statusline_inactive(range)
                            
   36              0.000145   unlet! w:airline_render_left w:airline_render_right
   36              0.001309   exe 'unlet! ' 'w:airline_section_'. join(s:sections, ' w:airline_section_')
                            
                              " Now create the active statusline
   36              0.000113   let w:airline_active = 1
   36              0.000342   let context = { 'winnr': winnr(), 'active': 1, 'bufnr': winbufnr(winnr()) }
   36   0.509878   0.001083   call s:invoke_funcrefs(context, g:airline_statusline_funcrefs)

FUNCTION  airline#parts#readonly()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/autoload/airline/parts.vim:89
Called 1463 times
Total time:   0.199206
 Self time:   0.069230

count  total (s)   self (s)
                              " only consider regular buffers (e.g. ones that represent actual files,
                              " but not special ones like e.g. NERDTree)
 1463   0.166990   0.037014   if !empty(&buftype) || airline#util#ignore_buf(bufname('%'))
   96              0.000186     return ''
 1367              0.001732   endif
 1367              0.009115   if &readonly && !filereadable(bufname('%'))
                                return '[noperm]'
 1367              0.001656   else
 1367              0.005856     return &readonly ? g:airline_symbols.readonly : ''
                              endif

FUNCTION  fugitive#Head()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-fugitive/autoload/fugitive.vim:497
Called 1263 times
Total time:   1.328073
 Self time:   0.235787

count  total (s)   self (s)
 1263              0.009267   let dir = a:0 > 1 ? a:2 : s:Dir()
 1263              0.004629   if empty(dir)
                                return ''
 1263              0.001147   endif
 1263   1.115788   0.023502   let file = fugitive#Find('.git/HEAD', dir)
 1263              0.049531   let ftime = getftime(file)
 1263              0.004310   if ftime == -1
                                return ''
 1263              0.013346   elseif ftime != get(s:head_cache, dir, [-1])[0]
    5              0.000573     let s:head_cache[dir] = [ftime, readfile(file)[0]]
 1263              0.001616   endif
 1263              0.009321   let head = s:head_cache[dir][1]
 1263              0.069787   if head =~# '^ref: '
 1263              0.031570     return substitute(head, '\C^ref: \%(refs/\%(heads/\|remotes/\|tags/\)\=\)\=', '', '')
                              elseif head =~# '^\x\{40,\}$'
                                let len = a:0 ? a:1 : 0
                                return len < 0 ? head : len ? head[0:len-1] : ''
                              else
                                return ''
                              endif

FUNCTION  <SNR>96_surroundings()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-commentary/plugin/commentary.vim:11
Called 6 times
Total time:   0.000422
 Self time:   0.000422

count  total (s)   self (s)
    6              0.000392   return split(get(b:, 'commentary_format', substitute(substitute(substitute( &commentstring, '^$', '%s', ''), '\S\zs%s',' %s', '') ,'%s\ze\S', '%s ', '')), '%s', 1)

FUNCTION  airline#extensions#obsession#get_status()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/autoload/airline/extensions/obsession.vim:21
Called 1275 times
Total time:   0.120613
 Self time:   0.025828

count  total (s)   self (s)
 1275   0.119278   0.024492   return ObsessionStatus((g:airline#extensions#obsession#indicator_text . s:spc), '')

FUNCTION  <SNR>178_compute_velocity()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-smoothie/autoload/smoothie.vim:119
Called 64 times
Total time:   0.000997
 Self time:   0.000997

count  total (s)   self (s)
   64              0.000788   return g:smoothie_base_speed * (s:target_displacement + s:subline_position)

FUNCTION  lens#get_cols()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/lens.vim/plugin/lens.vim:104
Called 13 times
Total time:   0.003554
 Self time:   0.002493

count  total (s)   self (s)
   13   0.003535   0.002474   return max(map(getline(line("w0"),line("w$")), {k,v->len(v)}))

FUNCTION  gitgutter#utility#setbufvar()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:9
Called 248 times
Total time:   0.010082
 Self time:   0.010082

count  total (s)   self (s)
  248              0.000867   let buffer = +a:buffer
                              " Default value for getbufvar() was introduced in Vim 7.3.831.
  248              0.001386   let ggvars = getbufvar(buffer, 'gitgutter')
  248              0.001294   if type(ggvars) == type('')
    7              0.000017     unlet ggvars
    7              0.000021     let ggvars = {}
    7              0.000041     call setbufvar(buffer, 'gitgutter', ggvars)
  248              0.000240   endif
  248              0.001393   let ggvars[a:varname] = a:val

FUNCTION  <SNR>48_getpos()
    Defined: ~/.fzf/plugin/fzf.vim:690
Called 25 times
Total time:   0.000500
 Self time:   0.000500

count  total (s)   self (s)
   25              0.000466   return {'tab': tabpagenr(), 'win': winnr(), 'winid': win_getid(), 'cnt': winnr('$'), 'tcnt': tabpagenr('$')}

FUNCTION  <SNR>161_Initialised()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vimspector/autoload/vimspector.vim:32
Called 16 times
Total time:   0.000141
 Self time:   0.000141

count  total (s)   self (s)
   16              0.000114   return s:enabled != v:null

FUNCTION  lens#get_size()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/lens.vim/plugin/lens.vim:77
Called 26 times
Total time:   0.000317
 Self time:   0.000317

count  total (s)   self (s)
   26              0.000087   if a:current > a:target
   15              0.000028     return a:current
   11              0.000011   endif
   11              0.000129   return max([ a:current, min([ max([a:target, a:resize_min]), a:resize_max, ]) ])

FUNCTION  39()
    Defined: ~/.fzf/plugin/fzf.vim:785
Called 1 time
Total time:   0.251842
 Self time:   0.001120

count  total (s)   self (s)
    1   0.000043   0.000022     if s:getpos() == self.ppos " {'window': 'enew'}
                                  for [opt, val] in items(self.winopts)
                                    execute 'let' opt '=' val
                                  endfor
                                  call self.switch_back(1)
    1              0.000001     else
    1              0.000005       if bufnr('') == self.buf
                                    " We use close instead of bd! since Vim does not close the split when
                                    " there's no other listed buffer (nvim +'set nobuflisted')
    1   0.030546   0.000845         close
    1              0.000004       endif
    1              0.000014       silent! execute 'tabnext' self.ppos.tab
    1              0.000010       silent! execute self.ppos.win.'wincmd w'
    1              0.000001     endif
                            
    1              0.000006     if bufexists(self.buf)
                                  execute 'bd!' self.buf
    1              0.000001     endif
                            
    1   0.000050   0.000029     if &lines == self.lines && &columns == self.columns && s:getpos() == self.ppos
    1              0.000011       execute self.winrest
    1              0.000001     endif
                            
    1   0.000054   0.000017     if !s:exit_handler(a:code, self.command, 1)
                                  return
    1              0.000001     endif
                            
    1   0.000800   0.000012     call s:pushd(self.dict)
    1   0.020107   0.000023     let lines = s:collect(self.temps)
    1   0.200067   0.000045     call s:callback(self.dict, lines)
    1   0.000079   0.000031     call self.switch_back(s:getpos() == self.ppos)

FUNCTION  <SNR>19_SynSet()
    Defined: /usr/local/Cellar/neovim/HEAD-40a7427/share/nvim/runtime/syntax/synload.vim:33
Called 13 times
Total time:   0.412337
 Self time:   0.231692

count  total (s)   self (s)
                              " clear syntax for :set syntax=OFF  and any syntax name that doesn't exist
   13              0.000349   syn clear
   13              0.000078   if exists("b:current_syntax")
                                unlet b:current_syntax
   13              0.000014   endif
                            
   13              0.000088   let s = expand("<amatch>")
   13              0.000044   if s == "ON"
                                " :set syntax=ON
                                if &filetype == ""
                                  echohl ErrorMsg
                                  echo "filetype unknown"
                                  echohl None
                                endif
                                let s = &filetype
   13              0.000034   elseif s == "OFF"
                                let s = ""
   13              0.000010   endif
                            
   13              0.000028   if s != ""
                                " Load the syntax file(s).  When there are several, separated by dots,
                                " load each in sequence.
   26              0.000207     for name in split(s, '\.')
   13   0.410970   0.230325       exe "runtime! syntax/" . name . ".vim syntax/" . name . "/*.vim"
   26              0.000086     endfor
   13              0.000019   endif

FUNCTION  <SNR>59_request()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/coc.nvim/autoload/coc/client.vim:148
Called 12 times
Total time:   2.235478
 Self time:   0.587313

count  total (s)   self (s)
   12   0.000375   0.000205   let channel = coc#client#get_channel(self)
   12              0.000093   if empty(channel) | return '' | endif
   12              0.000023   try
   12              0.000027     if s:is_vim
                                  let res = ch_evalexpr(channel, [a:method, a:args], {'timeout': 60 * 1000})
                                  if type(res) == 1 && res ==# ''
                                    throw 'request '.a:method. ' '.string(a:args).' timeout after 60s'
                                  endif
                                  let [l:errmsg, res] =  res
                                  if !empty(l:errmsg)
                                    throw l:errmsg
                                  else
                                    return res
                                  endif
   12              0.000016     else
   12   1.460621   0.953163       return call('rpcrequest', [channel, a:method] + a:args)
                                endif
                              catch /.*/
                                if v:exception =~# 'E475'
                                  if get(g:, 'coc_vim_leaving', 0) | return | endif
                                  echohl Error | echom '['.self.name.'] server connection lost' | echohl None
                                  let name = self.name
                                  call s:on_exit(name, 0)
                                  execute 'silent do User ConnectionLost'.toupper(name[0]).name[1:]
                                elseif v:exception =~# 'E12'
                                  " neovim's bug, ignore it
                                else
                                  echohl Error | echo 'Error on request ('.a:method.'): '.v:exception | echohl None
                                endif
   12              0.000053   endtry

FUNCTION  fzf_preview#remote#window#set_resource_command_name()
    Defined: ~/Repos/Configs/Neovim/.config/coc/extensions/node_modules/coc-fzf-preview/autoload/fzf_preview/remote/window.vim:4
Called 7 times
Total time:   0.000122
 Self time:   0.000122

count  total (s)   self (s)
    7              0.000101   let s:resource_command_name = a:command_name

FUNCTION  ShowDocIfNoDiagnostic()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugin-coc-diagnostic.vim:1
Called 92 times
Total time:   0.055925
 Self time:   0.006693

count  total (s)   self (s)
   92   0.015484   0.003955   if (coc#float#has_float() == 0)
   92   0.039665   0.001962     silent call CocActionAsync('doHover')
   92              0.000176   endif

FUNCTION  <SNR>150_enable_file()
    Defined: ~/Repos/Configs/Neovim/.config/coc/extensions/node_modules/coc-fzf-preview/plugin/fzf_preview.vim:174
Called 34 times
Total time:   0.000800
 Self time:   0.000800

count  total (s)   self (s)
   34              0.000471   if bufnr('%') != expand('<abuf>') || a:path == ''
    2              0.000004     return v:false
   32              0.000045   else
   32              0.000089     return v:true
                              endif

FUNCTION  airline#builder#should_change_group()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/autoload/airline/builder.vim:130
Called 207 times
Total time:   0.145161
 Self time:   0.007937

count  total (s)   self (s)
  207              0.000709   if a:group1 == a:group2
                                return 0
  207              0.000152   endif
  207   0.077438   0.002468   let color1 = airline#highlighter#get_highlight(a:group1)
  207   0.064608   0.002355   let color2 = airline#highlighter#get_highlight(a:group2)
  207              0.001595   return color1[1] != color2[1] || color1[0] != color2[0] ||  color1[2] != color2[2] || color1[3] != color2[3]

FUNCTION  fzf_preview#remote#window#set_fzf_last_query()
    Defined: ~/Repos/Configs/Neovim/.config/coc/extensions/node_modules/coc-fzf-preview/autoload/fzf_preview/remote/window.vim:8
Called 863 times
Total time:   0.153096
 Self time:   0.153096

count  total (s)   self (s)
  863              0.032236   if &filetype ==# 'fzf' && s:resource_command_name !=# ''
  856              0.045735     let matches = matchlist(getline('.'), '^\w\+\>.\(\(\w\|\s\|''\)\+\)')
  856              0.008703     if len(matches) > 0
                                  let query = substitute(substitute(matches[1], '\s\+$', '', ''), '^\s\+', '', '')
                                  if exists(':FzfPreviewRemoteEnvironment')
                                    call FzfPreviewDispatchResumeQuery(s:resource_command_name, query)
                                  else
                                    call CocAction('runCommand', 'fzf-preview-function.DispatchResumeQuery', [s:resource_command_name, query])
                                  endif
  856              0.001326     endif
                            
  856              0.017072     call timer_start(50, function('fzf_preview#remote#window#set_fzf_last_query'))
  863              0.001953   endif

FUNCTION  <SNR>178_stop_moving()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-smoothie/autoload/smoothie.vim:104
Called 4 times
Total time:   0.000198
 Self time:   0.000198

count  total (s)   self (s)
    4              0.000038   let s:target_displacement = 0
    4              0.000027   let s:subline_position = 0.0
    4              0.000043   if exists('s:timer_id')
    4              0.000037     call timer_stop(s:timer_id)
    4              0.000022     unlet s:timer_id
    4              0.000010   endif

FUNCTION  fzf_preview#remote#runner#fzf_run()
    Defined: ~/Repos/Configs/Neovim/.config/coc/extensions/node_modules/coc-fzf-preview/autoload/fzf_preview/remote/runner.vim:1
Called 7 times
Total time:   0.632510
 Self time:   0.000917

count  total (s)   self (s)
    7              0.000130   let source = a:params['source']
    7              0.000034   let options = a:params['options']
    7              0.000023   let handler = a:params['handler']
    7              0.000024   let env = a:params['environment']
                            
    7              0.000027   if env ==# 'remote'
                                let Sink = function('s:handler_wrapper', [handler])
    7              0.000021   elseif env ==# 'coc'
    7              0.000097     let Sink = function('s:coc_handler')
    7              0.000011   endif
                            
    7              0.000095   let window = g:fzf_preview_direct_window_option !=# '' ? g:fzf_preview_direct_window_option : { 'width': g:fzf_preview_floating_window_rate, 'height': g:fzf_preview_floating_window_rate }
                            
    7   0.631919   0.000326   call fzf#run({ 'source':  source, 'sink*':   Sink, 'options': options, 'window':  window, })

FUNCTION  <SNR>78_on_window_changed()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/plugin/airline.vim:59
Called 59 times
Total time:   0.594801
 Self time:   0.006016

count  total (s)   self (s)
                              " don't trigger for Vim popup windows
   59              0.000342   if &buftype is# 'popup'
                                return
   59              0.000054   endif
                            
   59              0.000300   if pumvisible() && (!&previewwindow || g:airline_exclude_preview)
                                " do not trigger for previewwindows
                                return
   59              0.000044   endif
   59              0.000354   let s:active_winnr = winnr()
                              " Handle each window only once, since we might come here several times for
                              " different autocommands.
   59              0.001002   let l:key = [bufnr('%'), s:active_winnr, winnr('$'), tabpagenr(), &ft]
   59              0.001134   if get(g:, 'airline_last_window_changed', []) == l:key && &stl is# '%!airline#statusline('.s:active_winnr.')' && &ft !~? 'gitcommit'
                                " fugitive is special, it changes names and filetypes several times,
                                " make sure the caching does not get into its way
   25              0.000046     return
   34              0.000026   endif
   34              0.000963   let g:airline_last_window_changed = l:key
   34   0.000496   0.000313   call s:init()
   34   0.589238   0.000635   call airline#update_statusline()

FUNCTION  <SNR>178_start_moving()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-smoothie/autoload/smoothie.vim:95
Called 4 times
Total time:   0.000188
 Self time:   0.000188

count  total (s)   self (s)
    4              0.000035   if !exists('s:timer_id')
    4              0.000132     let s:timer_id = timer_start(g:smoothie_update_interval, function("s:movement_tick"), {'repeat': -1})
    4              0.000009   endif

FUNCTION  airline#extensions#fzf#inactive_apply()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/autoload/airline/extensions/fzf.vim:37
Called 21 times
Total time:   0.000494
 Self time:   0.000494

count  total (s)   self (s)
   21              0.000217   if getbufvar(a:2.bufnr, '&filetype') ==# 'fzf'
                                let spc = g:airline_symbols.space
                                call a:1.add_section('airline_a', spc.'FZF'.spc)
                                call a:1.add_section('airline_c', '')
                                return 1
   21              0.000018   endif

FUNCTION  57()
    Defined: ~/.fzf/plugin/fzf.vim:785
Called 1 time
Total time:   0.420901
 Self time:   0.004251

count  total (s)   self (s)
    1   0.000049   0.000025     if s:getpos() == self.ppos " {'window': 'enew'}
                                  for [opt, val] in items(self.winopts)
                                    execute 'let' opt '=' val
                                  endfor
                                  call self.switch_back(1)
    1              0.000001     else
    1              0.000006       if bufnr('') == self.buf
                                    " We use close instead of bd! since Vim does not close the split when
                                    " there's no other listed buffer (nvim +'set nobuflisted')
    1   0.039703   0.003867         close
    1              0.000004       endif
    1              0.000015       silent! execute 'tabnext' self.ppos.tab
    1              0.000010       silent! execute self.ppos.win.'wincmd w'
    1              0.000001     endif
                            
    1              0.000007     if bufexists(self.buf)
                                  execute 'bd!' self.buf
    1              0.000003     endif
                            
    1   0.000062   0.000038     if &lines == self.lines && &columns == self.columns && s:getpos() == self.ppos
    1              0.000012       execute self.winrest
    1              0.000001     endif
                            
    1   0.000060   0.000020     if !s:exit_handler(a:code, self.command, 1)
                                  return
    1              0.000001     endif
                            
    1   0.000726   0.000014     call s:pushd(self.dict)
    1   0.012752   0.000047     let lines = s:collect(self.temps)
    1   0.367298   0.000048     call s:callback(self.dict, lines)
    1   0.000116   0.000056     call self.switch_back(s:getpos() == self.ppos)

FUNCTION  <SNR>142_get_seperator()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/autoload/airline/builder.vim:155
Called 207 times
Total time:   0.385483
 Self time:   0.004950

count  total (s)   self (s)
  207   0.147324   0.002163   if airline#builder#should_change_group(a:prev_group, a:group)
  182   0.237631   0.002259     return s:get_transitioned_seperator(a:self, a:prev_group, a:group, a:side)
   25              0.000022   else
   25              0.000122     return a:side ? a:self._context.left_alt_sep : a:self._context.right_alt_sep
                              endif

FUNCTION  <SNR>85_abs_path()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:200
Called 345 times
Total time:   0.061030
 Self time:   0.061030

count  total (s)   self (s)
  345              0.043614   let p = resolve(expand('#'.a:bufnr.':p'))
                            
                              " Remove extra parts from fugitive's filepaths
  345              0.011479   let p = substitute(substitute(p, '^fugitive:', '', ''), '\v\.git/\x{40,}/', '', '')
                            
  345              0.003900   return a:shellesc ? gitgutter#utility#shellescape(p) : p

FUNCTION  coc#float#close_related()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/coc.nvim/autoload/coc/float.vim:830
Called 8 times
Total time:   0.000978
 Self time:   0.000740

count  total (s)   self (s)
    8   0.000390   0.000153   if !coc#float#valid(a:winid)
                                return
    8              0.000007   endif
    8              0.000068   let kind = get(a:, 1, '')
    8              0.000060   let winids = getwinvar(a:winid, 'related', [])
    8              0.000034   for id in winids
                                if s:is_vim
                                  " vim doesn't throw
                                  call popup_close(id)
                                elseif nvim_win_is_valid(id)
                                  if empty(kind) || getwinvar(id, 'kind', '') ==# kind
                                    noa call nvim_win_close(id, 1)
                                  endif
                                endif
    8              0.000024   endfor

FUNCTION  <SNR>48_callback()
    Defined: ~/.fzf/plugin/fzf.vim:865
Called 4 times
Total time:   1.217976
 Self time:   0.000619

count  total (s)   self (s)
    4              0.000060   let popd = has_key(a:dict, 'pushd')
    4              0.000013   if popd
    4              0.000022     let w:fzf_pushd = a:dict.pushd
    4              0.000006   endif
                            
    4              0.000006   try
    4              0.000020     if has_key(a:dict, 'sink')
                                  for line in a:lines
                                    if type(a:dict.sink) == 2
                                      call a:dict.sink(line)
                                    else
                                      execute a:dict.sink s:escape(line)
                                    endif
                                  endfor
    4              0.000014     endif
    4              0.000022     if has_key(a:dict, 'sink*')
    4   1.212900   0.000104       call a:dict['sink*'](a:lines)
    4              0.000007     endif
                              catch
                                if stridx(v:exception, ':E325:') < 0
                                  echoerr v:exception
                                endif
    4              0.000005   endtry
                            
                              " We may have opened a new window or tab
    4              0.000010   if popd
    4              0.000035     let w:fzf_pushd = a:dict.pushd
    4   0.004650   0.000089     call s:dopopd()
    4              0.000005   endif

FUNCTION  <SNR>16_LoadFTPlugin()
    Defined: /usr/local/Cellar/neovim/HEAD-40a7427/share/nvim/runtime/ftplugin.vim:14
Called 13 times
Total time:   0.180754
 Self time:   0.170418

count  total (s)   self (s)
   13              0.000183     if exists("b:undo_ftplugin")
                                  exe b:undo_ftplugin
                                  unlet! b:undo_ftplugin b:did_ftplugin
   13              0.000018     endif
                            
   13              0.000142     let s = expand("<amatch>")
   13              0.000054     if s != ""
   13              0.000236       if &cpo =~# "S" && exists("b:did_ftplugin")
                            	" In compatible mode options are reset to the global values, need to
                            	" set the local values also when a plugin was already used.
                            	unlet b:did_ftplugin
   13              0.000016       endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "aaa" and then "bbb".
   26              0.000241       for name in split(s, '\.')
   13   0.179356   0.169019 	exe 'runtime! ftplugin/' . name . '.vim ftplugin/' . name . '_*.vim ftplugin/' . name . '/*.vim'
   26              0.000105       endfor
   13              0.000022     endif

FUNCTION  fugitive#ReloadStatus()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-fugitive/autoload/fugitive.vim:2914
Called 4 times
Total time:   0.001709
 Self time:   0.000447

count  total (s)   self (s)
    4   0.001322   0.000119   call s:ExpireStatus(a:0 ? a:1 : -1)
    4              0.000049   if a:0 > 1 ? a:2 : 1
                                let t = reltime()
                                let t:fugitive_reload_status = t
                                for tabnr in exists('*settabvar') ? range(1, tabpagenr('$')) : []
                                  call settabvar(tabnr, 'fugitive_reload_status', t)
                                endfor
                                call s:ReloadTabStatus()
                                exe s:DoAutocmdChanged(a:0 ? a:1 : -1)
    4              0.000007   else
    4   0.000122   0.000063     call s:ReloadWinStatus()
    4              0.000007   endif
    4              0.000009   return ''

FUNCTION  <SNR>78_airline_refresh()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/plugin/airline.vim:220
Called 2 times
Total time:   0.273687
 Self time:   0.016677

count  total (s)   self (s)
                              " a:1, fast refresh, do not reload the theme
    2              0.000098   let fast=!empty(get(a:000, 0, 0))
    2              0.011956   if !exists("#airline")
                                " disabled
                                return
    2              0.000005   endif
    2   0.088317   0.000101   call airline#util#doautocmd('AirlineBeforeRefresh')
    2   0.076973   0.000229   call airline#highlighter#reset_hlcache()
    2              0.000024   if !fast
                                call airline#load_theme()
    2              0.000004   endif
    2   0.092108   0.000088   call airline#update_statusline()
    2   0.000070   0.000040   call airline#update_tabline()

FUNCTION  gitgutter#utility#repo_path()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:112
Called 180 times
Total time:   0.011647
 Self time:   0.004998

count  total (s)   self (s)
  180   0.009135   0.003087   let p = gitgutter#utility#getbufvar(a:bufnr, 'path', '')
  180   0.002213   0.001612   return a:shellesc ? gitgutter#utility#shellescape(p) : p

FUNCTION  <SNR>58_variables()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/coc.nvim/autoload/coc/util.vim:275
Called 14 times
Total time:   0.005858
 Self time:   0.005858

count  total (s)   self (s)
   14              0.002157   let info = getbufinfo({'bufnr':a:bufnr, 'variables': 1})
   14              0.000380   let variables = copy(info[0]['variables'])
  279              0.000642   for key in keys(variables)
  265              0.001074     if key !~# '\v^coc'
  265              0.000860       unlet variables[key]
  265              0.000222     endif
  279              0.000233   endfor
   14              0.000035   return variables

FUNCTION  <SNR>48_exit_handler()
    Defined: ~/.fzf/plugin/fzf.vim:583
Called 7 times
Total time:   0.000174
 Self time:   0.000174

count  total (s)   self (s)
    7              0.000023   if a:code == 130
    3              0.000004     return 0
    4              0.000034   elseif has('nvim') && a:code == 129
                                " When deleting the terminal buffer while fzf is still running,
                                " Nvim sends SIGHUP.
                                return 0
    4              0.000009   elseif a:code > 1
                                call s:error('Error running ' . a:command)
                                if !empty(a:000)
                                  sleep
                                endif
                                return 0
    4              0.000004   endif
    4              0.000006   return 1

FUNCTION  coc#util#clear_highlights()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/coc.nvim/autoload/coc/util.vim:989
Called 110 times
Total time:   0.009108
 Self time:   0.009108

count  total (s)   self (s)
  110              0.001283     let winid = get(a:, 1, win_getid())
  110              0.002241     if empty(getwininfo(winid))
                                  " not valid
                                  return
  110              0.000130     endif
  110              0.000377     if winid == win_getid()
  110              0.001601       let arr = filter(getmatches(), 'v:val["group"] =~# "^CocHighlight"')
  110              0.000362       for item in arr
                                    call matchdelete(item['id'])
  110              0.000216       endfor
                                elseif s:clear_match_by_id
                                  let arr = filter(getmatches(winid), 'v:val["group"] =~# "^CocHighlight"')
                                  for item in arr
                                    call matchdelete(item['id'], winid)
                                  endfor
  110              0.000097     endif

FUNCTION  <SNR>85_dir()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:209
Called 145 times
Total time:   0.030422
 Self time:   0.005140

count  total (s)   self (s)
  145   0.030252   0.004970   return gitgutter#utility#shellescape(fnamemodify(s:abs_path(a:bufnr, 0), ':h'))

FUNCTION  <SNR>56_SyncAutocmd()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/coc.nvim/plugin/coc.vim:224
Called 4 times
Total time:   0.259289
 Self time:   0.000287

count  total (s)   self (s)
    4              0.000055   if !g:coc_workspace_initialized
                                return
    4              0.000010   endif
    4              0.000018   if g:coc_service_initialized
    4   0.259110   0.000109     call coc#rpc#request('CocAutocmd', a:000)
                              else
                                call coc#rpc#notify('CocAutocmd', a:000)
    4              0.000007   endif

FUNCTION  <SNR>174_reset_summary()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/hunk.vim:24
Called 26 times
Total time:   0.001322
 Self time:   0.000434

count  total (s)   self (s)
   26   0.001299   0.000411   call gitgutter#utility#setbufvar(a:bufnr, 'summary', [0,0,0])

FUNCTION  gitgutter#utility#windows()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:231
Called 43 times
Total time:   0.001149
 Self time:   0.001149

count  total (s)   self (s)
   43              0.000947   return has('win64') || has('win32') || has('win16')

FUNCTION  airline#parts#spell()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/autoload/airline/parts.vim:67
Called 1263 times
Total time:   0.077414
 Self time:   0.077414

count  total (s)   self (s)
 1263              0.033894   let spelllang = g:airline_detect_spelllang ? printf(" [%s]", toupper(substitute(&spelllang, ',', '/', 'g'))) : ''
 1263              0.007169   if g:airline_detect_spell && &spell
                                let winwidth = airline#util#winwidth()
                                if winwidth >= 90
                                  return g:airline_symbols.spell . spelllang
                                elseif winwidth >= 70
                                  return g:airline_symbols.spell
                                else
                                  return split(g:airline_symbols.spell, '\zs')[0]
                                endif
 1263              0.001236   endif
 1263              0.002390   return ''

FUNCTION  gitgutter#hunk#summary()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/hunk.vim:20
Called 1361 times
Total time:   0.067100
 Self time:   0.026223

count  total (s)   self (s)
 1361   0.065478   0.024600   return gitgutter#utility#getbufvar(a:bufnr, 'summary', [0,0,0])

FUNCTION  <SNR>173_set_clean_jobs_variable()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/autoload/airline/async.vim:80
Called 10 times
Total time:   0.000510
 Self time:   0.000510

count  total (s)   self (s)
   10              0.000180   if !has_key(s:clean_jobs, a:vcs)
                                let s:clean_jobs[a:vcs] = {}
   10              0.000024   endif
   10              0.000156   let s:clean_jobs[a:vcs][a:file]=a:id

FUNCTION  <SNR>48_fzf_tempname()
    Defined: ~/.fzf/plugin/fzf.vim:114
Called 14 times
Total time:   0.000285
 Self time:   0.000159

count  total (s)   self (s)
   14   0.000270   0.000145   return s:fzf_call('tempname')

FUNCTION  <SNR>85_strip_trailing_new_line()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:227
Called 5 times
Total time:   0.003150
 Self time:   0.003150

count  total (s)   self (s)
    5              0.003143   return substitute(a:line, '[[:cntrl:]]$', '', '')

FUNCTION  <SNR>50_VimNavigate()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-tmux-navigator/plugin/tmux_navigator.vim:10
Called 3 times
Total time:   0.120799
 Self time:   0.000301

count  total (s)   self (s)
    3              0.000006   try
    3   0.120757   0.000258     execute 'wincmd ' . a:direction
                              catch
                                echohl ErrorMsg | echo 'E11: Invalid in command-line window; <CR> executes, CTRL-C quits: wincmd k' | echohl None
    3              0.000004   endtry

FUNCTION  <SNR>99_SetupPasta()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-pasta/plugin/pasta.vim:42
Called 13 times
Total time:   0.000297
 Self time:   0.000297

count  total (s)   self (s)
   13              0.000094   if exists("g:pasta_enabled_filetypes")
   13              0.000159     if index(g:pasta_enabled_filetypes, &ft) == -1
   13              0.000019       return
                                endif
                              elseif exists("g:pasta_disabled_filetypes") && index(g:pasta_disabled_filetypes, &ft) != -1
                                return
                              endif
                            
                              exe "nmap <buffer> " . g:pasta_paste_before_mapping . " <Plug>BeforePasta"
                              exe "xmap <buffer> " . g:pasta_paste_before_mapping . " <Plug>VisualPasta"
                            
                              exe "nmap <buffer> " . g:pasta_paste_after_mapping . " <Plug>AfterPasta"
                              exe "xmap <buffer> " . g:pasta_paste_after_mapping . " <Plug>VisualPasta"

FUNCTION  <SNR>169_on_stdout_nvim()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/async.vim:56
Called 72 times
Total time:   0.002613
 Self time:   0.002613

count  total (s)   self (s)
   72              0.000850   if empty(self.stdoutbuffer)
   43              0.000316     let self.stdoutbuffer = a:data
   29              0.000030   else
   29              0.000621     let self.stdoutbuffer = self.stdoutbuffer[:-2] + [self.stdoutbuffer[-1] . a:data[0]] + a:data[1:]
   72              0.000084   endif

FUNCTION  lens#get_target_height()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/lens.vim/plugin/lens.vim:98
Called 13 times
Total time:   0.000163
 Self time:   0.000114

count  total (s)   self (s)
   13   0.000153   0.000104   return lens#get_rows() + (&laststatus != 0 ? 1 : 0)

FUNCTION  <SNR>96_go()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-commentary/plugin/commentary.vim:27
Called 12 times
Total time:   0.007138
 Self time:   0.006116

count  total (s)   self (s)
   12              0.000143   if !a:0
    6   0.000411   0.000389     let &operatorfunc = matchstr(expand('<sfile>'), '[^. ]*$')
    6              0.000031     return 'g@'
    6              0.000094   elseif a:0 > 1
                                let [lnum1, lnum2] = [a:1, a:2]
    6              0.000014   else
    6              0.000124     let [lnum1, lnum2] = [line("'["), line("']")]
    6              0.000012   endif
                            
    6   0.000579   0.000157   let [l, r] = s:surroundings()
    6              0.000031   let uncomment = 2
   13              0.000095   for lnum in range(lnum1,lnum2)
    7              0.000217     let line = matchstr(getline(lnum),'\S.*\s\@<!')
    7   0.000729   0.000268     let [l, r] = s:strip_white_space(l,r,line)
    7              0.000140     if len(line) && (stridx(line,l) || line[strlen(line)-strlen(r) : -1] != r)
    6              0.000028       let uncomment = 0
    7              0.000013     endif
   13              0.000037   endfor
                            
    6              0.000052   if get(b:, 'commentary_startofline')
                                let indent = '^'
    6              0.000009   else
    6              0.000028     let indent = '^\s*'
    6              0.000009   endif
                            
   13              0.000079   for lnum in range(lnum1,lnum2)
    7              0.000045     let line = getline(lnum)
    7              0.000049     if strlen(r) > 2 && l.r !~# '\\'
                                  let line = substitute(line,'\M' . substitute(l, '\ze\S\s*$', '\\zs\\d\\*\\ze', '') . '\|' . substitute(r, '\S\zs', '\\zs\\d\\*\\ze', ''),'\=substitute(submatch(0)+1-uncomment,"^0$\\|^-\\d*$","","")','g')
    7              0.000012     endif
    7              0.000019     if uncomment
    1              0.000048       let line = substitute(line,'\S.*\s\@<!','\=submatch(0)[strlen(l):-strlen(r)-1]','')
    6              0.000007     else
    6              0.000265       let line = substitute(line,'^\%('.matchstr(getline(lnum1),indent).'\|\s*\)\zs.*\S\@<=','\=l.submatch(0).r','')
    7              0.000010     endif
    7              0.000554     call setline(lnum,line)
   13              0.000045   endfor
    6              0.000049   let modelines = &modelines
    6              0.000013   try
    6   0.000136   0.000109     set modelines=0
    6   0.000750   0.000670     silent doautocmd User CommentaryPost
    6              0.000025   finally
    6   0.000103   0.000092     let &modelines = modelines
    6              0.000015   endtry
    6              0.000017   return ''

FUNCTION  <SNR>172_Dir()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-fugitive/autoload/fugitive.vim:277
Called 4 times
Total time:   0.000375
 Self time:   0.000094

count  total (s)   self (s)
    4   0.000368   0.000087   return a:0 ? FugitiveGitDir(a:1) : FugitiveGitDir()

FUNCTION  airline#parts#crypt()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/autoload/airline/parts.vim:59
Called 1263 times
Total time:   0.024149
 Self time:   0.024149

count  total (s)   self (s)
 1263              0.022689   return g:airline_detect_crypt && exists("+key") && !empty(&key) ? g:airline_symbols.crypt : ''

FUNCTION  <SNR>130_hl_group_exists()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/autoload/airline/highlighter.vim:92
Called 2125 times
Total time:   0.055770
 Self time:   0.055770

count  total (s)   self (s)
 2125              0.017440   if !hlexists(a:group)
                                return 0
 2125              0.023981   elseif empty(synIDattr(hlID(a:group), 'fg'))
                                return 0
 2125              0.001953   endif
 2125              0.002622   return 1

FUNCTION  <SNR>177_call_coc()
    Defined: ~/Repos/Configs/Neovim/.config/coc/extensions/node_modules/coc-fzf-preview/autoload/fzf_preview/remote/handler_to_process.vim:24
Called 4 times
Total time:   0.765323
 Self time:   0.000385

count  total (s)   self (s)
    4              0.000027   if (a:process_name == v:null)
    4              0.000099     let process_name = substitute(a:default_process_function_name, '^FzfPreview', '', '')
    4   0.765035   0.000097     call CocAction('runCommand', 'fzf-preview-callback.' . process_name, [a:lines])
                              else
                                let processes = eval('g:' . a:process_name)
                                let Process = processes[a:expect_key]
                            
                                if type(Process) == v:t_string
                                  if exists('*' . Process)
                                    call call(Process, [a:lines])
                                  else
                                    call CocAction('runCommand', 'fzf-preview-callback.' . Process, [a:lines])
                                  endif
                                elseif type(Process) == v:t_func
                                  call Process(a:lines)
                                endif
    4              0.000009   endif

FUNCTION  <SNR>178_execute_preserving_scroll()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-smoothie/autoload/smoothie.vim:29
Called 108 times
Total time:   0.022682
 Self time:   0.022357

count  total (s)   self (s)
  108              0.000936   let l:saved_scroll = &scroll
  108              0.018576   execute a:command
  108   0.002826   0.002502   let &scroll = l:saved_scroll

FUNCTION  <SNR>85_is_file_buffer()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:63
Called 121 times
Total time:   0.002209
 Self time:   0.002209

count  total (s)   self (s)
  121              0.002036   return empty(getbufvar(a:bufnr, '&buftype'))

FUNCTION  <SNR>48_popup_support()
    Defined: ~/.fzf/plugin/fzf.vim:125
Called 7 times
Total time:   0.000065
 Self time:   0.000065

count  total (s)   self (s)
    7              0.000060   return has('nvim') ? has('nvim-0.4') : has('popupwin') && has('patch-8.2.191')

FUNCTION  airline#extensions#branch#head()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/autoload/airline/extensions/branch.vim:239
Called 1263 times
Total time:   2.630387
 Self time:   0.076851

count  total (s)   self (s)
 1263              0.008243   if !exists('b:buffer_vcs_config')
    7   0.000369   0.000066     call s:init_buffer()
 1263              0.001568   endif
                            
 1263   2.055755   0.014367   call s:update_branch()
 1263   0.517933   0.018338   call s:update_untracked()
                            
 1263              0.011703   if exists('b:airline_head') && !empty(b:airline_head)
 1243              0.003436     return b:airline_head
   20              0.000019   endif
                            
   20              0.000087   let b:airline_head = ''
   20              0.000209   let vcs_priority = get(g:, "airline#extensions#branch#vcs_priority", ["git", "mercurial"])
                            
   20              0.000055   let heads = []
   60              0.000163   for vcs in vcs_priority
   40              0.000257     if !empty(b:buffer_vcs_config[vcs].branch)
   20              0.000108       let heads += [vcs]
   40              0.000041     endif
   60              0.000075   endfor
                            
   40              0.000089   for vcs in heads
   20              0.000082     if !empty(b:airline_head)
                                  let b:airline_head .= ' | '
   20              0.000019     endif
   20              0.000078     if len(heads) > 1
                                  let b:airline_head .= s:vcs_config[vcs].exe .':'
   20              0.000017     endif
   20   0.012861   0.000610     let b:airline_head .= s:format_name({s:vcs_config[vcs].display_branch}())
   20              0.000121     let additional = b:buffer_vcs_config[vcs].untracked
   20              0.000243     if empty(additional) && has_key(b:buffer_vcs_config[vcs], 'dirty') && b:buffer_vcs_config[vcs].dirty
   11              0.000065       let additional = g:airline_symbols['dirty']
   20              0.000020     endif
   20              0.000087     let b:airline_head .= additional
   40              0.000080   endfor
                            
   20              0.000067   if empty(heads)
                                if airline#util#has_vcscommand()
                                  noa call VCSCommandEnableBufferSetup()
                                  if exists('b:VCSCommandBufferInfo')
                                    let b:airline_head = s:format_name(get(b:VCSCommandBufferInfo, 0, ''))
                                  endif
                                endif
   20              0.000016   endif
                            
   20              0.000059   if empty(heads)
                                if airline#util#has_custom_scm()
                                  try
                                    let Fn = function(g:airline#extensions#branch#custom_head)
                                    let b:airline_head = Fn()
                                  endtry
                                endif
   20              0.000015   endif
                            
   20              0.000156   if exists("g:airline#extensions#branch#displayed_head_limit")
                                let w:displayed_head_limit = g:airline#extensions#branch#displayed_head_limit
                                if strwidth(b:airline_head) > w:displayed_head_limit - 1
                                  let b:airline_head = airline#util#strcharpart(b:airline_head, 0, w:displayed_head_limit - 1) . (&encoding ==? 'utf-8' ?  '' : '.')
                                endif
   20              0.000015   endif
                            
   20              0.000064   return b:airline_head

FUNCTION  airline#util#shorten()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/autoload/airline/util.vim:28
Called 5064 times
Total time:   0.330535
 Self time:   0.203544

count  total (s)   self (s)
 5064   0.209757   0.082766   if airline#util#winwidth() < a:winwidth && len(split(a:text, '\zs')) > a:minwidth
   24              0.000091     if get(a:000, 0, 0)
                                  " shorten from tail
                                  return ''.matchstr(a:text, '.\{'.a:minwidth.'}$')
   24              0.000030     else
                                  " shorten from beginning of string
   24              0.000319       return matchstr(a:text, '^.\{'.a:minwidth.'}').''
                                endif
 5040              0.005110   else
 5040              0.012022     return a:text
                              endif

FUNCTION  airline#highlighter#reset_hlcache()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/autoload/airline/highlighter.vim:57
Called 2 times
Total time:   0.076744
 Self time:   0.076744

count  total (s)   self (s)
    2              0.076737   let s:hl_groups = {}

FUNCTION  gitgutter#diff#run_diff()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:69
Called 26 times
Total time:   0.232178
 Self time:   0.019545

count  total (s)   self (s)
   26   0.001796   0.000396   if gitgutter#utility#repo_path(a:bufnr, 0) == -1
                                throw 'gitgutter author fail'
   26              0.000041   endif
                            
   26   0.001628   0.000354   if gitgutter#utility#repo_path(a:bufnr, 0) == -2
                                throw 'gitgutter not tracked'
   26              0.000035   endif
                            
   26              0.000211   let temp_from = tempname()
   26              0.000158   let temp_buffer = tempname()
                            
                              " Wrap compound commands in parentheses to make Windows happy.
                              " bash doesn't mind the parentheses.
   26              0.000085   let cmd = '('
                            
                              " Append buffer number to temp filenames to avoid race conditions between
                              " writing and reading the files when asynchronously processing multiple
                              " buffers.
                            
                              " Without the buffer number, buff_file would have a race between the
                              " second gitgutter#process_buffer() writing the file (synchronously, below)
                              " and the first gitgutter#process_buffer()'s async job reading it (with
                              " git-diff).
   26              0.000225   let buff_file = temp_buffer.'.'.a:bufnr
                            
                              " Add a counter to avoid a similar race with two quick writes of the same buffer.
                              " Use a modulus greater than a maximum reasonable number of visible buffers.
   26              0.000167   let s:counter = (s:counter + 1) % 20
   26              0.000211   let buff_file .= '.'.s:counter
                            
   26   0.004943   0.000369   let extension = gitgutter#utility#extension(a:bufnr)
   26              0.000160   if !empty(extension)
   26              0.000211     let buff_file .= '.'.extension
   26              0.000044   endif
                            
                              " Write buffer to temporary file.
                              " Note: this is synchronous.
   26   0.018915   0.002922   call s:write_buffer(a:bufnr, buff_file)
                            
   26              0.000307   if a:from ==# 'index'
                                " Without the buffer number, from_file would have a race in the shell
                                " between the second process writing it (with git-show) and the first
                                " reading it (with git-diff).
   26              0.000555     let from_file = temp_from.'.'.a:bufnr
                            
                                " Add a counter to avoid a similar race with two quick writes of the same buffer.
   26              0.000244     let from_file .= '.'.s:counter
                            
   26              0.000179     if !empty(extension)
   26              0.000284       let from_file .= '.'.extension
   26              0.000052     endif
                            
                                " Write file from index to temporary file.
   26   0.008594   0.001398     let index_name = gitgutter#utility#get_diff_base(a:bufnr).':'.gitgutter#utility#repo_path(a:bufnr, 1)
   26              0.000553     let cmd .= g:gitgutter_git_executable.' '.g:gitgutter_git_args.' --no-pager show '.index_name.' > '.from_file.' && '
                            
                              elseif a:from ==# 'working_tree'
                                let from_file = gitgutter#utility#repo_path(a:bufnr, 1)
   26              0.000042   endif
                            
                              " Call git-diff.
   26              0.000302   let cmd .= g:gitgutter_git_executable.' '.g:gitgutter_git_args.' --no-pager'
   26              0.000072   if s:c_flag
   26              0.000156     let cmd .= ' -c "diff.autorefreshindex=0"'
   26              0.000139     let cmd .= ' -c "diff.noprefix=false"'
   26              0.000130     let cmd .= ' -c "core.safecrlf=false"'
   26              0.000038   endif
   26              0.000439   let cmd .= ' diff --no-ext-diff --no-color -U0 '.g:gitgutter_diff_args.' -- '.from_file.' '.buff_file
                            
                              " Pipe git-diff output into grep.
   26              0.000228   if !a:preserve_full_diff && !empty(g:gitgutter_grep)
   26   0.002400   0.000588     let cmd .= ' | '.g:gitgutter_grep.' '.gitgutter#utility#shellescape('^@@ ')
   26              0.000043   endif
                            
                              " grep exits with 1 when no matches are found; git-diff exits with 1 when
                              " differences are found.  However we want to treat non-matches and
                              " differences as non-erroneous behaviour; so we OR the command with one
                              " which always exits with success (0).
   26              0.000135   let cmd .= ' || exit 0'
                            
   26              0.000113   let cmd .= ')'
                            
   26   0.012319   0.000445   let cmd = gitgutter#utility#cd_cmd(a:bufnr, cmd)
                            
   26   0.000628   0.000447   if g:gitgutter_async && gitgutter#async#available()
   26   0.170490   0.002161     call gitgutter#async#execute(cmd, a:bufnr, {   'out': function('gitgutter#diff#handler'),   'err': function('gitgutter#hunk#reset'), })
   26              0.000689     return 'async'
                            
                              else
                                let diff = gitgutter#utility#system(cmd)
                            
                                if v:shell_error
                                  call gitgutter#debug#log(diff)
                                  throw 'gitgutter diff failed'
                                endif
                            
                                return diff
                              endif

FUNCTION  <SNR>123_is_excluded_window()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/autoload/airline/extensions.vim:111
Called 50 times
Total time:   0.007212
 Self time:   0.007212

count  total (s)   self (s)
   50              0.001434   for matchft in g:airline_exclude_filetypes
                                if matchft ==# &ft
                                  return 1
                                endif
   50              0.000088   endfor
                            
  200              0.000533   for matchw in g:airline_exclude_filenames
  150              0.003279     if matchstr(expand('%'), matchw) ==# matchw
                                  return 1
  150              0.000117     endif
  200              0.000274   endfor
                            
   50              0.000288   if g:airline_exclude_preview && &previewwindow
                                return 1
   50              0.000036   endif
                            
   50              0.000075   return 0

FUNCTION  GitGutterGetHunkSummary()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-gitgutter/plugin/gitgutter.vim:197
Called 1244 times
Total time:   0.114833
 Self time:   0.050839

count  total (s)   self (s)
 1244   0.113461   0.049467   return gitgutter#hunk#summary(winbufnr(0))

FUNCTION  airline#parts#mode()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/autoload/airline/parts.vim:55
Called 1263 times
Total time:   0.115938
 Self time:   0.026469

count  total (s)   self (s)
 1263   0.113999   0.024531   return airline#util#shorten(get(w:, 'airline_current_mode', ''), 79, 1)

FUNCTION  coc#util#get_bufoptions()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/coc.nvim/autoload/coc/util.vim:245
Called 14 times
Total time:   0.010297
 Self time:   0.004440

count  total (s)   self (s)
   14              0.000173   if !bufloaded(a:bufnr) | return v:null | endif
   14              0.000099   let bufname = bufname(a:bufnr)
   14              0.000119   let buftype = getbufvar(a:bufnr, '&buftype')
   14              0.000044   let previewwindow = 0
   14              0.000077   let winid = bufwinid(a:bufnr)
   14              0.000035   if winid != -1
   14              0.000108     let previewwindow = getwinvar(winid, '&previewwindow', 0)
   14              0.000017   endif
   14              0.000032   let size = -1
   14              0.000065   if bufnr('%') == a:bufnr
   14              0.000166     let size = line2byte(line("$") + 1)
                              elseif !empty(bufname)
                                let size = getfsize(bufname)
   14              0.000013   endif
   14   0.009157   0.003299   return { 'bufname': bufname, 'size': size, 'eol': getbufvar(a:bufnr, '&eol'), 'buftype': buftype, 'winid': winid, 'previewwindow': previewwindow == 0 ? v:false : v:true, 'variables': s:variables(a:bufnr), 'fullpath': empty(bufname) ? '' : fnamemodify(bufname, ':p'), 'filetype': getbufvar(a:bufnr, '&filetype'), 'iskeyword': getbufvar(a:bufnr, '&iskeyword'), 'changedtick': getbufvar(a:bufnr, 'changedtick'),}

FUNCTION  airline#extensions#quickfix#apply()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/autoload/airline/extensions/quickfix.vim:14
Called 36 times
Total time:   0.000584
 Self time:   0.000584

count  total (s)   self (s)
   36              0.000176   if &buftype == 'quickfix'
                                let w:airline_section_a = airline#extensions#quickfix#get_type()
                                let w:airline_section_b = '%{get(w:, "quickfix_title", "")}'
                                let w:airline_section_c = ''
                                let w:airline_section_x = ''
   36              0.000035   endif

FUNCTION  <SNR>143_get_section()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/autoload/airline/extensions/default.vim:20
Called 392 times
Total time:   0.040074
 Self time:   0.033111

count  total (s)   self (s)
  392              0.002289   if has_key(s:section_truncate_width, a:key)
  259   0.007020   0.002686     if airline#util#winwidth(a:winnr) < s:section_truncate_width[a:key]
                                  return ''
  259              0.000192     endif
  392              0.000294   endif
  392              0.001340   let spc = g:airline_symbols.space
  392              0.007519   if !exists('g:airline_section_{a:key}')
                                return ''
  392              0.000261   endif
  392   0.008059   0.005430   let text = airline#util#getwinvar(a:winnr, 'airline_section_'.a:key, g:airline_section_{a:key})
  392              0.007524   let [prefix, suffix] = [get(a:000, 0, '%('.spc), get(a:000, 1, spc.'%)')]
  392              0.002647   return empty(text) ? '' : prefix.text.suffix

FUNCTION  gitgutter#hunk#increment_lines_removed()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/hunk.vim:40
Called 1 time
Total time:   0.000058
 Self time:   0.000016

count  total (s)   self (s)
    1   0.000028   0.000006   let summary = gitgutter#hunk#summary(a:bufnr)
    1              0.000003   let summary[2] += a:count
    1   0.000027   0.000007   call gitgutter#utility#setbufvar(a:bufnr, 'summary', summary)

FUNCTION  airline#mode_changed()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/autoload/airline.vim:279
Called 57 times
Total time:   0.002711
 Self time:   0.001999

count  total (s)   self (s)
                              " airline#visual_active
                              " Boolean: for when to get visual wordcount
                              " needed for the wordcount extension
   57              0.001157   let g:airline#visual_active = (mode() =~? '[vs]')
   57   0.001312   0.000600   call airline#update_tabline()

FUNCTION  fugitive#Find()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-fugitive/autoload/fugitive.vim:920
Called 1263 times
Total time:   1.092286
 Self time:   0.703938

count  total (s)   self (s)
 1263              0.008969   if type(a:object) == type(0)
                                let name = bufname(a:object)
                                return FugitiveVimPath(name =~# '^$\|^/\|^\a\+:' ? name : getcwd() . '/' . name)
 1263              0.011460   elseif a:object =~# '^[~$]'
                                let prefix = matchstr(a:object, '^[~$]\i*')
                                let owner = expand(prefix)
                                return FugitiveVimPath((len(owner) ? owner : prefix) . strpart(a:object, len(prefix)))
 1263   0.073454   0.051694   elseif s:Slash(a:object) =~# '^$\|^/\|^\%(\a\a\+:\).*\%(//\|::\)' . (has('win32') ? '\|^\a:/' : '')
                                return FugitiveVimPath(a:object)
 1263   0.044911   0.025802   elseif s:Slash(a:object) =~# '^\.\.\=\%(/\|$\)'
                                return FugitiveVimPath(simplify(getcwd() . '/' . a:object))
 1263              0.001666   endif
 1263              0.007939   let dir = a:0 ? a:1 : s:Dir()
 1263              0.005047   if empty(dir)
                                let file = matchstr(a:object, '^\%(:\d:\|[^:]*:\)\zs.*', '', '')
                                let dir = FugitiveExtractGitDir(file)
                                if empty(dir)
                                  return fnamemodify(FugitiveVimPath(len(file) ? file : a:object), ':p')
                                endif
 1263              0.001134   endif
 1263   0.044259   0.015367   let rev = s:Slash(a:object)
 1263   0.251261   0.025698   let tree = s:Tree(dir)
 1263              0.008843   let base = len(tree) ? tree : 'fugitive://' . dir . '//0'
 1263              0.003966   if rev ==# '.git'
                                let f = len(tree) ? tree . '/.git' : dir
 1263              0.008173   elseif rev =~# '^\.git/'
 1263              0.014329     let f = substitute(rev, '^\.git', '', '')
 1263   0.093264   0.020434     let cdir = fugitive#CommonDir(dir)
 1263              0.013935     if f =~# '^/\.\./\.\.\%(/\|$\)'
                                  let f = simplify(len(tree) ? tree . f[3:-1] : dir . f)
 1263              0.011064     elseif f =~# '^/\.\.\%(/\|$\)'
                                  let f = base . f[3:-1]
 1263              0.017917     elseif cdir !=# dir && ( f =~# '^/\%(config\|hooks\|info\|logs/refs\|objects\|refs\|worktrees\)\%(/\|$\)' || f !~# '^/\%(index$\|index\.lock$\|\w*MSG$\|\w*HEAD$\|logs/\w*HEAD$\|logs$\|rebase-\w\+\)\%(/\|$\)' && getftime(FugitiveVimPath(dir . f)) < 0 && getftime(FugitiveVimPath(cdir . f)) >= 0)
                                  let f = simplify(cdir . f)
 1263              0.001437     else
 1263              0.010498       let f = simplify(dir . f)
 1263              0.001517     endif
                              elseif rev ==# ':/'
                                let f = base
                              elseif rev =~# '^\.\%(/\|$\)'
                                let f = base . rev[1:-1]
                              elseif rev =~# '^::\%(/\|\a\+\:\)'
                                let f = rev[2:-1]
                              elseif rev =~# '^::\.\.\=\%(/\|$\)'
                                let f = simplify(getcwd() . '/' . rev[2:-1])
                              elseif rev =~# '^::'
                                let f = base . '/' . rev[2:-1]
                              elseif rev =~# '^:\%([0-3]:\)\=\.\.\=\%(/\|$\)\|^:[0-3]:\%(/\|\a\+:\)'
                                let f = rev =~# '^:\%([0-3]:\)\=\.' ? simplify(getcwd() . '/' . matchstr(rev, '\..*')) : rev[3:-1]
                                if s:cpath(base . '/', (f . '/')[0 : len(base)])
                                  let f = 'fugitive://' . dir . '//' . +matchstr(rev, '^:\zs\d\ze:') . '/' . strpart(f, len(base) + 1)
                                else
                                  let altdir = FugitiveExtractGitDir(f)
                                  if len(altdir) && !s:cpath(dir, altdir)
                                    return fugitive#Find(a:object, altdir)
                                  endif
                                endif
                              elseif rev =~# '^:[0-3]:'
                                let f = 'fugitive://' . dir . '//' . rev[1] . '/' . rev[3:-1]
                              elseif rev ==# ':'
                                if $GIT_INDEX_FILE =~# '/[^/]*index[^/]*\.lock$' && s:cpath(fnamemodify($GIT_INDEX_FILE,':p')[0:strlen(dir)]) ==# s:cpath(dir . '/') && filereadable($GIT_INDEX_FILE)
                                  let f = fnamemodify($GIT_INDEX_FILE, ':p')
                                else
                                  let f = fugitive#Find('.git/index', dir)
                                endif
                              elseif rev =~# '^:(\%(top\|top,literal\|literal,top\|literal\))'
                                let f = matchstr(rev, ')\zs.*')
                                if f=~# '^\.\.\=\%(/\|$\)'
                                  let f = simplify(getcwd() . '/' . f)
                                elseif f !~# '^/\|^\%(\a\a\+:\).*\%(//\|::\)' . (has('win32') ? '\|^\a:/' : '')
                                  let f = base . '/' . f
                                endif
                              elseif rev =~# '^:/\@!'
                                let f = 'fugitive://' . dir . '//0/' . rev[1:-1]
                              else
                                if !exists('f')
                                  let commit = substitute(matchstr(rev, '^\%([^:.-]\|\.\.[^/:]\)[^:]*\|^:.*'), '^@\%($\|[~^]\|@{\)\@=', 'HEAD', '')
                                  let file = substitute(matchstr(rev, '^\%([^:.-]\|\.\.[^/:]\)[^:]*\zs:.*'), '^:', '/', '')
                                  if file =~# '^/\.\.\=\%(/\|$\)\|^//\|^/\a\+:'
                                    let file = file =~# '^/\.' ? simplify(getcwd() . file) : file[1:-1]
                                    if s:cpath(base . '/', (file . '/')[0 : len(base)])
                                      let file = '/' . strpart(file, len(base) + 1)
                                    else
                                      let altdir = FugitiveExtractGitDir(file)
                                      if len(altdir) && !s:cpath(dir, altdir)
                                        return fugitive#Find(a:object, altdir)
                                      endif
                                      return file
                                    endif
                                  endif
                                  let commits = split(commit, '\.\.\.-\@!', 1)
                                  if len(commits) == 2
                                    call map(commits, 'empty(v:val) || v:val ==# "@" ? "HEAD" : v:val')
                                    let commit = matchstr(s:ChompDefault('', [dir, 'merge-base'] + commits + ['--']), '\<[0-9a-f]\{40,\}\>')
                                  endif
                                  if commit !~# '^[0-9a-f]\{40,\}$'
                                    let commit = matchstr(s:ChompDefault('', [dir, 'rev-parse', '--verify', commit . (len(file) ? '^{}' : ''), '--']), '\<[0-9a-f]\{40,\}\>')
                                  endif
                                  if len(commit)
                                    let f = 'fugitive://' . dir . '//' . commit . file
                                  else
                                    let f = base . '/' . substitute(rev, '^:/:\=\|^[^:]\+:', '', '')
                                  endif
                                endif
 1263              0.001152   endif
 1263   0.034623   0.014429   return FugitiveVimPath(f)

FUNCTION  coc#_complete()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/coc.nvim/autoload/coc.vim:56
Called 4 times
Total time:   0.018353
 Self time:   0.016045

count  total (s)   self (s)
    4              0.000065   let items = get(g:coc#_context, 'candidates', [])
    4              0.000033   let preselect = get(g:coc#_context, 'preselect', -1)
    4   0.018157   0.015849   call complete( g:coc#_context.start + 1, items)
    4              0.000042   if s:select_api && len(items) && preselect != -1
                                call nvim_select_popupmenu_item(preselect, v:false, v:false, {})
    4              0.000005   endif
    4              0.000008   return ''

FUNCTION  airline#extensions#wordcount#apply()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/autoload/airline/extensions/wordcount.vim:88
Called 29 times
Total time:   0.002502
 Self time:   0.002502

count  total (s)   self (s)
   29              0.000659   let filetypes = get(g:, 'airline#extensions#wordcount#filetypes',  ['asciidoc', 'help', 'mail', 'markdown', 'nroff', 'org', 'rst', 'plaintex', 'tex', 'text'])
                              " export current filetypes settings to global namespace
   29              0.000241   let g:airline#extensions#wordcount#filetypes = filetypes
                            
                              " Check if filetype needs testing
   29              0.000107   if did_filetype()
                                " correctly test for compound filetypes (e.g. markdown.pandoc)
    6              0.000069     let ft = substitute(&filetype, '\.', '\\|', 'g')
                            
                                " Select test based on type of "filetypes": new=list, old=string
    6              0.000164     if type(filetypes) == get(v:, 't_list', type([])) ? match(filetypes, '\<'. ft. '\>') > -1 || index(filetypes, 'all') > -1 : match(&filetype, filetypes) > -1
                                  let b:airline_changedtick = -1
                                  call s:update_wordcount(1) " force update: ensures initial worcount exists
    6              0.000032     elseif exists('b:airline_wordcount') " cleanup when filetype is removed
                                  unlet b:airline_wordcount
    6              0.000006     endif
   29              0.000021   endif
                            
   29              0.000125   if exists('b:airline_wordcount')
                                call airline#extensions#prepend_to_section( 'z', '%{airline#extensions#wordcount#get()}')
   29              0.000023   endif

FUNCTION  gitgutter#diff#handler()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:174
Called 26 times
Total time:   0.128501
 Self time:   0.031771

count  total (s)   self (s)
   26   0.002043   0.000339   call gitgutter#debug#log(a:diff)
                            
   26              0.000118   if !bufexists(a:bufnr)
                                return
   26              0.000019   endif
                            
   26   0.020352   0.000539   call gitgutter#hunk#set_hunks(a:bufnr, gitgutter#diff#parse_diff(a:diff))
   26   0.055126   0.000490   let modified_lines = gitgutter#diff#process_hunks(a:bufnr, gitgutter#hunk#hunks(a:bufnr))
                            
   26              0.000107   let signs_count = len(modified_lines)
   26              0.000103   if g:gitgutter_max_signs != -1 && signs_count > g:gitgutter_max_signs
                                call gitgutter#utility#warn_once(a:bufnr, printf( 'exceeded maximum number of signs (%d > %d, configured by g:gitgutter_max_signs).', signs_count, g:gitgutter_max_signs), 'max_signs')
                                call gitgutter#sign#clear_signs(a:bufnr)
                            
   26              0.000023   else
   26              0.000101     if g:gitgutter_signs || g:gitgutter_highlight_lines || g:gitgutter_highlight_linenrs
   26   0.039507   0.022436       call gitgutter#sign#update_signs(a:bufnr, modified_lines)
   26              0.005806     endif
   26              0.000213   endif
                            
   26   0.003852   0.000346   call s:save_last_seen_change(a:bufnr)
   26              0.000241   if exists('#User#GitGutter')
                                let g:gitgutter_hook_context = {'bufnr': a:bufnr}
                                execute 'doautocmd' s:nomodeline 'User GitGutter'
                                unlet g:gitgutter_hook_context
   26              0.000021   endif

FUNCTION  fzf_preview#remote#mr#append()
    Defined: ~/Repos/Configs/Neovim/.config/coc/extensions/node_modules/coc-fzf-preview/autoload/fzf_preview/remote/mr.vim:1
Called 32 times
Total time:   0.210054
 Self time:   0.024229

count  total (s)   self (s)
   32   0.175741   0.000751   let files = s:get_files_with_create_directory(a:cache_path)
                            
   32              0.000436   call insert(files, a:path)
   32   0.033739   0.022905   call writefile(fzf_preview#remote#util#uniq(files)[:g:fzf_preview_mru_limit - 1], a:cache_path)

FUNCTION  gitgutter#setup_maps()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter.vim:107
Called 19 times
Total time:   0.008894
 Self time:   0.008230

count  total (s)   self (s)
   19              0.000048   if !g:gitgutter_map_keys
                                return
   19              0.000014   endif
                            
                              " Note hasmapto() and maparg() operate on the current buffer.
                            
   19              0.000079   let bufnr = bufnr('')
                            
   19   0.000608   0.000190   if gitgutter#utility#getbufvar(bufnr, 'mapped', 0)
   12              0.000012     return
    7              0.000028   endif
                            
    7              0.001034   if !hasmapto('<Plug>(GitGutterPrevHunk)') && maparg('[c', 'n') ==# ''
    7              0.000222     nmap <buffer> [c <Plug>(GitGutterPrevHunk)
    7              0.000010   endif
    7              0.000912   if !hasmapto('<Plug>(GitGutterNextHunk)') && maparg(']c', 'n') ==# ''
    7              0.000187     nmap <buffer> ]c <Plug>(GitGutterNextHunk)
    7              0.000009   endif
                            
    7              0.000570   if !hasmapto('<Plug>(GitGutterStageHunk)', 'v') && maparg('<Leader>hs', 'x') ==# ''
    7              0.000277     xmap <buffer> <Leader>hs <Plug>(GitGutterStageHunk)
    7              0.000010   endif
    7              0.000526   if !hasmapto('<Plug>(GitGutterStageHunk)', 'n') && maparg('<Leader>hs', 'n') ==# ''
    7              0.000183     nmap <buffer> <Leader>hs <Plug>(GitGutterStageHunk)
    7              0.000008   endif
    7              0.000626   if !hasmapto('<Plug>(GitGutterUndoHunk)') && maparg('<Leader>hu', 'n') ==# ''
    7              0.000167     nmap <buffer> <Leader>hu <Plug>(GitGutterUndoHunk)
    7              0.000007   endif
    7              0.000539   if !hasmapto('<Plug>(GitGutterPreviewHunk)') && maparg('<Leader>hp', 'n') ==# ''
    7              0.000160     nmap <buffer> <Leader>hp <Plug>(GitGutterPreviewHunk)
    7              0.000007   endif
                            
    7              0.000548   if !hasmapto('<Plug>(GitGutterTextObjectInnerPending)') && maparg('ic', 'o') ==# ''
                                omap <buffer> ic <Plug>(GitGutterTextObjectInnerPending)
    7              0.000006   endif
    7              0.000501   if !hasmapto('<Plug>(GitGutterTextObjectOuterPending)') && maparg('ac', 'o') ==# ''
                                omap <buffer> ac <Plug>(GitGutterTextObjectOuterPending)
    7              0.000005   endif
    7              0.000493   if !hasmapto('<Plug>(GitGutterTextObjectInnerVisual)') && maparg('ic', 'x') ==# ''
                                xmap <buffer> ic <Plug>(GitGutterTextObjectInnerVisual)
    7              0.000005   endif
    7              0.000456   if !hasmapto('<Plug>(GitGutterTextObjectOuterVisual)') && maparg('ac', 'x') ==# ''
                                xmap <buffer> ac <Plug>(GitGutterTextObjectOuterVisual)
    7              0.000005   endif
                            
    7   0.000356   0.000108   call gitgutter#utility#setbufvar(bufnr, 'mapped', 1)

FUNCTION  <SNR>59_notify()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/coc.nvim/autoload/coc/client.vim:181
Called 820 times
Total time:   0.199464
 Self time:   0.180924

count  total (s)   self (s)
  820   0.038092   0.019552   let channel = coc#client#get_channel(self)
  820              0.005017   if empty(channel)
                                return ''
  820              0.001075   endif
  820              0.001734   try
  820              0.002558     if s:is_vim
                                  call ch_sendraw(channel, json_encode([0, [a:method, a:args]])."\n")
  820              0.002029     else
  820              0.070265       call call('rpcnotify', [channel, a:method] + a:args)
  820              0.003487     endif
                              catch /.*/
                                if v:exception =~# 'E475'
                                  if get(g:, 'coc_vim_leaving', 0)
                                    return
                                  endif
                                  echohl Error | echom '['.self.name.'] server connection lost' | echohl None
                                  let name = self.name
                                  call s:on_exit(name, 0)
                                  execute 'silent do User ConnectionLost'.toupper(name[0]).name[1:]
                                elseif v:exception =~# 'E12'
                                  " neovim's bug, ignore it
                                else
                                  echohl Error | echo 'Error on notify ('.a:method.'): '.v:exception | echohl None
                                endif
  820              0.001878   endtry

FUNCTION  gitgutter#hunk#increment_lines_added()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/hunk.vim:28
Called 40 times
Total time:   0.003148
 Self time:   0.000928

count  total (s)   self (s)
   40   0.001570   0.000331   let summary = gitgutter#hunk#summary(a:bufnr)
   40              0.000124   let summary[0] += a:count
   40   0.001392   0.000411   call gitgutter#utility#setbufvar(a:bufnr, 'summary', summary)

FUNCTION  <SNR>144_has_fresh_changes()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter.vim:162
Called 81 times
Total time:   0.006572
 Self time:   0.001795

count  total (s)   self (s)
   81   0.006442   0.001665   return getbufvar(a:bufnr, 'changedtick') != gitgutter#utility#getbufvar(a:bufnr, 'tick')

FUNCTION  <SNR>173_valid_dir()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/autoload/airline/async.vim:50
Called 102 times
Total time:   0.002637
 Self time:   0.002637

count  total (s)   self (s)
  102              0.001518   if empty(a:dir) || !isdirectory(a:dir)
                                return getcwd()
  102              0.000150   endif
  102              0.000265   return a:dir

FUNCTION  airline#async#nvim_vcs_clean()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/autoload/airline/async.vim:305
Called 51 times
Total time:   0.049535
 Self time:   0.047832

count  total (s)   self (s)
   51   0.004249   0.003055     let config = { 'buf': '', 'vcs': a:vcs, 'file': a:file, 'cwd': s:valid_dir(fnamemodify(a:file, ':p:h')), 'on_stdout': function('s:nvim_output_handler'), 'on_stderr': function('s:nvim_output_handler'), 'on_exit': function('s:on_exit_clean')}
   51              0.000215     if g:airline#init#is_windows && &shell =~ 'cmd\|powershell'
                                  let cmd = a:cmd
   51              0.000058     else
   51              0.000398       let cmd = [&shell, &shellcmdflag, a:cmd]
   51              0.000062     endif
                            
   51              0.000300     if !has_key(s:clean_jobs, a:vcs)
    1              0.000004       let s:clean_jobs[a:vcs] = {}
   51              0.000047     endif
   51              0.000352     if has_key(s:clean_jobs[a:vcs], a:file)
                                  " still running
   41              0.000060       return
                                  " jobs dict should be cleaned on exit, so not needed here
                                  " call remove(s:clean_jobs[a:vcs], a:file)
   10              0.000008     endif
   10              0.041819     let id = jobstart(cmd, config)
   10   0.001248   0.000739     call s:set_clean_jobs_variable(a:vcs, a:file, id)

FUNCTION  coc#util#unplace_signs()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/coc.nvim/autoload/coc/util.vim:466
Called 25 times
Total time:   0.002124
 Self time:   0.002124

count  total (s)   self (s)
   25              0.000332   if !bufloaded(a:bufnr) | return | endif
  169              0.000326   for id in a:sign_ids
  144              0.001118     execute 'silent! sign unplace '.id.' buffer='.a:bufnr
  169              0.000163   endfor

FUNCTION  <SNR>132_display_git_branch()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/autoload/airline/extensions/branch.vim:115
Called 20 times
Total time:   0.012142
 Self time:   0.007526

count  total (s)   self (s)
                              " disable FocusGained autocommand, might cause loops because system() causes
                              " a refresh, which causes a system() command again #2029
   20   0.000934   0.000624   call airline#util#ignore_next_focusgain()
   20              0.000115   let name = b:buffer_vcs_config['git'].branch
   20              0.000029   try
   20   0.009789   0.005484     let commit = matchstr(FugitiveParse()[0], '^\x\+')
                            
   20              0.000098     if has_key(s:names, commit)
                                  let name = get(s:names, commit)."(".name.")"
   20              0.000067     elseif !empty(commit)
                                  let ref = fugitive#repo().git_chomp('describe', '--all', '--exact-match', commit)
                                  if ref !~ "^fatal: no tag exactly matches"
                                    let name = s:format_name(substitute(ref, '\v\C^%(heads/|remotes/|tags/)=','',''))."(".name.")"
                                  else
                                    let name = matchstr(commit, '.\{'.s:sha1size.'}')."(".name.")"
                                  endif
   20              0.000016     endif
                              catch
   20              0.000027   endtry
   20              0.000043   return name

FUNCTION  CocAction()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/coc.nvim/plugin/coc.vim:69
Called 8 times
Total time:   1.977612
 Self time:   0.000106

count  total (s)   self (s)
    8   1.204028   0.439196   return coc#rpc#request(a:name, a:000)

FUNCTION  <SNR>85_filename()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:214
Called 17 times
Total time:   0.002949
 Self time:   0.000310

count  total (s)   self (s)
   17   0.002931   0.000292   return fnamemodify(s:abs_path(a:bufnr, 0), ':t')

FUNCTION  airline#statusline()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/autoload/airline.vim:190
Called 1463 times
Total time:   0.053543
 Self time:   0.053543

count  total (s)   self (s)
 1463              0.022705   if has_key(s:contexts, a:winnr)
 1463              0.025010     return '%{airline#check_mode('.a:winnr.')}'.s:contexts[a:winnr].line
                              endif
                              " in rare circumstances this happens...see #276
                              return ''

FUNCTION  lens#run()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/lens.vim/plugin/lens.vim:116
Called 13 times
Total time:   0.010945
 Self time:   0.000969

count  total (s)   self (s)
   13   0.004301   0.000282   let width = lens#get_size( winwidth(0), lens#get_target_width(), g:lens#width_resize_min, g:lens#width_resize_max)
                            
   13   0.000583   0.000230   let height = lens#get_size( winheight(0), lens#get_target_height(), g:lens#height_resize_min, g:lens#height_resize_max)
                            
   13              0.000083   if g:lens#animate && exists('g:animate#loaded') && g:animate#loaded
   13   0.000277   0.000134     if ! animate#window_is_animating(winnr())
   13   0.005566   0.000106       call animate#window_absolute(width, height)
   13              0.000012     endif
                              else
                                execute 'vertical resize ' . width
                                execute 'resize ' . height
   13              0.000009   endif

FUNCTION  lens#win_enter()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/lens.vim/plugin/lens.vim:141
Called 20 times
Total time:   0.012303
 Self time:   0.001359

count  total (s)   self (s)
                              " Don't resize if the window is floating
   20              0.000132   if exists('*nvim_win_get_config')
   20              0.000395     if ! g:lens#resize_floating && nvim_win_get_config(0)['relative'] != ''
    7              0.000013       return
   13              0.000014     endif
   13              0.000011   endif
                            
   13              0.000042   if g:lens#disabled || g:lens#enter_disabled
                                return
   13              0.000010   endif
                            
   13              0.000104   if index(g:lens#disabled_filetypes, &filetype) != -1
                                return
   13              0.000009   endif
                            
   13              0.000073   if index(g:lens#disabled_buftypes, &buftype) != -1
                                  return
   13              0.000008   endif
                            
   13              0.000046   if len(g:lens#disabled_filenames) > 0
                                  let l:filename = expand('%:p')
                                  for l:pattern in g:lens#disabled_filenames
                                      if match(l:filename, l:pattern) > -1
                                          return
                                      endif
                                  endfor
   13              0.000011   endif
                            
   13   0.011078   0.000134   call lens#run()

FUNCTION  <SNR>178_count_to_scroll()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-smoothie/autoload/smoothie.vim:171
Called 4 times
Total time:   0.000079
 Self time:   0.000079

count  total (s)   self (s)
    4              0.000034   if v:count
                                let &scroll=v:count
    4              0.000010   end

FUNCTION  coc#util#jumpTo()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/coc.nvim/autoload/coc/util.vim:206
Called 1 time
Total time:   0.000048
 Self time:   0.000048

count  total (s)   self (s)
    1              0.000021   let content = getline(a:line + 1)
    1              0.000009   let pre = strcharpart(content, 0, a:character)
    1              0.000006   let col = strlen(pre) + 1
    1              0.000007   call cursor(a:line + 1, col)

FUNCTION  gitgutter#utility#is_active()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:50
Called 121 times
Total time:   0.090468
 Self time:   0.009128

count  total (s)   self (s)
  121   0.090282   0.008941   return g:gitgutter_enabled && gitgutter#utility#getbufvar(a:bufnr, 'enabled', 1) && !pumvisible() && s:is_file_buffer(a:bufnr) && s:exists_file(a:bufnr) && s:not_git_dir(a:bufnr)

FUNCTION  airline#extensions#apply()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/autoload/airline/extensions.vim:71
Called 50 times
Total time:   0.014820
 Self time:   0.005606

count  total (s)   self (s)
   50              0.000466   let filetype_overrides = get(s:, 'filetype_overrides', {})
   50              0.000576   call extend(filetype_overrides, get(g:, 'airline_filetype_overrides', {}), 'force')
                            
   50   0.007683   0.000471   if s:is_excluded_window()
                                return -1
   50              0.000037   endif
                            
   50              0.000165   if &buftype == 'terminal'
    7              0.000026     let w:airline_section_x = ''
    7              0.000020     let w:airline_section_y = ''
   50              0.000037   endif
                            
   50              0.000275   if &previewwindow && empty(get(w:, 'airline_section_a', ''))
                                let w:airline_section_a = 'Preview'
                                let w:airline_section_b = ''
                                let w:airline_section_c = bufname(winbufnr(winnr()))
   50              0.000038   endif
                            
   50              0.000513   if has_key(filetype_overrides, &ft) && ((&filetype == 'help' && &buftype == 'help') || &filetype !~ 'help')
                                " for help files only override it, if the buftype is also of type 'help',
                                " else it would trigger when editing Vim help files
    6              0.000069     let args = filetype_overrides[&ft]
    6   0.002095   0.000092     call airline#extensions#apply_left_override(args[0], args[1])
   50              0.000043   endif
                            
   50              0.000125   if &buftype == 'help'
                                let w:airline_section_x = ''
                                let w:airline_section_y = ''
                                let w:airline_render_right = 1
   50              0.000035   endif
                            
   50              0.000351   for item in items(s:filetype_regex_overrides)
                                if match(&ft, item[0]) >= 0
                                  call airline#extensions#apply_left_override(item[1][0], item[1][1])
                                endif
   50              0.000080   endfor

FUNCTION  <SNR>169_build_command()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/async.vim:43
Called 43 times
Total time:   0.000661
 Self time:   0.000661

count  total (s)   self (s)
   43              0.000305   if has('unix')
   43              0.000273     return ['sh', '-c', a:cmd]
                              endif
                            
                              if has('win32')
                                return has('nvim') ? ['cmd.exe', '/c', a:cmd] : 'cmd.exe /c '.a:cmd
                              endif
                            
                              throw 'unknown os'

FUNCTION  <SNR>129_create()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/autoload/airline/section.vim:17
Called 6 times
Total time:   0.001722
 Self time:   0.001483

count  total (s)   self (s)
    6              0.000017   let _ = ''
   12              0.000060   for idx in range(len(a:parts))
    6   0.000134   0.000075     let part = airline#parts#get(a:parts[idx])
    6              0.000014     let val = ''
    6              0.000028     let add_sep = get(l:, 'add_sep', 0)
                            
    6              0.000028     if exists('part.function')
    6              0.000023       let func = (part.function).'()'
                                elseif exists('part.text')
                                  let func = '"'.(part.text).'"'
                                else
                                  if a:append > 0 && idx != 0
                                    let val .= s:spc.g:airline_left_alt_sep.s:spc
                                  endif
                                  if a:append < 0 && idx != 0
                                    let t = ''
                                    if !add_sep
                                      let t = s:spc.g:airline_right_alt_sep.s:spc
                                    endif
                                    let val = t.val
                                  endif
                                  if exists('part.raw')
                                    let _ .= s:wrap_accent(part, val.(part.raw))
                                    continue
                                  else
                                    let _ .= s:wrap_accent(part, val.a:parts[idx])
                                    continue
                                  endif
    6              0.000004     endif
                            
    6              0.000029     let minwidth = get(part, 'minwidth', 0)
                            
    6              0.000016     if a:append > 0 && idx != 0
                                  let partval = printf('%%{airline#util#append(%s,%s)}', func, minwidth)
                                  " will add an extra separator, if minwidth is zero
                                  let add_sep = (minwidth == 0)
    6              0.000024     elseif a:append < 0 && idx != len(a:parts) - 1
                                  let partval = printf('%%{airline#util#prepend(%s,%s)}', func, minwidth)
                                  " will add an extra separator, if minwidth is zero
                                  let add_sep = (minwidth == 0)
    6              0.000005     else
    6              0.000047       let partval = printf('%%{airline#util#wrap(%s,%s)}', func, minwidth)
    6              0.000012       let add_sep = 0
    6              0.000005     endif
                            
    6              0.000022     if exists('part.condition')
                                  let partval = substitute(partval, '{', '\="{".(part.condition)." ? "', '')
                                  let partval = substitute(partval, '}', ' : ""}', '')
    6              0.000005     endif
                            
    6   0.000247   0.000067     let val .= s:wrap_accent(part, partval)
    6              0.000020     let _ .= val
   12              0.000049   endfor
    6              0.000013   return _

FUNCTION  airline#util#has_lawrencium()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/autoload/airline/util.vim:158
Called 1314 times
Total time:   0.022613
 Self time:   0.022613

count  total (s)   self (s)
 1314              0.008203   if !exists("s:has_lawrencium")
    1              0.000010     let s:has_lawrencium  = exists('*lawrencium#statusline')
 1314              0.001484   endif
 1314              0.003419   return s:has_lawrencium

FUNCTION  airline#highlighter#get_highlight()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/autoload/airline/highlighter.vim:61
Called 4515 times
Total time:   1.667042
 Self time:   0.619661

count  total (s)   self (s)
                              " only check for the cterm reverse attribute
                              " TODO: do we need to check all modes (gui, term, as well)?
 4515              0.086598   let reverse = synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'cterm')
 4515              0.035170   if get(g:, 'airline_highlighting_cache', 0) && has_key(s:hl_groups, a:group)
                                let res = s:hl_groups[a:group]
                                return reverse ? [ res[1], res[0], res[3], res[2], res[4] ] : res
 4515              0.007819   else
 4515   0.286411   0.054865     let ctermfg = s:get_syn(a:group, 'fg', 'cterm')
 4515   0.261755   0.050483     let ctermbg = s:get_syn(a:group, 'bg', 'cterm')
 4515   0.251085   0.046958     let guifg = s:get_syn(a:group, 'fg', 'gui')
 4515   0.374030   0.047906     let guibg = s:get_syn(a:group, 'bg', 'gui')
 4515              0.054801     let bold = synIDattr(synIDtrans(hlID(a:group)), 'bold')
 4515              0.009082     if reverse
                                  let res = s:get_array(guibg, guifg, ctermbg, ctermfg, bold ? ['bold'] : a:000)
 4515              0.004689     else
 4515   0.141450   0.067139       let res = s:get_array(guifg, guibg, ctermfg, ctermbg, bold ? ['bold'] : a:000)
 4515              0.005972     endif
 4515              0.003621   endif
 4515              0.040050   let s:hl_groups[a:group] = res
 4515              0.007608   return res

FUNCTION  provider#clipboard#Call()
    Defined: /usr/local/Cellar/neovim/HEAD-40a7427/share/nvim/runtime/autoload/provider/clipboard.vim:212
Called 4 times
Total time:   4.828433
 Self time:   0.000534

count  total (s)   self (s)
    4              0.000089   if get(s:, 'here', v:false)  " Clipboard provider must not recurse. #7184
                                return 0
    4              0.000009   endif
    4              0.000028   let s:here = v:true
    4              0.000009   try
    4   4.828191   0.000292     return call(s:clipboard[a:method],a:args,s:clipboard)
    4              0.000017   finally
    4              0.000021     let s:here = v:false
    4              0.000010   endtry

FUNCTION  airline#extensions#coc#get_status()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/autoload/airline/extensions/coc.vim:45
Called 1275 times
Total time:   0.100025
 Self time:   0.021821

count  total (s)   self (s)
                              " Shorten text for windows < 91 characters
 1275   0.097001   0.018796   return airline#util#shorten(get(g:, 'coc_status', ''), 91, 9)

FUNCTION  fugitive#CommonDir()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-fugitive/autoload/fugitive.vim:256
Called 1263 times
Total time:   0.072830
 Self time:   0.072830

count  total (s)   self (s)
 1263              0.005850   if empty(a:dir)
                                return ''
 1263              0.001264   endif
 1263              0.007548   if !has_key(s:commondirs, a:dir)
    1              0.000044     if getfsize(a:dir . '/HEAD') < 10
                                  let s:commondirs[a:dir] = ''
    1              0.000018     elseif filereadable(a:dir . '/commondir')
                                  let cdir = get(readfile(a:dir . '/commondir', 1), 0, '')
                                  if cdir =~# '^/\|^\a:/'
                                    let s:commondirs[a:dir] = s:Slash(FugitiveVimPath(cdir))
                                  else
                                    let s:commondirs[a:dir] = simplify(a:dir . '/' . cdir)
                                  endif
    1              0.000001     else
    1              0.000008       let s:commondirs[a:dir] = a:dir
    1              0.000001     endif
 1263              0.001103   endif
 1263              0.005990   return s:commondirs[a:dir]

FUNCTION  <SNR>48_popup()
    Defined: ~/.fzf/plugin/fzf.vim:925
Called 7 times
Total time:   0.236173
 Self time:   0.000598

count  total (s)   self (s)
                              " Size and position
    7              0.000096   let width = min([max([8, a:opts.width > 1 ? a:opts.width : float2nr(&columns * a:opts.width)]), &columns])
    7              0.000087   let height = min([max([4, a:opts.height > 1 ? a:opts.height : float2nr(&lines * a:opts.height)]), &lines - has('nvim')])
    7              0.000049   let row = float2nr(get(a:opts, 'yoffset', 0.5) * (&lines - height))
    7              0.000039   let col = float2nr(get(a:opts, 'xoffset', 0.5) * (&columns - width))
                            
                              " Managing the differences
    7              0.000062   let row = min([max([0, row]), &lines - has('nvim') - height])
    7              0.000042   let col = min([max([0, col]), &columns - width])
    7              0.000027   let row += !has('nvim')
    7              0.000024   let col += !has('nvim')
                            
    7   0.235709   0.000134   call s:create_popup('Normal', { 'row': row, 'col': col, 'width': width, 'height': height })

FUNCTION  coc#util#set_buf_var()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/coc.nvim/autoload/coc/util.vim:843
Called 2 times
Total time:   0.000058
 Self time:   0.000058

count  total (s)   self (s)
    2              0.000034   if !bufloaded(a:bufnr) | return | endif
    1              0.000018   call setbufvar(a:bufnr, a:name, a:val)

FUNCTION  <SNR>48_border_opt()
    Defined: ~/.fzf/plugin/fzf.vim:694
Called 7 times
Total time:   0.113331
 Self time:   0.000403

count  total (s)   self (s)
    7              0.000043   if type(a:window) != type({})
                                return ''
    7              0.000005   endif
                            
                              " Border style
    7              0.000044   let style = tolower(get(a:window, 'border', 'rounded'))
    7              0.000036   if !has_key(a:window, 'border') && !get(a:window, 'rounded', 1)
                                let style = 'sharp'
    7              0.000005   endif
    7              0.000023   if style == 'none' || style == 'no'
                                return ''
    7              0.000004   endif
                            
                              " For --border styles, we need fzf 0.24.0 or above
    7   0.112986   0.000059   call fzf#exec('0.24.0')
    7              0.000024   let opt = ' --border=' . style
    7              0.000024   if has_key(a:window, 'highlight')
                                let color = s:get_color('fg', a:window.highlight)
                                if len(color)
                                  let opt .= ' --color=border:' . color
                                endif
    7              0.000004   endif
    7              0.000012   return opt

FUNCTION  <SNR>176_handle_double_hunk()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/sign.vim:212
Called 26 times
Total time:   0.000515
 Self time:   0.000515

count  total (s)   self (s)
   26              0.000284   if a:modified_lines[0:1] == [[1, 'removed_first_line'], [1, 'removed']]
                                return [[1, 'removed_above_and_below']] + a:modified_lines[2:]
   26              0.000025   endif
                            
   26              0.000061   return a:modified_lines

FUNCTION  coc#float#nvim_refresh_scrollbar()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/coc.nvim/autoload/coc/float.vim:822
Called 309 times
Total time:   0.029721
 Self time:   0.015892

count  total (s)   self (s)
  309   0.023621   0.009791   let id = coc#float#get_related(a:winid, 'scrollbar')
  309              0.002259   if id && nvim_win_is_valid(id)
                                call coc#float#nvim_scrollbar(a:winid)
  309              0.000532   endif

FUNCTION  <SNR>175_process_hunk()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:241
Called 103 times
Total time:   0.051574
 Self time:   0.029929

count  total (s)   self (s)
  103              0.000344   let modifications = []
  103              0.000333   let from_line  = a:hunk[0]
  103              0.000284   let from_count = a:hunk[1]
  103              0.000260   let to_line    = a:hunk[2]
  103              0.000386   let to_count   = a:hunk[3]
                            
  103   0.001279   0.000842   if s:is_added(from_count, to_count)
   26   0.001790   0.000242     call s:process_added(modifications, from_count, to_count, to_line)
   26   0.002036   0.000217     call gitgutter#hunk#increment_lines_added(a:bufnr, to_count)
                            
   77   0.001004   0.000598   elseif s:is_removed(from_count, to_count)
    1   0.000019   0.000008     call s:process_removed(modifications, from_count, to_count, to_line)
    1   0.000065   0.000007     call gitgutter#hunk#increment_lines_removed(a:bufnr, from_count)
                            
   76   0.001092   0.000604   elseif s:is_modified(from_count, to_count)
   62   0.015522   0.013474     call s:process_modified(modifications, from_count, to_count, to_line)
   62   0.005464   0.000536     call gitgutter#hunk#increment_lines_modified(a:bufnr, to_count)
                            
   14   0.000234   0.000135   elseif s:is_modified_and_added(from_count, to_count)
   14   0.007322   0.000172     call s:process_modified_and_added(modifications, from_count, to_count, to_line)
   14   0.001477   0.000149     call gitgutter#hunk#increment_lines_added(a:bufnr, to_count - from_count)
   14   0.001445   0.000120     call gitgutter#hunk#increment_lines_modified(a:bufnr, from_count)
                            
                              elseif s:is_modified_and_removed(from_count, to_count)
                                call s:process_modified_and_removed(modifications, from_count, to_count, to_line)
                                call gitgutter#hunk#increment_lines_modified(a:bufnr, to_count)
                                call gitgutter#hunk#increment_lines_removed(a:bufnr, from_count - to_count)
                            
  103              0.000074   endif
  103              0.000196   return modifications

FUNCTION  airline#highlighter#highlight_modified_inactive()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/autoload/airline/highlighter.vim:222
Called 57 times
Total time:   0.058994
 Self time:   0.007561

count  total (s)   self (s)
   57              0.000531   if getbufvar(a:bufnr, '&modified')
   16              0.000379     let colors = exists('g:airline#themes#{g:airline_theme}#palette.inactive_modified.airline_c') ? g:airline#themes#{g:airline_theme}#palette.inactive_modified.airline_c : []
   41              0.000056   else
   41              0.003495     let colors = exists('g:airline#themes#{g:airline_theme}#palette.inactive.airline_c') ? g:airline#themes#{g:airline_theme}#palette.inactive.airline_c : []
   57              0.000080   endif
                            
   57              0.000351   if !empty(colors)
   57   0.053226   0.001793     call airline#highlighter#exec('airline_c'.(a:bufnr).'_inactive', colors)
   57              0.000070   endif

FUNCTION  50()
    Defined: ~/.fzf/plugin/fzf.vim:774
Called 1 time
Total time:   0.000020
 Self time:   0.000020

count  total (s)   self (s)
    1              0.000008     if a:inplace && bufnr('') == self.buf
                                  if bufexists(self.pbuf)
                                    execute 'keepalt b' self.pbuf
                                  endif
                                  " No other listed buffer
                                  if bufnr('') == self.buf
                                    enew
                                  endif
    1              0.000001     endif

FUNCTION  airline#extensions#branch#get_head()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/autoload/airline/extensions/branch.vim:308
Called 1263 times
Total time:   2.820241
 Self time:   0.105309

count  total (s)   self (s)
 1263   2.644968   0.014582   let head = airline#extensions#branch#head()
 1263   0.033769   0.022130   let winwidth = get(airline#parts#get('branch'), 'minwidth', 120)
 1263              0.011340   let minwidth = empty(get(b:, 'airline_hunks', '')) ? 14 : 7
 1263   0.089938   0.017033   let head = airline#util#shorten(head, winwidth, minwidth)
 1263              0.012872   let symbol = get(g:, 'airline#extensions#branch#symbol', g:airline_symbols.branch)
 1263              0.022198   return empty(head) ? get(g:, 'airline#extensions#branch#empty_message', '') : printf('%s%s', empty(symbol) ? '' : symbol.(g:airline_symbols.space), head)

FUNCTION  coc#float#has_float()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/coc.nvim/autoload/coc/float.vim:10
Called 92 times
Total time:   0.011528
 Self time:   0.011528

count  total (s)   self (s)
   92              0.001033   if s:is_vim
                                if !exists('*popup_list')
                                  return 0
                                endif
                                let arr = filter(popup_list(), 'getwinvar(v:val,"float",0)&&popup_getpos(v:val)["visible"]')
                                return !empty(arr)
   92              0.000247   endif
  207              0.002502   for i in range(1, winnr('$'))
  115              0.001076     if getwinvar(i, 'float')
                                  return 1
  115              0.000185     endif
  207              0.000555   endfor
   92              0.000420   return 0

FUNCTION  54()
    Defined: ~/.fzf/plugin/fzf.vim:785
Called 1 time
Total time:   0.044957
 Self time:   0.001354

count  total (s)   self (s)
    1   0.000050   0.000026     if s:getpos() == self.ppos " {'window': 'enew'}
                                  for [opt, val] in items(self.winopts)
                                    execute 'let' opt '=' val
                                  endfor
                                  call self.switch_back(1)
    1              0.000001     else
    1              0.000006       if bufnr('') == self.buf
                                    " We use close instead of bd! since Vim does not close the split when
                                    " there's no other listed buffer (nvim +'set nobuflisted')
    1   0.044741   0.001191         close
    1              0.000004       endif
    1              0.000014       silent! execute 'tabnext' self.ppos.tab
    1              0.000010       silent! execute self.ppos.win.'wincmd w'
    1              0.000001     endif
                            
    1              0.000007     if bufexists(self.buf)
                                  execute 'bd!' self.buf
    1              0.000001     endif
                            
    1   0.000051   0.000029     if &lines == self.lines && &columns == self.columns && s:getpos() == self.ppos
    1              0.000011       execute self.winrest
    1              0.000001     endif
                            
    1   0.000024   0.000017     if !s:exit_handler(a:code, self.command, 1)
    1              0.000001       return
                                endif
                            
                                call s:pushd(self.dict)
                                let lines = s:collect(self.temps)
                                call s:callback(self.dict, lines)
                                call self.switch_back(s:getpos() == self.ppos)

FUNCTION  56()
    Defined: ~/.fzf/plugin/fzf.vim:774
Called 1 time
Total time:   0.000029
 Self time:   0.000029

count  total (s)   self (s)
    1              0.000010     if a:inplace && bufnr('') == self.buf
                                  if bufexists(self.pbuf)
                                    execute 'keepalt b' self.pbuf
                                  endif
                                  " No other listed buffer
                                  if bufnr('') == self.buf
                                    enew
                                  endif
    1              0.000001     endif

FUNCTION  coc#rpc#notify()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/coc.nvim/autoload/coc/rpc.vim:95
Called 820 times
Total time:   0.282742
 Self time:   0.047794

count  total (s)   self (s)
  820   0.053563   0.018078   if !coc#rpc#ready()
                                return ''
  820              0.001128   endif
  820   0.220900   0.021436   call s:client['notify'](a:method, a:args)
  820              0.002448   return ''

FUNCTION  <SNR>172_function()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-fugitive/autoload/fugitive.vim:17
Called 16 times
Total time:   0.000737
 Self time:   0.000737

count  total (s)   self (s)
   16              0.000716   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '.*\zs<SNR>\d\+_'),''))

FUNCTION  <SNR>178_movement_tick()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-smoothie/autoload/smoothie.vim:126
Called 68 times
Total time:   0.187077
 Self time:   0.149004

count  total (s)   self (s)
   68              0.002191   if s:target_displacement == 0
    4   0.000313   0.000116     call s:stop_moving()
    4              0.000013     return
   64              0.000178   endif
                            
   64   0.003948   0.002951   let l:subline_step_size = s:subline_position + (g:smoothie_update_interval/1000.0 * s:compute_velocity())
   64              0.001102   let l:step_size = float2nr(trunc(l:subline_step_size))
                            
   64              0.000679   if abs(l:step_size) > abs(s:target_displacement)
                                " clamp step size to prevent overshooting the target
                                let l:step_size = s:target_displacement
   64              0.000121   end
                            
   64   0.037971   0.001093   if s:step_many(l:step_size)
                                " we've collided with either buffer end
                                call s:stop_moving()
   64              0.000136   else
   64              0.000464     let s:target_displacement -= l:step_size
   64              0.000505     let s:subline_position = l:subline_step_size - l:step_size
   64              0.000106   endif
                            
   64              0.000171   if l:step_size
                                " Usually Vim handles redraws well on its own, but without explicit redraw
                                " I've encountered some sporadic display artifacts.  TODO: debug further.
   48              0.135177     redraw
   64              0.000389   endif

FUNCTION  airline#extensions#hunks#get_hunks()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/autoload/airline/extensions/hunks.vim:95
Called 1263 times
Total time:   0.775346
 Self time:   0.355674

count  total (s)   self (s)
 1263              0.008523   if !get(w:, 'airline_active', 0)
                                return ''
 1263              0.001293   endif
                              " Cache values, so that it isn't called too often
 1263   0.080270   0.052704   if exists("b:airline_hunks") && get(b:,  'airline_changenr', 0) == b:changedtick && airline#util#winwidth() == get(s:, 'airline_winwidth', 0) && get(b:, 'source_func', '') isnot# 's:get_hunks_signify' && get(b:, 'source_func', '') isnot# 's:get_hunks_gitgutter' && get(b:, 'source_func', '') isnot# 's:get_hunks_empty' && get(b:, 'source_func', '') isnot# 's:get_hunks_changes' && get(b:, 'source_func', '') isnot# 's:get_hunks_coc'
                                return b:airline_hunks
 1263              0.001741   endif
 1263   0.294092   0.016942   let hunks = airline#extensions#hunks#get_raw_hunks()
 1263              0.004147   let string = ''
 1263   0.030104   0.018754   let winwidth = get(airline#parts#get('hunks'), 'minwidth', 100)
 1263              0.005820   if !empty(hunks)
                                " hunks should contain [added, changed, deleted]
 4976              0.021952     for i in [0, 1, 2]
 3732   0.125027   0.050970       if (s:non_zero_only == 0 && airline#util#winwidth() > winwidth) || hunks[i] > 0
 3732              0.052307         let string .= printf('%s%s ', s:hunk_symbols[i], hunks[i])
 3732              0.004770       endif
 4976              0.008725     endfor
 1263              0.001560   endif
 1263   0.028324   0.022863   if index(airline#extensions#get_loaded_extensions(), 'branch') == -1 && string[-1:] == ' '
                                " branch extension not loaded, skip trailing whitespace
                                let string = string[0:-2]
 1263              0.001437   endif
                            
 1263              0.005981   let b:airline_hunks = string
 1263              0.005933   let b:airline_changenr = b:changedtick
 1263   0.043058   0.018970   let s:airline_winwidth = airline#util#winwidth()
 1263              0.003207   return string

FUNCTION  <SNR>143_build_sections()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/autoload/airline/extensions/default.vim:35
Called 75 times
Total time:   0.067225
 Self time:   0.011095

count  total (s)   self (s)
  384              0.004879   for key in a:keys
  309              0.001503     if (key == 'warning' || key == 'error') && !a:context.active
   34              0.000034       continue
  275              0.000200     endif
  275   0.058908   0.002778     call s:add_section(a:builder, a:context, key)
  350              0.000439   endfor

FUNCTION  <SNR>88_persist()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-obsession/plugin/obsession.vim:69
Called 20 times
Total time:   0.001749
 Self time:   0.001749

count  total (s)   self (s)
   20              0.000133   if exists('g:SessionLoad')
                                return ''
   20              0.000019   endif
   20              0.000143   let sessionoptions = &sessionoptions
   20              0.000108   if exists('g:this_obsession')
                                try
                                  set sessionoptions-=blank sessionoptions-=options sessionoptions+=tabpages
                                  execute 'mksession! '.fnameescape(g:this_obsession)
                                  let body = readfile(g:this_obsession)
                                  call insert(body, 'let g:this_session = v:this_session', -3)
                                  call insert(body, 'let g:this_obsession = v:this_session', -3)
                                  if type(get(g:, 'obsession_append')) == type([])
                                    for line in g:obsession_append
                                      call insert(body, line, -3)
                                    endfor
                                  endif
                                  call writefile(body, g:this_obsession)
                                  let g:this_session = g:this_obsession
                                  exe s:doautocmd_user('Obsession')
                                catch /^Vim(mksession):E11:/
                                  return ''
                                catch
                                  unlet g:this_obsession
                                  let &l:readonly = &l:readonly
                                  return 'echoerr '.string(v:exception)
                                finally
                                  let &sessionoptions = sessionoptions
                                endtry
   20              0.000018   endif
   20              0.000032   return ''

FUNCTION  airline#extensions#fzf#apply()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/autoload/airline/extensions/fzf.vim:28
Called 36 times
Total time:   0.000714
 Self time:   0.000620

count  total (s)   self (s)
   36              0.000121   if &filetype ==# 'fzf'
    7              0.000026     let spc = g:airline_symbols.space
    7   0.000124   0.000072     call a:1.add_section('airline_a', spc.'FZF'.spc)
    7   0.000086   0.000044     call a:1.add_section('airline_c', '')
    7              0.000011     return 1
   29              0.000022   endif

FUNCTION  gitgutter#utility#getbufvar()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:21
Called 1788 times
Total time:   0.061095
 Self time:   0.061095

count  total (s)   self (s)
 1788              0.016913   let ggvars = getbufvar(a:buffer, 'gitgutter')
 1788              0.026558   if type(ggvars) == type({}) && has_key(ggvars, a:varname)
 1404              0.006914     return ggvars[a:varname]
  384              0.000504   endif
  384              0.003546   if a:0
  379              0.000972     return a:1
    5              0.000004   endif

FUNCTION  <SNR>145_set_cursor()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-startify/autoload/startify.vim:817
Called 26 times
Total time:   0.004225
 Self time:   0.004225

count  total (s)   self (s)
   26              0.000486   let b:startify.oldline = exists('b:startify.newline') ? b:startify.newline : s:fixed_column
   26              0.000201   let b:startify.newline = line('.')
                            
                              " going up (-1) or down (1)
   26              0.000299   if b:startify.oldline == b:startify.newline && col('.') != s:fixed_column && !b:startify.leftmouse
    1              0.000011     let movement = 2 * (col('.') > s:fixed_column) - 1
    1              0.000006     let b:startify.newline += movement
   25              0.000162   else
   25              0.000277     let movement = 2 * (b:startify.newline > b:startify.oldline) - 1
   25              0.000128     let b:startify.leftmouse = 0
   26              0.000044   endif
                            
                              " skip section headers lines until an entry is found
   38              0.000434   while index(b:startify.section_header_lines, b:startify.newline) != -1
   12              0.000064     let b:startify.newline += movement
   38              0.000103   endwhile
                            
                              " skip blank lines between lists
   26              0.000228   if empty(getline(b:startify.newline))
    1              0.000005     let b:startify.newline += movement
   26              0.000042   endif
                            
                              " don't go beyond first or last entry
   26              0.000480   let b:startify.newline = max([b:startify.firstline, min([b:startify.lastline, b:startify.newline])])
                            
   26              0.000245   call cursor(b:startify.newline, s:fixed_column)

FUNCTION  FugitiveParse()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-fugitive/plugin/fugitive.vim:71
Called 20 times
Total time:   0.004306
 Self time:   0.002477

count  total (s)   self (s)
   20   0.004029   0.002200   let path = s:Slash(a:0 ? a:1 : @%)
   20              0.000179   if path !~# '^fugitive:'
   20              0.000062     return ['', '']
                              endif
                              let vals = matchlist(path, '\c^fugitive:\%(//\)\=\(.\{-\}\)\%(//\|::\)\(\x\{40,\}\|[0-3]\)\(/.*\)\=$')
                              if len(vals)
                                return [(vals[2] =~# '^.$' ? ':' : '') . vals[2] . substitute(vals[3], '^/', ':', ''), vals[1]]
                              endif
                              let v:errmsg = 'fugitive: invalid Fugitive URL ' . path
                              throw v:errmsg

FUNCTION  fzf_preview#remote#handler_to_process#call_funcref_or_fallback_default_process()
    Defined: ~/Repos/Configs/Neovim/.config/coc/extensions/node_modules/coc-fzf-preview/autoload/fzf_preview/remote/handler_to_process.vim:1
Called 4 times
Total time:   0.765607
 Self time:   0.000284

count  total (s)   self (s)
    4              0.000065   if a:env ==# 'remote'
                                call s:call_remote_plugin(a:default_process_function_name, a:expect_key, a:lines, a:process_name)
    4              0.000017   elseif a:env ==# 'coc'
    4   0.765442   0.000119     call s:call_coc(a:default_process_function_name, a:expect_key, a:lines, a:process_name)
    4              0.000011   endif

FUNCTION  animate#window_absolute()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/animate.vim/plugin/animate.vim:216
Called 13 times
Total time:   0.005460
 Self time:   0.000219

count  total (s)   self (s)
   13   0.005444   0.000203   call animate#window_delta( float2nr(a:width - winwidth(0)), float2nr(a:height - winheight(0)), )

FUNCTION  airline#util#prepend()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/autoload/airline/util.vim:63
Called 6375 times
Total time:   0.102151
 Self time:   0.102151

count  total (s)   self (s)
 6375              0.035875   if a:minwidth > 0 && airline#util#winwidth() < a:minwidth
                                return ''
 6375              0.005835   endif
 6375              0.041722   return empty(a:text) ? '' : a:text.s:spc.g:airline_right_alt_sep.s:spc

FUNCTION  lens#get_rows()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/lens.vim/plugin/lens.vim:92
Called 13 times
Total time:   0.000049
 Self time:   0.000049

count  total (s)   self (s)
   13              0.000040   return line('$')

FUNCTION  <SNR>143_add_section()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/autoload/airline/extensions/default.vim:47
Called 275 times
Total time:   0.056130
 Self time:   0.018658

count  total (s)   self (s)
  275              0.006148     let condition = (a:key is# "warning" || a:key is# "error") && (v:version == 704 && !has("patch1511"))
                                " i have no idea why the warning section needs special treatment, but it's
                                " needed to prevent separators from showing up
  275   0.006859   0.002607     if ((a:key == 'error' || a:key == 'warning') && empty(s:get_section(a:context.winnr, a:key)))
                                  return
  275              0.000200     endif
  275              0.000442     if condition
                                  call a:builder.add_raw('%(')
  275              0.000231     endif
  275   0.038197   0.004977     call a:builder.add_section('airline_'.a:key, s:get_section(a:context.winnr, a:key))
  275              0.000493     if condition
                                  call a:builder.add_raw('%)')
  275              0.000229     endif

FUNCTION  <SNR>132_update_hg_branch()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/autoload/airline/extensions/branch.vim:138
Called 1263 times
Total time:   0.153219
 Self time:   0.131447

count  total (s)   self (s)
 1263   0.033154   0.011382   if airline#util#has_lawrencium()
                                let cmd='LC_ALL=C hg qtop'
                                let stl=lawrencium#statusline()
                                let file=expand('%:p')
                                if !empty(stl) && get(b:, 'airline_do_mq_check', 1)
                                  if g:airline#init#vim_async
                                    noa call airline#async#get_mq_async(cmd, file)
                                  elseif has("nvim")
                                    noa call airline#async#nvim_get_mq_async(cmd, file)
                                  else
                                    " remove \n at the end of the command
                                    let output=system(cmd)[0:-2]
                                    noa call airline#async#mq_output(output, file)
                                  endif
                                endif
                                " do not do mq check anymore
                                let b:airline_do_mq_check = 0
                                if exists("b:mq") && !empty(b:mq)
                                  if stl is# 'default'
                                    " Shorten default a bit
                                    let stl='def'
                                  endif
                                  let stl.=' ['.b:mq.']'
                                endif
                                let s:vcs_config['mercurial'].branch = stl
 1263              0.001330   else
 1263              0.007413     let s:vcs_config['mercurial'].branch = ''
 1263              0.001468   endif

FUNCTION  <SNR>130_group_not_done()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/autoload/airline/highlighter.vim:25
Called 1440 times
Total time:   0.029311
 Self time:   0.029311

count  total (s)   self (s)
 1440              0.011123   if index(a:list, a:name) == -1
 1320              0.011200     call add(a:list, a:name)
 1320              0.002134     return 1
  120              0.000116   else
  120              0.000251     if &vbs
                                  echomsg printf("airline: group: %s already done, skipping", a:name)
  120              0.000081     endif
  120              0.000146     return 0
                              endif

FUNCTION  airline#util#getbufvar()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/autoload/airline/util.vim:71
Called 93 times
Total time:   0.000654
 Self time:   0.000654

count  total (s)   self (s)
   93              0.000538     return getbufvar(a:bufnr, a:key, a:def)

FUNCTION  <SNR>169_on_stderr_nvim()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/async.vim:66
Called 55 times
Total time:   0.001714
 Self time:   0.001015

count  total (s)   self (s)
   55              0.000410   if a:data != ['']  " With Neovim there is always [''] reported on stderr.
   12   0.000952   0.000254     call self.handler.err(self.buffer)
   55              0.000055   endif

FUNCTION  <SNR>132_update_untracked()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/autoload/airline/extensions/branch.vim:192
Called 1263 times
Total time:   0.499594
 Self time:   0.357240

count  total (s)   self (s)
 1263              0.108075   let file = expand("%:p")
 1263              0.026179   if empty(file) || isdirectory(file) || !empty(&buftype)
   92              0.000179     return
 1171              0.001373   endif
                            
 1171              0.004763   let needs_update = 1
 1171              0.016958   let vcs_checks   = get(g:, "airline#extensions#branch#vcs_checks", ["untracked", "dirty"])
 3513              0.016015   for vcs in keys(s:vcs_config)
 2342              0.031628     if file =~ s:vcs_config[vcs].exclude
                                  " Skip check for files that live in the exclude directory
                                  let needs_update = 0
 2342              0.002836     endif
 2342              0.018394     if has_key(s:vcs_config[vcs].untracked, file)
 1120              0.003691       let needs_update = 0
 1120   0.062231   0.024580       call airline#extensions#branch#update_untracked_config(file, vcs)
 2342              0.002618     endif
 3513              0.005956   endfor
                            
 1171              0.002885   if !needs_update
 1120              0.001876     return
   51              0.000042   endif
                            
  153              0.000735   for vcs in keys(s:vcs_config)
                                " only check, for git, if fugitive is installed
                                " and for 'hg' if lawrencium is installed, else skip
  102   0.007998   0.001371     if vcs is# 'git' && (!airline#util#has_fugitive() && !airline#util#has_gina())
                                  continue
  102   0.001917   0.001075     elseif vcs is# 'mercurial' && !airline#util#has_lawrencium()
   51              0.000085       continue
   51              0.000044     endif
   51              0.000240     let config = s:vcs_config[vcs]
                                " Note that asynchronous update updates s:vcs_config only, and only
                                " s:update_untracked updates b:buffer_vcs_config. If s:vcs_config is
                                " invalidated again before s:update_untracked is called, then we lose the
                                " result of the previous call, i.e. the head string is not updated. It
                                " doesn't happen often in practice, so we let it be.
   51              0.000326     if index(vcs_checks, 'untracked') > -1
   51   0.068661   0.024959       call airline#async#vcs_untracked(config, file, vcs)
   51              0.000086     endif
                                " Check clean state of repo
   51              0.000442     if index(vcs_checks, 'dirty') > -1
   51   0.054646   0.001114       call airline#async#vcs_clean(config.dirty, file, vcs)
   51              0.000193     endif
  102              0.000525   endfor

FUNCTION  gitgutter#hunk#set_hunks()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/hunk.vim:5
Called 26 times
Total time:   0.003023
 Self time:   0.000718

count  total (s)   self (s)
   26   0.001375   0.000392   call gitgutter#utility#setbufvar(a:bufnr, 'hunks', a:hunks)
   26   0.001611   0.000289   call s:reset_summary(a:bufnr)

FUNCTION  <SNR>142_get_accented_line()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/autoload/airline/builder.vim:163
Called 306 times
Total time:   0.023866
 Self time:   0.023866

count  total (s)   self (s)
  306              0.000773   if a:self._context.active
                                " active window
  226              0.000543     let contents = []
  226              0.002609     let content_parts = split(a:contents, '__accent')
  570              0.001251     for cpart in content_parts
  344              0.003531       let accent = matchstr(cpart, '_\zs[^#]*\ze')
  344              0.001437       call add(contents, cpart)
  570              0.000692     endfor
  226              0.001465     let line = join(contents, a:group)
  226              0.002725     let line = substitute(line, '__restore__', a:group, 'g')
   80              0.000069   else
                                " inactive window
   80              0.001290     let line = substitute(a:contents, '%#__accent[^#]*#', '', 'g')
   80              0.000829     let line = substitute(line, '%#__restore__#', '', 'g')
  306              0.000255   endif
  306              0.000532   return line

FUNCTION  <SNR>178_step_many()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-smoothie/autoload/smoothie.vim:63
Called 64 times
Total time:   0.036879
 Self time:   0.010144

count  total (s)   self (s)
   64              0.000529   let l:remaining_lines = a:lines
  172              0.000560   while 1
  172              0.000837     if l:remaining_lines < 0
  108   0.028236   0.001502       if s:step_up()
                                    return 1
  108              0.000222       endif
  108              0.000710       let l:remaining_lines += 1
   64              0.000246     elseif l:remaining_lines > 0
                                  if s:step_down()
                                    return 1
                                  endif
                                  let l:remaining_lines -= 1
   64              0.000094     else
   64              0.000137       return 0
  108              0.000143     endif
  108              0.000223   endwhile

FUNCTION  <SNR>144_reset_tick()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter.vim:166
Called 12 times
Total time:   0.000796
 Self time:   0.000240

count  total (s)   self (s)
   12   0.000773   0.000217   call gitgutter#utility#setbufvar(a:bufnr, 'tick', 0)

FUNCTION  fzf#run()
    Defined: ~/.fzf/plugin/fzf.vim:414
Called 7 times
Total time:   0.631594
 Self time:   0.040447

count  total (s)   self (s)
    7              0.000024 try
    7   0.000574   0.000153   let [shell, shellslash, shellcmdflag, shellxquote] = s:use_sh()
                            
    7              0.000088   let dict   = exists('a:1') ? copy(a:1) : {}
    7   0.000264   0.000092   let temps  = { 'result': s:fzf_tempname() }
    7   0.000201   0.000106   let optstr = s:evaluate_opts(get(dict, 'options', ''))
    7              0.000010   try
    7   0.001035   0.000117     let fzf_exec = fzf#shellescape(fzf#exec())
                              catch
                                throw v:exception
    7              0.000011   endtry
                            
    7              0.000032   if !has_key(dict, 'dir')
    7   0.000682   0.000083     let dict.dir = s:fzf_getcwd()
    7              0.000016   endif
    7              0.000081   if has('win32unix') && has_key(dict, 'dir')
                                let dict.dir = fnamemodify(dict.dir, ':p')
    7              0.000007   endif
                            
    7              0.000028   if has_key(dict, 'source')
    7              0.000026     let source = dict.source
    7              0.000030     let type = type(source)
    7              0.000015     if type == 1
                                  let prefix = '( '.source.' )|'
    7              0.000013     elseif type == 3
    7   0.000190   0.000078       let temps.input = s:fzf_tempname()
    7              0.037296       call writefile(source, temps.input)
    7   0.000631   0.000265       let prefix = (s:is_win ? 'type ' : 'cat ').fzf#shellescape(temps.input).'|'
                                else
                                  throw 'Invalid source type'
    7              0.000005     endif
                              else
                                let prefix = ''
    7              0.000005   endif
                            
    7              0.000057   let prefer_tmux = get(g:, 'fzf_prefer_tmux', 0) || has_key(dict, 'tmux')
    7              0.000083   let use_height = has_key(dict, 'down') && !has('gui_running') && !(has('nvim') || s:is_win || has('win32unix') || s:present(dict, 'up', 'left', 'right', 'window')) && executable('tput') && filereadable('/dev/tty')
    7              0.000056   let has_vim8_term = has('terminal') && has('patch-8.0.995')
    7              0.000083   let has_nvim_term = has('nvim-0.2.1') || has('nvim') && !s:is_win
    7              0.000067   let use_term = has_nvim_term || has_vim8_term && !has('win32unix') && (has('gui_running') || s:is_win || !use_height && s:present(dict, 'down', 'up', 'left', 'right', 'window'))
    7              0.000072   let use_tmux = (has_key(dict, 'tmux') || (!use_height && !use_term || prefer_tmux) && !has('win32unix') && s:splittable(dict)) && s:tmux_enabled()
    7              0.000014   if prefer_tmux && use_tmux
                                let use_height = 0
                                let use_term = 0
    7              0.000005   endif
    7              0.000009   if use_height
                                let height = s:calc_size(&lines, dict.down, dict)
                                let optstr .= ' --height='.height
    7              0.000010   elseif use_term
    7              0.000029     let optstr .= ' --no-height'
    7              0.000005   endif
    7   0.113447   0.000116   let optstr .= s:border_opt(get(dict, 'window', 0))
    7              0.000080   let command = prefix.(use_tmux ? s:fzf_tmux(dict) : fzf_exec).' '.optstr.' > '.temps.result
                            
    7              0.000010   if use_term
    7   0.475289   0.000179     return s:execute_term(dict, command, temps)
                              endif
                            
                              let lines = use_tmux ? s:execute_tmux(dict, command, temps) : s:execute(dict, command, use_height, temps)
                              call s:callback(dict, lines)
                              return lines
    7              0.000013 finally
    7   0.000245   0.000224   let [&shell, &shellslash, &shellcmdflag, &shellxquote] = [shell, shellslash, shellcmdflag, shellxquote]
    7              0.000031 endtry

FUNCTION  airline#extensions#get_loaded_extensions()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/autoload/airline/extensions.vim:499
Called 1263 times
Total time:   0.005461
 Self time:   0.005461

count  total (s)   self (s)
 1263              0.004168   return s:loaded_ext

FUNCTION  airline#builder#new()
    Defined: ~/Repos/Configs/Neovim/.config/nvim/plugged/vim-airline/autoload/airline/builder.vim:229
Called 57 times
Total time:   0.002938
 Self time:   0.002938

count  total (s)   self (s)
   57              0.000690   let builder = copy(s:prototype)
   57              0.000217   let builder._context = a:context
   57              0.000160   let builder._sections = []
                            
   57              0.001515   call extend(builder._context, { 'left_sep': g:airline_left_sep, 'left_alt_sep': g:airline_left_alt_sep, 'right_sep': g:airline_right_sep, 'right_alt_sep': g:airline_right_alt_sep, }, 'keep')
   57              0.000180   return builder

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
    4   4.828433   0.000534  provider#clipboard#Call()
    4   4.827523   0.005101  <SNR>146_try_cmd()
    2   3.408768   0.000227  31()
 1263   2.820241   0.105309  airline#extensions#branch#get_head()
 1463   2.681214   0.511198  airline#check_mode()
 1263   2.630387   0.076851  airline#extensions#branch#head()
   12   2.236405   0.000460  coc#rpc#request()
   12   2.235478   0.587313  <SNR>59_request()
   57   2.073545   0.270326  airline#highlighter#highlight()
 1263   2.041387   0.152855  <SNR>132_update_branch()
    8   1.977612   0.000106  CocAction()
 1263   1.735314   0.143539  <SNR>132_update_git_branch()
 4515   1.667042   0.619661  airline#highlighter#get_highlight()
 1263   1.504699   0.090012  FugitiveHead()
    2   1.419131   0.000149  30()
 2285   1.349733   0.263049  airline#highlighter#exec()
 1263   1.328073   0.235787  fugitive#Head()
  908   1.258052   0.068451  <SNR>130_exec_separator()
    4   1.217976   0.000619  <SNR>48_callback()
    4   1.212796   0.000121  <SNR>160_coc_handler()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
18060              0.973069  <SNR>130_get_syn()
 1263   1.092286   0.703938  fugitive#Find()
 4515   1.667042   0.619661  airline#highlighter#get_highlight()
   12   2.235478   0.587313  <SNR>59_request()
 1463   2.681214   0.511198  airline#check_mode()
 1263   0.499594   0.357240  <SNR>132_update_untracked()
 1263   0.775346   0.355674  airline#extensions#hunks#get_hunks()
16611              0.355136  airline#util#winwidth()
 1263   0.459634   0.318368  airline#extensions#whitespace#check()
   43   0.278949   0.273822  gitgutter#async#execute()
   57   2.073545   0.270326  airline#highlighter#highlight()
 2285   1.349733   0.263049  airline#highlighter#exec()
 1275   0.267960   0.255493  airline#extensions#fugitiveline#bufname()
 1263   1.328073   0.235787  fugitive#Head()
 8841              0.233466  airline#util#append()
   13   0.412337   0.231692  <SNR>19_SynSet()
 5064   0.330535   0.203544  airline#util#shorten()
 2530   0.213752   0.195600  FugitiveGitDir()
14141   0.227664   0.181219  airline#util#wrap()
  820   0.199464   0.180924  <SNR>59_notify()

